#summary A brief comparison between Ela and Haskell.
#labels Featured

== Introduction ==

This article provides a brief overview of differences between Ela and Haskell. It can be used a "quick start" guide for those who are familiar with Haskell.


== Feature comparison ==

||             || *Ela* || *Haskell* ||
|| Major programming paradigm || Functional || Functional ||
|| Syntax || ML style, layout based || ML style, layout based ||
|| Purity || Impure, supports records with optional mutable fields || Pure ||
|| Type system || No type system, only dynamic (run-time) typing || Statically typed with type inference ||
|| Type strength || Strong || Strong ||
|| Type safety || Safe || Safe ||
|| Evaluation strategy || Strict by default, lazy by demand || Lazy by default, string by demand ||
|| Pattern matching || Yes || Yes ||
|| Function definition by pattern matching || Yes || Yes ||
|| Algebraic types || Yes, through polymorphic variants || Yes ||
|| First-class modules || Yes || No ||
|| OOP support || Through duck typing and modules || Through existential types ||
|| Monads || No || Yes ||
|| Exceptions || Through structured exception handling || Through monads ||
|| Curried functions || Yes, all functions are curried || Yes, all functions are curried ||
|| Operators as functions || Yes || Yes ||

== Syntax overview ==

===Global bindings===

Ela always requires `let` keyword for both global and local bindings (local bindings can be optionally done through `where` construct).

Haskell:

{{{
x = 0

fib a b 0 = a
fib a b n = fib b (a + b) (n - 1)
}}}

Ela:

{{{
let x = 0

let fib a b 0 = a
    fib a b n = fib b (a + b) (n - 1)
}}}

===Local bindings===

Both Ela and Haskell use `let` and `where` constructs for local bindings:

Haskell:

{{{
fib = fib' 0 1
      where fib' a b 0 = a
            fib' a b n = fib' b (a + b) (n - 1)
}}}

Ela:

{{{
let fib = fib' 0 1
          where fib' a b 0 = a
                fib' a b n = fib' b (a + b) (n - 1)
}}}

Haskell:

{{{
fib = let fib' a b 0 = a
          fib' a b n = fib' b (a + b) (n - 1)
      in fib' 0 1
}}}

Ela:

{{{
let fib = let fib' a b 0 = a
             fib' a b n = fib' b (a + b) (n - 1)
          in fib' 0 1
}}}

===List construction and list pattern matching===

By default Ela uses `(::)` operator for list construction. Haskell uses `(:)` operator.

Haskell:

{{{
xs = 1:2:3:[]

(y:ys) = xs
}}}

Ela:

{{{
let xs = 1::2::3::[]

let (y::ys) = xs
}}}

===Algebraic data types===

Haskell supports them. Ela provides a support for polymorphic variants which can be used in a similar fashion. Polymorphic variants don't have to be declared.

Haskell:

{{{
data Couple a = Foo a | Bar a

unbox (Foo a) = a
unbox (Bar a) = a
}}}

Ela:

{{{
let unbox (`Foo a) = a
          (`Bar a) = a
}}}

===Partial operator application===

Both languages support it.

Haskell:

{{{
div2 = (/2)

x = div2 10 {- 5.0 -}
}}}

Ela:

{{{
let div2 = (/2)

let x = div2 10 {- 5 -}
}}}

===Pattern matching===

Haskell uses `case` expression, when Ela have `match` expression. Layout rules for both constructs are similar.

Haskell:

{{{
xs = 1:2:3:[]

res = case xs of 
           (x:xs) -> x
           []     -> 0  
}}}

Ela:

{{{
let xs = 1:2:3:[]

let res = match xs with 
                x::xs = x
                []    = 0  
}}}

===Guards===

Both Haskell and Ela support guards in a similar way.

Haskell:

{{{
x = case (1,2) of
         (x,y) | x > y      -> x
               | x < y      -> y
               | otherwise  -> x + y
}}}

Ela:

{{{
let x = match (1,2) with
              (x,y) | x > y -> x
                    | x < y -> y
                    | else  -> x + y
}}}

===Ranges===

Both Ela and Haskell support rages with similar syntax.

Haskell:

{{{
r1 = [1..] {- infinite range -}

r2 = [10,9..] {- infinite range -}

r3 = [1..10] {- finite range -}

r4 = [10,9..1] {- finite range -}
}}}

Ela:

{{{
let r1 = [1..] //infinite range

let r2 = [10,9..] //infinite range

let r3 = [1..10] //finite range

let r4 = [10,9..1] //finite range
}}}


===Comprehensions===

Both Ela and Haskell support comprehensions but Ela syntax is slightly different. Also comprehensions in Ela are strict by default.

Haskell:

{{{
xs = [x+y | x <- [1..10], y <- [10,9..1], x `mod` y == 0]
}}}

Ela:

{{{
let xs = [x+y \\ x <- [1..10], y <- [10,9..1] | x % y == 0] //strict

let xs' = [& x+y \\ x <- [1..10], y <- [10,9..1] | x % y == 0] //lazy
}}}

===Non-strict evaluation===

In Haskell evaluation is non-strict by default. In Ela one should explicitely mark a certain expression as lazy.

Haskell:

{{{
map' f (x:xs) = f x : map' f xs
map' _ []     = []

cycle' xs = xs ++ cycle xs
}}}

Ela:

{{{
let map' f x::xs = f x :: (& map' f xs)
    map' _ []    = []

let cycle' xs = xs ++ (& cycle xs)
}}}