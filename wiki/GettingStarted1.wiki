#summary Gettings started with Ela using Ela interactive environment (WIP)

= Introduction =

Current Ela implementation is a single managed DLL that doesn't require any installation and can be executed under CLR and Mono. You will require .NET 3.5 or higher to run it under CLR or Mono 2.6 or higher to run it under Mono.

A command line utility Ela Console (_elac_) that comes with Ela supports both platforms as well and can be used for various purposes - you can execute Ela source code files using it (i.e. _elac HelloWorld.ela_), compile them into object files (_.elaobj_) or just output byte code to the console or use interactive mode for testing and debugging. Lunch _elac_ with a _-help_ switch to view all the available options.

In order to start an interactive session you don't have to provide any command line parameters to _elac_. Just double click the file. (In order to run it under you should lunch Ela Console through the Mono hosting process, i.e. _Mono.exe elac.exe_).

= Interactive mode =

OK, so you have downloaded files, started Ela Console and if you have .NET or Mono propertly installed you should be able to see the program welcome caption.

{{{
Ela Interpreter version 0.7.19.0
Running CLR 2.0.50727.3615 32-bit

Interactive mode
Enter expressions and press <Return> to execute.
Press Ctrl+C to exit.
}}}

It may vary depending on your system and Ela Interpreter version.

Now you can enter Ela expressions and see the immediate result in the console window. Pressing _Return_ key always executes an expression. If you want to specify several expressions at once you can separate them with a semicolon character. Semicolon is optional hovewer if there is only one expression that you want to execute.

In Ela everything is an expression therefore you can test any language construct in an interactive mode. Lets start from simple expressions:

{{{
>2 + 12 / 3

6
}}}

As you can see Ela has an operator priority similar to the C-style languages. Also at the very basis Ela syntax has a lot in common with other C-style languages as well (for example with JavaScript).

Ela has a lot of built-in types including four numeric types (int, long, float and double), strings (e.g. `"Hello"`), chars (e.g. `'H'`), linked lists, arrays, tuples, records, polymorphic variants, etc. You can use *D* postfix to tell the compiler that you number is double and *L* postfix to specify that you want to declare a 64-bit integer:

{{{
>25L / 12

2

>25d / 12

2.08333333333333
}}}

You can use the following syntax to declare an array:

{{{
>[| 1, 2, 3 |]

[|1,2,3|]
}}}

Arrays can be concatenated using *+* operator:

{{{
>[| 1, 2, 3 |] + [| 4, 5, 6 |]

[|1,2,3,4,5,6|]
}}}

Linked lists can be created and concatenated in a similar manner:

{{{
>[1, 2] + [3, 4]

[1,2,3,4]
}}}

Ela also has a _list constructor_ operator *::* that can be used to create lists:

{{{
>1::2::3::[]

[1,2,3]}}}
}}}

List constructor operator is right associative and the very right part of it should always reference a list instance. For example, the following code would cause an error:

{{{
>1::2::3

(1,7): Error ELA808: Invalid type. Expected: 'list', got: 'int'.
        in memory at line: 1, col: 7
}}}

Ela also supports tuples - grouped values of different types - with a syntax that is pretty similar to the one that used by many programming languages:

{{{
>(1, 2, 3)

(1,2,3)

>(1,)

(1)
}}}

Records are like tuples (and basically _are_ tuples) with the only exception that besides a positional access to its members they also provided a "by name" access which might be more convinient in certain cases:

{{{
>(lang:"Ela",version:"0.7")

(lang:"Ela",version:"0.7")
}}}

While in interactive session you can also declare new variables. Ela has two ways to declare a variable - to declare a mutable variable using _var_ keyword (that is the only option available in such languages as JavaScript) and to declare an immutable variable using _let_ keyword (that's the one which value cannot be changed once declared). Also unlike many scripting languages that don't require an explicit variable declaration in Ela variable declarations are mandatory.

{{{
>var x = 1

>let y = 2
}}}

So now we have a mutable _x_ variable and an immutable _y_ variable. There are many benefits of immutability which is probably one of the most core features of functional languages. It makes your programs easier to understand and more predictable. Also immutability helps a compiler to optimize your code.

Compiler keeps an eye on the variables and if you try to change a value of an immutable variable the program won't run at all:

{{{
>y = 3

(1,1): Error ELA312: Unable to change a value of an immutable variable 'y'.
(1,1): Hint ELA501: Use 'var' keyword to declare a mutable variable.
}}}

Another important moment - initialization of variables in Ela is mandatory even for those of them that are declared as mutable.

An immutable variable means that can't change a value bound to this variable however if the value itself is a mutable data structure (like array) you can still change it in-place:

{{{
>let arr = [| 1, 2, 3 |]

>arr[0] = 10

10

>arr

[|10,2,3|]
}}}

However the same trick won't work for lists that are read-only and any list modification should create a new instance of a list.

Ela is a functional language and probably the most important data type in Ela type system is function. Functions can be declared using the following syntax:

{{{
>let sum(x, y) x + y
}}}

As soon as everything in Ela is an expression (in other words any language construct potentially yields a value) the _return_ keyword is not required (but is still supported in Ela if you prefer to write in such a way). A body of a function in Ela should be an expression but again as soon as everything is an expression there is absolutely no problem with that. If you want to create a function with a body that contains several expressions you can use a special block expression *{ }* for that. This is how our previous function could be written:

{{{
>let sum(x, y) { let res = x + y; res }
}}}

The situation with a block expression is pretty simple - it starts a new lexical scope just like in C/C++ (which has no effect in a case of a function declaration as soon as function already starts a lexical scope) and as well as all other expressions it yields a value (which is always the value of a very last expression inside it, in our case the value of a _res_ variable). You are probably interested which value can be returned by an empty block expression and if it is even an allowed language construct. Yes, it is an allowed construct. And it yields a value of type _unit_.

Unit is a special type that is used in the cases when no other specific value can be yielded. You might find similarities between unit and _void_ but unlike void in many languages unit is an actual value that can be returned from a function, assigned to a variable, etc. Also there is no such a notion as _null_ in Ela and unit is sometimes used instead of it.

This is how you can explicitly assign a unit to a variable:

{{{
>let empty = ();
}}}

(It is probably easier taking the similarities in literals to think of a unit as of a zero element tuple). Also several language constructs (not only empty block) always yield a unit. This is typically a case for the imperative constructs such as _for_ cycles.

But lets return to our function.

There is something special about our _sum_ function in comparison with many other programming languages including JavaScript. Guess what? This function is _curried_. Basically all the functions in Ela are curried and there is no way to declare a one that is not.

In a case if you haven't heard this notion before - a _curried function_ simply means a function that can accept its parameters one by one. Let's test it in an iteractive mode:

{{{
>sum(2, 2)

4

>sum(2)(2)

4
}}}

It might not seem very handy at the first glance but there is much more in it.

First of all what happens when you call it like `sum(2)` and don't provide the second argument in-place? Doing so creates a _partially applied_ sum function that accepts a single parameter, adds it to the number 2 and yields the results of this calculation:

{{{
>let sum2 = sum(2)

>sum2(10)

12
}}}

Partial application allows you to create new functions at runtime and to escape certain verbosity which might be annoying in the cases when a frequently call a function with a similar parameter list. You can think of it as of _specialization_ of a generic sum function for a partical case when one of the arguments is always an integer of value 2.

Of course something we don't need to "narrow" what the function actually do but quite the opposite - to combine it with other function to achieve a more complex functionality.

Let's say that we are writing a program that can sum two integers but except of it this program should also make sure that the result of this sum is greater than 0. In a case if it somehow goes below 0 the result should be immediatly corrected.

OK, we've got our requirements, let's implement it.

First of all we need to implement a validation function:

{{{
>let guard(x) if (x < 0) 0 else x
}}}

And then - to write the calling code:

{{{
>let res = sum(2, 3); guard(res)

5
}}}

Pretty wordy, isn't it? Also that is the kind of code that actually tells the compiler what it needs to do - well, eh, call this function, take the return value, then, eh, call another function... You can surely write it as nested function call (e.g. `guard(sum(2, 3)`) but it doesn't look pretty either. What we actually have in here is a chain of function calls - why not to write it in the same manner?

{{{
>sum(2, 3) |> guard

5

>guard <| sum(2, 3)

5
}}}

These are forward and backward pipe operators. You can really think of them as a pipe that takes its input and pushes it through the sequence of function calls in order to finally yield a computed value for you. Each function in such a chain should only take a single parameter except of the very first function that serves as an entry point for the pipe and is called before the pipe is entered (you can also use any expression here, not just function call). But what if one of the values for the calculation comes from another function and we now need to use our sum function in the middle of a pipe?

That is again a case when partial application may be helpful:

{{{
>let getValue() 10

>getValue() |> sum(2) |> guard

12
}}}