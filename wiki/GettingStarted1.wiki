#summary Getting started with Ela using interactive environment (WIP)

= Introduction =

Current Ela implementation is a single managed DLL that doesn't require any installation and can be executed under CLR and Mono. You will require .NET 3.5 or higher to run it under CLR or Mono 2.6 or higher to run it under Mono.

A command line utility Ela Console (_elac_) that comes with Ela supports both platforms as well and can be used for various purposes - you can execute Ela source code files using it (i.e. _elac HelloWorld.ela_), compile them into object files (_.elaobj_) or just output byte code to the console or use interactive mode for testing and debugging. Lunch _elac_ with a _-help_ switch to view all the available options.

In order to start an interactive session you don't have to provide any command line parameters to _elac_. Just double click the file. (In order to run it under you should lunch Ela Console through the Mono hosting process, i.e. _Mono.exe elac.exe_).

= Interactive mode =

OK, so you have downloaded files, started Ela Console and if you have .NET or Mono propertly installed you should be able to see the program welcome caption.

{{{
Ela Interpreter version 0.7.20.0
Running CLR 2.0.50727.3615 32-bit

Interactive mode
Enter expressions and press <Return> to execute.
Press Ctrl+C to exit.
}}}

It may vary depending on your system and Ela Interpreter version.

Now you can enter Ela expressions and see the immediate result in the console window. Pressing _Return_ key always executes an expression. If you want to specify several expressions at once you can separate them with a semicolon character. Semicolon is optional hovewer if there is only one expression that you want to execute.

In Ela everything is an expression therefore you can test any language construct in an interactive mode. Lets start from simple expressions:

{{{
>2 + 12 / 3

6
}}}

As you can see Ela has an operator priority similar to the C-style languages. Also at the very basis Ela syntax has a lot in common with other C-style languages as well (for example with JavaScript).

Ela has a lot of built-in types including four numeric types (int, long, float and double), strings (e.g. `"Hello"`), chars (e.g. `'H'`), linked lists, arrays, tuples, records, polymorphic variants, etc. You can use `D` postfix to tell the compiler that you number is double and `L` postfix to specify that you want to declare a 64-bit integer:

{{{
>25L / 12

2

>25D / 12

2.08333333333333
}}}

You can use the following syntax to declare an array:

{{{
>[| 1, 2, 3 |]

[|1,2,3|]
}}}

Arrays can be concatenated using `+` operator:

{{{
>[| 1, 2, 3 |] + [| 4, 5, 6 |]

[|1,2,3,4,5,6|]
}}}

Linked lists can be created and concatenated in a similar manner:

{{{
>[1, 2] + [3, 4]

[1,2,3,4]
}}}

Ela also has a _list constructor_ operator `::` that can be used to create lists:

{{{
>1::2::3::[]

[1,2,3]}}}
}}}

List constructor operator is right associative and the very right part of it should always reference a list instance. For example, the following code would cause an error:

{{{
>1::2::3

(1,7): Error ELA808: Invalid type. Expected: 'list', got: 'int'.
        in memory at line: 1, col: 7
}}}

Ela also supports tuples - grouped values of different types - with a syntax that is pretty similar to the one that used by many programming languages:

{{{
>(1, 2, 3)

(1,2,3)

>(1,)

(1)
}}}

Records are like tuples (and basically _are_ tuples) with the only exception that besides a positional access to its members they also provided a "by name" access which might be more convinient in certain cases:

{{{
>(lang:"Ela",version:"0.7")

(lang:"Ela",version:"0.7")
}}}

While in interactive session you can also declare new variables. Ela has two ways to declare a variable - to declare a mutable variable using _var_ keyword (that is the only option available in such languages as JavaScript) and to declare an immutable variable using _let_ keyword (that's the one which value cannot be changed once declared). Also unlike many scripting languages that don't require an explicit variable declaration in Ela variable declarations are mandatory.

{{{
>var x = 1

>let y = 2
}}}

So now we have a mutable _x_ variable and an immutable _y_ variable. There are many benefits of immutability which is probably one of the most core features of functional languages. It makes your programs easier to understand and more predictable. Also immutability helps a compiler to optimize your code.

Compiler keeps an eye on the variables and if you try to change a value of an immutable variable the program won't run at all:

{{{
>y = 3

(1,1): Error ELA312: Unable to change a value of an immutable variable 'y'.
(1,1): Hint ELA501: Use 'var' keyword to declare a mutable variable.
}}}

Another important moment - initialization of variables in Ela is mandatory even for those of them that are declared as mutable.

An immutable variable means that can't change a value bound to this variable however if the value itself is a mutable data structure (like array) you can still change it in-place:

{{{
>let arr = [| 1, 2, 3 |]

>arr[0] = 10

10

>arr

[|10,2,3|]
}}}

However the same trick won't work for lists that are read-only and any list modification should create a new instance of a list.

Ela is a functional language and probably the most important data type in Ela type system is function. Functions can be declared using the following syntax:

{{{
>let sum(x, y) x + y
}}}

As soon as everything in Ela is an expression (in other words any language construct potentially yields a value) the _return_ keyword is not required (but is still supported in Ela if you prefer to write in such a way). A body of a function in Ela should be an expression but again as soon as everything is an expression there is absolutely no problem with that. If you want to create a function with a body that contains several expressions you can use a special block expression *{ }* for that. This is how our previous function could be written:

{{{
>let sum(x, y) { let res = x + y; res }
}}}

The situation with a block expression is pretty simple - it starts a new lexical scope just like in C/C++ (which has no effect in a case of a function declaration as soon as function already starts a lexical scope) and as well as all other expressions it yields a value (which is always the value of a very last expression inside it, in our case the value of a _res_ variable). You are probably interested which value can be returned by an empty block expression and if it is even an allowed language construct. Yes, it is an allowed construct. And it yields a value of type _unit_.

Unit is a special type that is used in the cases when no other specific value can be yielded. You might find similarities between unit and _void_ but unlike void in many languages unit is an actual value that can be returned from a function, assigned to a variable, etc. Also there is no such a notion as _null_ in Ela and unit is sometimes used instead of it.

This is how you can explicitly assign a unit to a variable:

{{{
>let empty = ();
}}}

(It is probably easier taking the similarities in literals to think of a unit as of a zero element tuple). Also several language constructs (not only empty block) always yield a unit. This is typically a case for the imperative constructs such as _for_ cycles.

But lets return to our function.

There is something special about our _sum_ function in comparison with many other programming languages including JavaScript. Guess what? This function is _curried_. Basically all the functions in Ela are curried and there is no way to declare a one that is not.

In a case if you haven't heard this notion before - a _curried function_ simply means a function that can accept its parameters one by one. Let's test it in an iteractive mode:

{{{
>sum(2, 2)

4

>sum(2)(2)

4
}}}

It might not seem very handy at the first glance but there is much more in it.

First of all what happens when you call it like `sum(2)` and don't provide the second argument in-place? Doing so creates a _partially applied_ sum function that accepts a single parameter, adds it to the number 2 and yields the results of this calculation:

{{{
>let sum2 = sum(2)

>sum2(10)

12
}}}

Partial application allows you to create new functions at runtime and to escape certain verbosity which might be annoying in the cases when you frequently call a function with a similar parameter list. You can think of it as of _specialization_ of a generic sum function for a particular case when one of the arguments is always an integer of value 2.

Of course sometimes we don't need to "narrow" what the function actually does but quite the opposite - to combine it with other function to achieve a more complex functionality.

Let's say that we are writing a program that can sum two integers but except of it this program should also make sure that the result of this sum is greater than 0. In a case if it somehow goes below 0 the result should be immediatly corrected.

OK, we've got our requirements, let's implement it.

First of all we need to write a validation function:

{{{
>let guard(x) if (x < 0) 0 else x
}}}

And then - to write the calling code:

{{{
>let res = sum(2, 3); guard(res)

5
}}}

Pretty wordy, isn't it? Also that is the kind of code that actually tells the compiler what it needs to do - well, eh, call this function, take the return value, then, eh, call another function... You can surely write it as nested function call (e.g. `guard(sum(2, 3)`) but it doesn't look pretty either. What we actually have in here is a _chain_ of function calls - why not to write it in the same manner?

{{{
>sum(2, 3) |> guard

5

>guard <| sum(2, 3)

5
}}}

These are forward and backward pipe operators. You can really think of them as a pipe that takes its input and pushes it through the sequence of function calls in order to finally yield a computed value for you. Each function in such a chain should only take a single parameter except of the very first function that serves as an entry point for the pipe and is called before the pipe is actually entered (you can also use any expression here, not just function call). But what if one of the values for the calculation comes from another function and we now need to use our sum function in the middle of the pipe?

That is again a case when partial application may be helpful:

{{{
>let getValue() 10

>getValue() |> sum(2) |> guard

12
}}}

OK, but if we need to perform these operations - calculation through sum and validation through guard - quite often and even our pipes might look somewhat repetative? There is another operator in Ela specifically for such cases - it is called _function composition_:

{{{
>let comp = guard >>> sum

>comp(2, 3)

5
}}}

Or you can use backward function composition:

{{{
>let comp2 = sum <<< guard;

>comp2(20, 30)

50
}}}

Function composition creates a new function that has the same parameter list as the very first function in the chain and returns the value from the very last function.
As with pipe operators you can combine any number of functions at once using composition operators. Each function except of the first should only accept a single parameter.

The major difference between composition and pipes is that pipes don't create any functions, they perform a function call, when composition never calls function but generates a new function as a combination of them.

OK, let's take another task - we don't need to sum two integers and validate the result but rather to calculate the sum of elements in a list.

So we need to implement a function that takes as the arguments - a list, an initial value for out calculation and a function that will be used to performed an actual calculation. This is a typical _higher-order function_ (a function that operates with other functions). Let's call it _fold_:

{{{
>let fold(list, i, f) { var res = i; for (x in list) res = f(res, x); res }

>fold([1, 2, 3, 4], 0, sum)

>10
}}}

OK, it gets the job done, but there is one thing I don't really like about this function. Again it actually tells the compiler what it should do - erh, declare a mutable variable to store an itermediate result, iterate through the list, call a function on each iteration...

The code doesn't really seem to be clean when in reality that is a very simple function that does a very simple thing. How else we can implement it?

{{{
let fold2(list, i, f) on x::xs,.. -> fold2(list, f(i, x), f) on [],.. -> i

>fold2([1, 2, 3, 4], 0, sum)

>10
}}}

The second version of the _fold_ function uses _pattern matching_. Here you can see a short version of _match_ expression that is allowed when the whole function body is a single match. It uses a special _head and tail_ pattern that may come up very handy when we need to deconstruct lists.

A pattern `x::xs` does two things - it verifies that our linked list contains at list one element and binds the very first element of the list (the _head_) to the variable _x_ and the rest of the list (the _tail_) to the variable _xs_. So on the first call `x` will be bound to `1` and `xs` to `[2, 3, 4]`, on the second call - `x` to `2` and `xs` to `[3, 4]`, etc. The second pattern matches the empty list.

As soon as we use a short match syntax here we actually match against the whole expression in the function argument list taking it as if it were a tuple. But we don't really need to bind or deconstruct the other two parameters - we just need them as is. Therefore we are using the two dots `..` operator to tell the compiler that the other values are out of need for us - that we don't really care how many other elements our virtual tuple has.

You might say that this function might look better or more "declarative" but it is less effecient than the first version of fold because it have to recursively call itself instead of running a simple and cheap _for_ cycle.

Luckily that is not exactly the case here. The function _fold2_ is a _tail recursive function_ which means that the very last instruction of this function is a call to itself. Ela compiler can recognize tail recursion and replace with simple goto instead of an expensive function call. In other words you have the same effeciency as with _for_ cycle and a much nicer code.

But still there is something not really right with the way how we do it. We have created a sum function before during another test - therefore we now can simply reference it by name and provide as an argument to our fold function. But what is we didn't have an implementation of sum? Should we write a separate declaration for each function even if this function is that straightforward and simple?

Of course no. That is the reason why Ela have so called _anonymous functions_. Anonymous functions are pretty much like regular functions with the only exception that they simply lack names. The same for their syntax:

{{{
>\(x, y) x + y
}}}

As you can see here we use a `\` operator (you can take it as a stylized lambda symbol) instead of a function name. Parenthis around parameters are always required (even if you have a function with a single parameter, e.g. `\(x) x + 2`).

This is how our code would look like with anonymous function:

{{{
>fold2([1, 2, 3, 4], 0, \(x, y) x + y)

>10
}}}

Well again there is something not really right here. It looks like that our sum operation does nothing else than a standard `+` operator do and even anonymous function syntax is somewhat too much for it. And again we have a solution here:

{{{
>fold2([1, 2, 3, 4], 0, _+_)

>10
}}}

So what've just happend? What is this `_+_` thing? That is simply another way to declare a function in Ela. If a function body is short just as in our case when it has only a single binary operation we do not have to explicitly specify the whole parameter list but rather use a `_` operator. Here - exactly as in the case with a regular anonymous function - we declare a function that takes two parameters which are referenced using `_` in their subsequent order (e.g. a function in the form `_+_+_` would take three parameters a return a sum of them).