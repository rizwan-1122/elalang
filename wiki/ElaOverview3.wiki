#summary Ela overview 3. Functions

==Introduction==

In this chapter we will review functions in Ela - their pecularities and operations available for them. We are also going to use Ela Interactive Console as in previous chapter. However it is not always convinient to type function declarations directly in interactive mode - this is fully supported and works good for short function declarations however you might find more complex function declarations written in a single line quite cumbersome. That is why we are going to write such functions in a separate file.

This is what you need to do: create a file named _Samples.ela_ and place it in the folder where you have your Ela Console executable (_elac.exe_). In order to import declarations from this file you need to use `open` directive like so:

{{{
ela>open Samples
}}}

Now you can refer to the top level variables declared in _Samples.ela_ (however you need to prefix them with the name of a module, i.e. `Samples.myVar`). 

Let's say that you have a `sum` function defined in _Samples.ela_. This function has a definition `let sum x y = x + y` and you need to call it from an interactive session. This is how you can do that:

{{{
ela>Samples.sum 2 2

4
}}}

But what if you change an existing function definition or add a new function? There is also a way to deal with that. Ela Console provides a special `#reload` command that allows to reload any previously imported module:

{{{
ela>#reload Samples

Module 'Samples' successfully reloaded.
}}}

After that all your newly defined functions and/or changes to existing function will be visible in interactive session. 

These are probably all the major features that Ela Console can offer you so far so let's get started. Run Ela Console and type `open Samples` - you will only need to do this once but don't forget to reload Samples after each change to the file.

==Why so fundamental?==

As soon as Ela is a functional language function is a core data type in Ela type system. We have already acquainted with functions in previous chapters; here we will summarize what we know about them so far.

Ela uses its own convention to represent function types. As soon as all parameter and return type deduction logic is normally deferred until runtime (and first function application) Ela uses an asteriks symbol instead of type names:

{{{
ela>let myFun x y = x $ y

ela>myFun

myFun:*->*->*
}}}

The notation `myFun:*->*->*` describes a function that accepts two parameters. The third asteriks stands for the return type. And `myFun` is a function name. If Ela doesn't know what the function name is it will replace the name with the `<f>`:

{{{
ela>\x y -> x + y

<f>:*->*->*
}}}

If you have a value and you want to check if a given value is of type function you can use `?` operator like so (I will describe the `?` operator with more detail in the next chapter):

{{{
ela>myFun ? fun

True
}}}

The `fun` is an internal name of the function type in Ela (like `int` for integers or `string` for strings).

Now let's finally see what the reasons why functions are the most fundamental type in Ela.

===Functions as first class values===

Ela functions are first class values. Unlike many programming languages functions in Ela are regular values like integer numbers, strings or tuples. This pecularity actually unleashes a lot of programming power - you can pass functions as arguments to other functions, return them from functions, perform different operations on functions, etc. Some modern programming languages - even not from the functional family - also utilize this concept of functions as first class values. Probably the most widespread language of such kind is JavaScript. This alone allows you to adopt a lot of functional patterns in programming. We have already written a couple of _higher order functions_ that are based on this facility.

Higher order functions are functions that operate with other functions - accepts them as parameters or fetch them as return values. With higher order functions you can write a generic algorithm by allowing the part of its logic to be provided as an argument function. Let's take a _fold left_ function as an example. Copy this declaration in _Samples.ela_ file:

{{{
let foldl f z x::xs = foldl f (f z x) xs;           
          _ z []    = z 
}}}

As you can see `foldl` accepts three arguments - a function, an initial value and a list. The first argument is a function for two arguments. What `foldl` does is iterating through the list and calling a given function on each list element (it provides initial `z` as a first argument and a current list element as a second).

OK, good. But at the first glanse `foldl` doesn't do much. And that is true - it simply implements the idea of iterating through a list and calling a supplied function for each element. How this can be useful? 

Imagine that wee need to sum all elements of a list. You don't have to code all the logic from scratch, you can use an existing `foldl` function:

{{{
ela>#reload Samples

ela>let sum = Samples.foldl (+) 0 
}}}

Here we have created a new function by combining existing functions - `foldl` and `+` operator which is also a function as you remember. If you are having troubles understaning our `sum` function above that is OK, we will review its pecularities later. For now you can find its alternative version below:

{{{
let sum lst = Samples.foldl (\x y -> x + y) 0 lst
}}}

Let's move forward. Now we have a different task - we need to reverse elements of a given list. And you know what? We still don't need to write its implementation from scratch:

{{{
ela>let reverse = Samples.foldl (flip (::)) []
}}}

Basically this is what makes a language functional - instead of coding the sequence of actions to operate with data you operate with functions, create new functions by combining existing functions. As a result instead of working with data and _thinking data_ you think in terms of functions and what functions you need to combine to achieve your goal.

===Closures===

All Ela functions with absolutely no exceptions are closures. We have touched this pecularity already in the first chapter but I will summarize the idea anyway. As soon as in Ela you can declare functions anywhere - and that is the part of the obligatory stating that Ela has first class functions - it is frequently pretty useful to refer to variables that are declared outside of the function body, e.g. in the parent scope above the function definition.

Functions that are able to perform such a trick are called _closures_. It is important to understand that closures don't capture simply the variable value but the variable itself - you can think of it as of a possibility to refer directly to the parent scope variable within your function body. You should also be careful with it when operating with mutable values (like arrays) or mutable variables. All assignments to a variable or a variable value will be immediatly reflected in your closure function:

{{{
ela>let mutable x = 0

ela>let printIt () = cout x

ela>printIt ()

0

ela>x <- 42

ela>printIt ()

42
}}}

Sometimes such side effects may be useful in your programming but normally these are exceptional cases and in all other situations you should try to avoid them as soon as they render your code more error prone and more difficult to understand.

Closures are pretty useful even if you program in a pure functional way, with no side effects at all. In many cases you might need to fetch a function as a return value and this function will most probably perform some operations with the parameters of its parent function. In reality this is the only way how you can represent multiple parameter functions in Ela because all functions in Ela are _curried_.
  
===Curried functions===

As you probably remember from the very first chapter, all Ela functions accept just a single parameter. If you want to implement a function that can operate with several parameters you can create a chain of nested functions like so:

{{{
ela>let sum3 = \x -> \y -> \z -> x + y + z

ela>sum3 2 3 4

9
}}}

(As you can see the latter function that performs an actual claculation can refer to variables `x` and `y` declared in parent functions because it acts like a closure and captures the variables declared in the enclosing scopes).

Functions like `sum3` are called _curried_ functions. As you can see a curried function creates a closure for each subsequent argument and if you need a function for three arguments you will have a chain of three closures as above, for four arguments - chain of four closures, etc. Also as you should probably remember there is a syntax sugar that simplifies declaration of such functions. Using this alternate syntactic construct the `sum3` function can be declared like so:

{{{
let sum3 = \x y z = x + y + z
}}}

Or even like so:

{{{
let sum3 x y z = x + y + z
}}}

Also because function application operation is left associative you don't have to always use parenthesis when calling a function with several arguments, i.e. `((sum 2) 3) 4` is fully equivalent to `sum 2 3 4`, but, hey, you should probably know this already!

Curried functions are not here in order just to make the language weird but because they unleash a very powerful programming technique - partial function application. As soon as all multiple argument functions are in fact just chains of nested functions you don't have to provide all arguments when calling such functions. For example calling a function `sum3` like so: `sum3 0` creates a new function for two arguments that sums these arguments with zero.

As you already learned functional programming is all about creating new functions on the fly by combining existing functions - and partial application is a tool that comes up really helpful here. You can implement a generic function and specialize it by fixing some of its arguments. A good example of such technique is a `foldl` function defined above. Another example is a `zip` function. This function takes two lists and returns a single list which elements are tuples that contain elements from both first and second lists. In other words if we have lists `[1,2,3]` and `['a','b','c']` as an input the resulting list will be `[(1,'a'),(2,'b'),(3,'c')]`.

How we can implement this function? As usual we can start with a more generic one (copy the declaration below to _Samples.ela_ file):

{{{
let zipWith z x::xs y::ys = z x y :: zipWith z xs ys;             
            _ _     _     = [] 
}}}

As you can see besides two lists `zipWith` also accepts a function as a very first argument and this function gets applied to elements of both first and second list when a resulting list is constructed. Using `zipWith` we can seamlessly create our target `zip` function:

{{{
ela>#reload Samples

ela>let zip = Samples.zipWith (\x y -> (x, y))

ela>zip [1,2,3] ['a','b','c']

[(1,'a'),(2,'b'),(3,'c')]
}}}

A more straightforward example is a `take` function:

{{{
let take 0 _     = [];          
         n x::xs = x :: take (n - 1) xs; 	     
		 _ []    = [] 
}}}

Copy this function to _Samples.ela_. What do we see here? A `take` function accepts a number of elements and a list and returns a specified number of elements from this list. OK, let's assume that we have a pretty huge list and we need only first five entries from it, here is what we can do:

{{{
ela>#reload Samples

ela>let hugeList = buildList 10000 0 where buildList s n | s > nn = nn :: buildList s nn where nn = n + 1 end; | else = [] end

ela>Samples.take 5 hugeList

[1,2,3,4,5]
}}}

It works however if you need to perform this operation frequently it is probably not very practical to always hardcode the number of items that you want to fetch. As usual you can create a specific version of `take` function like so:

{{{
ela>let take5 = Samples.take 5

ela>take5 hugeList

[1,2,3,4,5]
}}}

==Infix or prefix?==

Normally functions are called using _prefix_ form - that is by placing the function name before its arguments. A function call like `sum 2 2` or `take5 hugeList` are prefix forms. However sometimes it is more visual to use _infix_ form - that is to place a function name between its arguments. This convention is typically used by operators however in Ela even regular functions can also be called using infix form.

There are several cases when this possibility can be useful. Let's say that we have an `elem` function. This function accepts an element, a list and tests if a given element exists in a given list. This is how this function can be defined (as usual copy this declaration to _Samples.ela_):

{{{
let any f x::xs | f x  = true;                 
                | else = any f xs;         
	    f []           = false  		
}}}

And now type the following in console:

{{{
ela>#reload Samples

ela>let elem x = Samples.any (==x) 
}}}

Just a quick note - as you can see an `elem` function is defined through a more generic `any` function. The latter one accepts a predicate and a list and tests whether any element of a list satisfies a given predicate. The `elem` function simply defines this predicate as a function that performs a comparison of the provided value with a list element. As I've alredy mentioned above this is pretty typical style of programming in Ela.

OK, but what is so specific about this `elem` function? Mostly nothing. With the only exception that application of `elem` is probably easier to read when it is written in infix form:

{{{
ela>elem 5 hugeList

True

ela>42 `elem` hugeList

True
}}}

Please bear in mind that in order to call a function using infix form you have to enclose it in back apostrophes like in the example above.

However functions are not the only entities that can escape from prefix to infix form. Operators that are applied using infix form by default can also be called in the same manner as functions:

{{{
ela>2 + 2

4

ela>(+) 2 2

4
}}}

Again it is important to remember that in order to apply an operator using prefix form you have to enclose it in parenthesis.

In fact the title of this section is a little bit misleading - infix and prefix forms are not the only possibilities. You can also apply both functions and operators using _postfix_ form. Postfix means that an argument is placed before the function or operator name. This is how it might look:

{{{
ela>let isEven x = x % 2 == 0

ela>(12 `isEven`)

True

ela>(13 `isEven`)

False
}}}

(Please note that parenthesis around the whole expression and back apostrophes around function names are mandatory).

The same for operators:

{{{
ela>(2+)

<f>:*->*

ela>let sum2 = (2+)

ela>sum2 3

5
}}}

The support for the postfix form is really important when it comes to operators as soon as it unveals a very convinient way to partially apply operators. If you partially apply an operator using postfix form than the very first argument gets "fixed". If you use a prefix form than the second argument is "fixed":

{{{
ela>let div1 = (5-)

ela>div1 3

2

ela>let div2 = (-5) //this is equivalent to: (-) 5

ela>div2 7

2
}}}

(Of course if your operator accepts just a single argument than both prefix and postfix forms would lead to the same result - to the call saturation).

All these tricks work with regular functions as well however are a little bit more common with operators.

As a result, with all these variety of application forms and ability to switch between them, we finally come to a conclusion that there is no real difference between operators and function. Or to say more precisely - operators _are_ functions that use a different calling convention _by default_.

And that is really true for most of standard Ela operators. Which again leads us to another conclusion: if a difference is, well, basically non-existent why not to give users an ability to define their own operators?

==Custom operators==

Declaration of custom operators is no way different from regular function declarations which is logical as soon as operators are just functions as we've seen before. There is one limitation however. In order to distinguish between operators and functions that have different default call convention Ela requires operators to have names composed from the following list of characters: `!%&*+-.:/<=>?@^|~`.

Let's see some examples of custom operators:

{{{
ela>let !! x y = x.[y]

ela>hugeList !! 2

2

ela>(!!) hugeList 50

50

ela>let ^^ x = x * 2

ela>(122 ^^)

244

ela>(^^ 42)

84
}}}

Another important difference between an operator and a function is that operators are automatically imported from the opened module. You don't have to prefix operators with module names like you do with functions and you also don't have to specify them in the module import list which is pretty convinient.

==Function declaration by pattern matching==

We will discuss pattern matching and all its syntactic variants in the next chapter, here I will give a short overview of the role of pattern matching in functions.

You should be acquainted with pattern matching concept already as if it was mentioned a couple of times in previous chapters. The idea behind definition of functions by pattern matching is to avoid reduntant parameter list definition and to use patterns directly in place of parameters. Let's take a simple pattern matching construct as an example:

{{{
let skip n lst = match (n, lst) with
                 (0, lst)   = lst;
				 (n, _::xs) = skip (n - 1) xs;
				 (_, [])    = []
				 end
}}}

This is a function that accepts number of elements, a list, skips the specified number of elements and return the resulting list.

As you can see we had to repeat parameter names twice (when even a single time is already redundant). Also we have to explicitly declare a match construct. It doesn't make a function declaration concise and readable. Here is an alternative:

{{{
let skip 0 xs    = xs;          
         n _::xs = skip (n - 1) xs;          
		 _ []    = [] 
}}}

It is probably obvious that this declaration is a way better than the previous one. Here we use patterns as a parameter list and declare a separate function body for each set of patterns.

==Anonymous functions==

I am really going to be short with these ones as we already have touched the basis before. Anonymous functions are functions that... well... are normally not bound to any name. A lot of modern languages support a concept of anonymous functions. For example in C# anonymous functions, or lambdas, are the only facility that can simulate functions as first class values and act as closures.

But this is not a case for Ela. It is important to understand that the only different between a function created using lambda syntax and a regular function declaration is that the latter one is always bound to a specific name. You are also free to declare named functions using lambda syntax. For example the following declarations are completely equivalent:

{{{
let sum x y = x + y

let sum = \x y -> x + y
}}}

These is only the syntactic difference between the two. For Ela compiler those are just two ways to say the same thing.

Anonymous functions are useful when you need to declare functions "in place" - to use them just once and then throw them away. However lambdas are not always the most concise way to declare a function. Sometimes partial application is much more readable and visual. Compare the two:

{{{
foldl (\x -> x * 2) 0 lst

foldl (*2) 0 lst
}}}

As you can see first sample with explicit lambda declaration is less readable than the partial application of multiplication operator. Moreover it is not even strictly neccessary to use lambdas for "in place" function declaration. It is possible to use regular declaration syntax like so:

{{{
foldl (let doubleMe x = x * 2 in doubleMe) 0 lst
}}}

As you remember `let..in` expression always fetches a value by evaluating the expression that immediatly follows the `in` clause. And that is the trick we use here. Of course this code sample is the most verbose among the three and probably the least practical however there is one difference between such declaration and a lambda expression.

Here you explicitely bind a function to a name therefore a compiler and afterwards an execution environment know how the function supplied to `foldl` is called. And this will be used in exception stack trace if something goes wrong inside your `doubleMe` function which might simplify debugging in some cases.

But again you can rewrite the above example like that and it will be fully equivalent:

{{{
foldl (let doubleMe = \x -> x * 2 in doubleMe) 0 lst
}}}

There is only one difference except the whole anonymity thing between lambdas and regular functions. As you remember it is possible to declare a regular function by pattern matching and specify several function bodies for each set of patterns (that do align respectively with the function parameters). It is possible to use pattern matching inside lambda declaration too however you can't define several bodies. This is the case when you should probably consider to use regular declaration syntax.

==Function operations==

===Application===

Function application is most important and the most basic operation available for functions. In Ela it is defined as a simple juxtaposition of a function and its argument - in prefix, infix or postfix forms. There are two things however that you should remember about function application - I've mentioned them before but it is useful to repeat them one more time:

  * Function application is left associative which means that function application in the form `(sum 2) 2` is always equivalent to `sum 2 2` and if you see an application like the one above you should understand that this is not a function call with two arguments but two subsequent function calls.
  * Function application has one of the highest priorities amoing all other Ela operations. The only operation that has a priority even higher than function application is a member access operation (i.e. `rec.fieldName`). High priority means that in many cases you can omit extra parenthesis around application expression as soon as anyway it binds tighter than other operators, i.e. `nn :: (buildList s nn)` is fully equivalent to `nn :: buildList s nn`.

===Pipe operators===

Pipe operators are yet another way to apply a function to its arguments. Ela has two pipe operators - backward pipe operator `<|` and forward pipe operator `|>`. For example we have a function `doubleMe` that is defined like so:

{{{
ela>let doubleMe x = x + x
}}}

This is how you can call it using regular application syntax and pipe operators:

{{{
ela>doubleMe 2

4

ela>doubleMe <| 2

4

ela>2 |> doubleMe

4
}}}

As you can see backward pipe operator uses applicative order (just like the regular application) when forward pipe uses so called normal order.

OK, but what's the catch? Why do we need these operators when they obviously seem to be redundant and do nothing more than the regular application does?

As you remember regular function application has one of the highest operation priorities. But pipes operators on the contrary have one of the lowest. And that is the catch. In many cases by using pipes operators you can omit a lot of parenthesis and make your code more visual. 

This is a typical pattern when you have a chain of function calls. Let's see how it works. Copy the following declarations into your _Samples.ela_ file:

{{{
let when f x::xs | f x  = x :: when f xs;
                 | else = when f xs;
	     _ []			= []

let project f x::xs = f x :: project f xs;
            _ []    = []
}}}

Here we have two functions - the first filters a given list using a given predicate and the second performs a list projection - applies a given function to all list elements. And this is a pretty typical scenario when you work with collections - fetch elements based on the certain condition and perform some transformations on the result list. This is how you can do it with forward pipe operator:

{{{
ela>#reload Samples

ela>lst |> Samples.when (>5) |> Samples.project (**2)

[36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529,576,625,676,
729,784,841,900,961,1024,1089,1156,1225,1296,1369,1444,1521,1600,1681,1764,1849,
1936,2025,2116...]
}}}

And that is an alternative using regular application syntax:

{{{
ela>Samples.project (**2) (Samples.when (>5) lst)
}}}

And we have only two functions here. Imagine the difference when you need to call, say, five functions in a row.

===Function composition===

As you can see pipe operators make your code much more readable in a lot of cases however if you require to call the same function chain frequently pipes are not really useful as soon as they require you to harcode the same chain of calls every time you need it. Function composition is a tool that is here to help you with such situations.

As with pipes Ela has two function composition operators - forward composition `>>` and backward composition `<<`. Composition is pretty similar to the pipes in the sense of usage with the only tiny difference - pipe operators are used to call functions and not to create functions when composition is used to create functions and not to call them.

If somebody will have to define an operator similar to, say, forward composition it might look like so:

{{{
let >> f g x = g(f x)
}}}

As you can an implementation is pretty straightforward - we accept one function, another one and call the latter with the results of the first function application. Let's see it in action:

{{{
ela>let sqrt x = x * x

ela>let neg x = --x

ela>let div x = x / 2

ela>let c = sqrt >> neg >> div

ela>c 42

-882
}}}

Backward composition works in a similar manner but in reverse order:

{{{
ela>let c2 = div << neg << sqrt

ela>c2 42

-882
}}}

Now let's see how we can rewrite the sample from the previous section using composition operators:

{{{
ela>let qry = Samples.when (>5) >> Samples.project (**2)

ela>qry lst

[36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529,576,625,676,
729,784,841,900,961,1024,1089,1156,1225,1296,1369,1444,1521,1600,1681,1764,1849,
1936,2025,2116...]
}}}

Standard composition operators work only for functions that accept a single parameter. However if you have a more specific case you can always declare your own composition operator that will match your particular requirements.