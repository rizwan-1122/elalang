#summary An overview of Ela Console and language interpreter

= Introduction =

Current Ela implementation is a single managed DLL that doesn't require any installation and can be executed under CLR and Mono. You will require .NET 3.5 or higher to run it under CLR or Mono 2.6 or higher to run it under Mono.

A command line utility Ela Console (_elac_) that comes with Ela supports both platforms as well and can be used for various purposes - you can execute Ela source code files using it (i.e. _elac HelloWorld.ela_), compile them into object files (_.elaobj_) or just output byte code to the console or use interactive mode for testing and debugging. Lunch _elac_ with a _-help_ switch to view all the available options.

In order to start an interactive session you don't have to provide any command line parameters to _elac_. Just double click the file. (In order to run it under you should lunch Ela Console through the Mono hosting process, i.e. _Mono.exe elac.exe_).

= Interactive mode =

OK, so you have downloaded files, started Ela Console and if you have .NET or Mono propertly installed you should be able to see the program welcome caption.

{{{
Ela Interpreter version 0.7.19.0
Running CLR 2.0.50727.3615 32-bit

Interactive mode
Enter expressions and press <Return> to execute.
Press Ctrl+C to exit.
}}}

It may vary depending on your system and Ela Interpreter version.

Now you can enter Ela expressions and see the immediate result in the console window. Pressing _Return_ key always executes an expression. If you want to specify several expressions at once you can separate them with a semicolon character. Semicolon is optional hovewer if there is only one expression that you want to execute.

In Ela everything is an expression therefore you can test any language construct in an interactive mode. Lets start from simple expressions:

{{{
>2 + 12 / 3

6
}}}

As you can see Ela has an operator priority similar to the C-style languages. Also at the very basis Ela syntax has a lot in common with other C-style languages as well (for example with JavaScript).

Ela has a lot of built-in types including four numeric types (int, long, float and double), strings (e.g. `"Hello"`), chars (e.g. `'H'`), linked lists, arrays, tuples, records, polymorphic variants, etc. You can use *D* postfix to tell the compiler that you number is double and *L* postfix to specify that you want to declare a 64-bit integer:

{{{
>25L / 12

2

>25d / 12

2.08333333333333
}}}

You can use the following syntax to declare an array:

{{{
>[| 1, 2, 3 |]

[|1,2,3|]
}}}

Arrays can be concatenated using *+* operator:

{{{
>[| 1, 2, 3 |] + [| 4, 5, 6 |]

[|1,2,3,4,5,6|]
}}}

Linked lists can be created and concatenated in a similar manner:

{{{
>[1, 2] + [3, 4]

[1,2,3,4]
}}}

Ela also has a _list constructor_ operator *::* that can be used to create lists:

{{{
>1::2::3::[]

[1,2,3]}}}
}}}

List constructor operator is right associative and the very right part of it should always reference a list instance. For example, the following code would cause an error:

{{{
>1::2::3

(1,7): Error ELA808: Invalid type. Expected: 'list', got: 'int'.
        in memory at line: 1, col: 7
}}}

Ela also supports tuples - grouped values of different types - with a syntax that is pretty similar to the one that used by many programming languages:

{{{
>(1, 2, 3)

(1,2,3)

>(1,)

(1)
}}}

Records are like tuples (and basically _are_ tuples) with the only exception that besides a positional access to its members they also provided a "by name" access which might be more convinient in certain cases:

{{{
>(lang:"Ela",version:"0.7")

(lang:"Ela",version:"0.7")
}}}

While in interactive session you can also declare new variables. Ela has two ways to declare a variable - to declare a mutable variable using _var_ keyword (that is the only option available in such languages as JavaScript) and to declare an immutable variable using _let_ keyword (that's the one which value cannot be changed once declared). Also unlike many scripting languages that don't require an explicit variable declaration in Ela variable declarations are mandatory.

{{{
>var x = 1

>let y = 2
}}}

So now we have a mutable _x_ variable and an immutable _y_ variable. There are many benefits of immutability which is probably one of the most core features of functional languages. It makes your programs easier to understand and more predictable. Also immutability helps a compiler to optimize your code.

Compiler keeps an eye on the variables and if you try to change a value of an immutable variable the program won't run at all:

{{{
>y = 3

(1,1): Error ELA312: Unable to change a value of an immutable variable 'y'.
(1,1): Hint ELA501: Use 'var' keyword to declare a mutable variable.
}}}

Another important moment - initialization of variables in Ela is mandatory even for those of them that are declared as mutable.

An immutable variable means that can't change a value bound to this variable however if the value itself is a mutable data structure (like array) you can still change it in-place:

{{{
>let arr = [| 1, 2, 3 |]


>arr[0] = 10

10

>arr

[|10,2,3|]
}}}