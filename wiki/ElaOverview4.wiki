#summary Ela overview 4. Traits
#labels Featured

==Introduction==

In this chapter I will tell you about some advanced aspects of Ela type system - precisely _traits_ - that make type system very flexible and easily extendable. 

==What this is all about==

_Trait_ is like interface in an object oriented language. Not exactly like it but the similarity can obviosly be established. Traits describes the behavior that is supported by a particular value. For example there is a trait _Num_ that includes all arithmentic operations. Taking into account the fact that a given value supports trait _Num_ doesn't neccessarily mean that this value is actually a number. It means that it can _act_ like a number. Tuples which are not really numbers does support trait _Num_ and implement it by applying arithmentic operations to their elements. And strings which are not lists in Ela (but are indexed arrays exactly like .NET strings) can be folded like lists.

Thanks to the traits all operations in Ela don't deal with specific types but instead operate with traits. You can always create your own data type that has nothing to do with built-in numerics but fully supports addition, multiplication, division, etc. This fact renders all Ela operations as _abstract operations_. And as a result you gain a lot of flexibility in the type system.

In this chapter I will tell me about all standard Ela traits and how they are used in Ela type system.

==Traits==

===Eq===

_Eq_ is one of the most fundamental traits that is supported by all Ela data types. This trait defines two operations - test for equality and test for inequality that are supported in Ela through operators _equals_ (`==`) and _not equals_ (`<>`). Different data types might implement these operations differently. For example when you compare tuples they are compared using structured equality. Try the following:

{{{
ela>(1,2) == (1,2)

True

ela>(3,4) <> (3,4,5)

True
}}}

However some other data types such as lists and arrays are compared by reference:

{{{
ela>[1,2] == [1,2]

False
}}}

When you create two lists with the same elements you still have two different lists, data structures for them are allocated separately therefore when we try to compare these lists using reference equality by asking "if these two expressions point to the _same_ list" we obviously get false as a result.

Ela has a limited set of types that are compared using reference equality: linked lists, arrays, modules and functions. All other data types, including strings, variants and records are compared using structural equality.

===Show===

_Show_ is another trait that is supported by all Ela data types. This trait defines a single operation of a conversion to string. If you ever programmed in .NET than _Show_ can probably remind you of a _ToString_ method that is inherited by all .NET types.

In fact when you are using Ela Interactive Console all the values that are printed out to the console are obtained using _Show_ trait. For example implementation of this trait by linked list return a serialized list that includes all its elements.

Ela has two built-in functions to support _Show_ trait. They are called respectively _show_ and _showf_. The latter one accepts two arguments - a format represented as a string and a value to be converted. Let's see them in action:

{{{
ela>show [1..5]

[1,2,3,4,5]

ela>show (`Some (1,2))

`Some (1,2)

ela>showf "#.##" 42.2345

42.23
}}}

===Ord===

_Ord_ trait contains a set of operations that can be used for comparison. These are _greater_ (`>`), _lesser_ (`<`), _greater or equal_ (`>=`) and _lesser or equal_ (`<=`):

{{{
ela>2 > 3

False

ela>(5,6) > (4,3)

True

ela>"ABIN" < "abin"

False
}}}

_Ord_ is supported by several standard data types including all numeric types, chars, strings and tuples. All other data types don't support it and you will get an error if you try to use one of the _Ord_ operators with them:

{{{
ela>[2,3] > [1,2]

<memory>(1,10): Error ELA907: A value '[2,3]' of type 'list' doesn't support tra
it 'Ord' (comparison operations).
        in memory at line: 1, col: 10
}}}

===Len===

_Len_ defines a single operation - calculation of one's length. As you already know there is a built-in `length` function that implements this trait:

{{{
ela>length [1,2,3]

3

ela>length (1,2)

2
}}}

_Len_ is supported by lists, arrays, tuples and records. Again you are going to catch an error if you try to use it with any other data type.

===Get===

Types that implement _Get_ trait support an indexer operation which can be used to obtain an element by its index. A good example of such a type is tuple:

{{{

ela>let tup' = (1,2)

ela>tup'.[1]

2
}}}

Remember that this trait only defines "read" through indexer operation - it doesn't support an assignment and if you try one your code will likely fail:

{{{
ela>tup'.[1] <- 3

<memory>(1,6): Error ELA901: A value '(1,2)' of type 'tuple' doesn't support trait 
'Set' (write through indexer).
        in memory at line: 1, col: 6
}}}

Other data types that support _Get_ trait are lists, arrays and records.

===Set===

_Set_ trait allows you to perform assignment through indexer - that is exactly the operation that tuples don't support. As soon as Ela is a functional language assignment is not a popular operation and only two data types implement it. These are arrays and records. Also if you want to change record fields through an indexer you have to declare them as mutable first:

{{{
ela>let rec = {mutable x = 0, y=0}

ela>rec.[1] <- 1

<memory>(1,5): Error ELA816: Field '' of the record '{mutable x=0,y=0}' is immutable 
and cannot be changed.
        in memory at line: 1, col: 5
		
ela>rec.[0] <- 1

ela>rec.[0]

1
}}}

===Call===

This trait defines a single operation - function call, which is supported by the only data type in Ela, function. There is not much else I can tell about _Call_ trait. There are functions in Ela and they can be called. That's it.

===Gen===

This one is a more complicated trait. It allows your data type to be generated using ranges and comprehensions. Only lists, arrays, records and tuples support this trait. Let's start from ranges.

Ranges in Ela are arithmetic sequences that can be used to create lists, arrays and tuples. You only have to specify a first element, a last element, and (optionally) a second element in a sequence that will be used to calculate stepping:

{{{
ela>[1..5]

[1,2,3,4,5]

ela>[1,3..10]

[1,3,5,7,9]

ela>[100,87..1]

[100,87,74,61,48,35,22,9]
}}}

An important note - if you want to create a range in a descending order than you have to specify the second element, e.g. the following code won't give the expected result:

{{{
ela>[10..1]

[10]
}}}

This is how you need to change it to make it work:

{{{
ela>[10,9..1]

[10,9,8,7,6,5,4,3,2,1]
}}}

You can also generate infinite lists using ranges by omitting the last element:

{{{
ela>[1..]

[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,
31,32,33,34,35,36,37,38,39,40,41...]

ela>[3,2..]

[3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,
-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37...]
}}}

You can even create ranges with tuples:

{{{
ela>[(1,2)..(5,6)]

[(1,2),(2,3),(3,4),(4,5),(5,6)]
}}}

In all the code samples above I was using ranges to generate a linked list however you can also create an array using the same technique (however infinite arrays are not supported):

{{{
ela>[|1.. |]

(1,3): Error ELA320: Range: '[|1..|]' is invalid. Only lists can be generated us
ing infinite ranges.

ela>[|1..5|]

[|1,2,3,4,5|]
}}}

Comprehension is a slightly more complex concept. Comprehension can be used to generate sequences of elements based on certain conditions with transformation of selected values. They are somewhat similar to C# Linq expressions but with a completely different notation.

Comprehension is combined from three parts - a value to select, an expression that actually fetches a value and an optional condition. Let's say that we have a range `[1..10]` and we need to select all even integers from it, multiply each element by two and compile a new list with the result. This is how this task might be written using Linq like syntax:

{{{
from x in [1..0] where x % 2 == 0 select x * 2
}}}

And that is the Ela version:

{{{
ela>[x * 2 \\ x <- [1..10] | x % 2 == 0]

[4,8,12,16,20]
}}}

What you can see in here? First it starts from the selected expression (which is in our case `x * 2`), it is followed by a mandatory `\\` operator and an expression that denotes how we are going to obtain this `x`. In our case we are just simply fetching it from a numeric range. The comprehension ends with a guard that has a typical guard syntax - a boolean expression preceeded by pipe operator.

As I've mentioned above, guard is not mandatory and you can omit it:

{{{
ela>[x * 2 \\ x <- [1..10]]

[2,4,6,8,10,12,14,16,18,20]
}}}

You can also use multiple guards:

{{{
ela>[x * 2 \\ x <- [1..10] | x % 2 == 0, x > 5]

[12,16,20]
}}}

You can even generate your sequence based on several inputs like so:

{{{
ela>[x * y \\ x <- [10,9..1], y <- [1..10] | x % 2 == 0, x > 5]

[10,20,30,40,50,60,70,80,90,100,8,16,24,32,40,48,56,64,72,80,6,12,18,24,30,36,42,
48,54,60]
}}}

Comprehensions can also be used to generate lazy lists like so:

{{{
ela>[& x \\ x <- [1..]]

[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,
31,32,33,34,35,36,37,38,39,40,41...]
}}}

You can use comprehensions to generate arrays as well:

{{{
ela>[|x * 2 \\ x <- [1..10] | x % 2 == 0, x > 5|]

[|12,16,20|]
}}}

Basically all these constructs are just syntax sugar for a comprehension operator `@@` that is used like so:

{{{
ela>[||] @@ [1..5]

[|1,2,3,4,5|]

ela>[||] @@ [x * 2 \\ x <- [1..10] | x % 2 == 0, x > 5]

[|12,16,20|]
}}}

And with tuples:

{{{
ela>(0,) @@ [x \\ x <- [1..10] | x % 2 == 0]

(0,2,4,6,8,10)
}}}

But tuples, arrays and lists are the only data types that are supported. If you try to use a comprehension operator with some other data type you are going to get a runtime error:

{{{
ela>"bar" @@ [x \\ x <- [1..10] | x % 2 == 0]

(1,11): Error ELA924: A value 'bar' of type 'string' doesn't support trait 'Gen' 
(cannot be used in comprehensions and ranges). 
		in memory at line: 1, col: 11 
}}}

===Bound===

_Bound_ trait is implemented by types that share a notion of a maximum and minimum value. These are the four numeric types. Built-in functions `min` and `max` represent this trait:

{{{
ela>max 0

2147483647

ela>min 0

-2147483648
}}}

===Enum===

_Enum_ trait defines two operations - getting a successor of a given value and getting its predeccesor. Ela has two built-in functions for that - `succ` and `pred`. You can use these functions with four numeric types, chars and tuples:

{{{
ela>succ 12

13

ela>pred (42,43)

(41,42)

ela>pred 'b'

a
}}}

===Num===

_Num_ stands for "numeric" and as you can guess this trait defines a bunch of arithmetic operations: _addition_ (`+`), _substraction_ (`-`), _multiplication_ (`*`), _division_ (`/`), _remainder_ (`%`) and _power_ (`**`). These operations are supported by numeric types and tuples:

{{{
ela>(1,2) * (3,2)

(3,4)

ela>(40,13) / (9,2)

(4,6)
}}}

As you usual don't try to use arithmetic operations with data types that don't support arithmetic - it won't work:

{{{
ela>"Hello," + " world!"

<memory>(1,12): Error ELA906: A value 'Hello,' of type 'string' doesn't support
trait 'Num' (basic arithmetic operations).
        in memory at line: 1, col: 12
}}}

===Neg===

_Neg_ trait contains a single operation - unary negation. As with _Num_ trait you can use it with all numeric types and tuples:

{{{
ela>--(1,2)

(-1,-2)
}}}

===Bit===

_Bit_ trait is supported by 32-bit integers, 64-bit integers and tuples. This trait contains bitwise operations including _bitwise and_ (`&&&`), _bitwise or_ (`|||`), _bitwise xor_ (`^^^`), _bitwise not_ (`~~~`), _left shift_ (`<<<`) and _right shift_ (`>>>`).

{{{
ela>(1,2) ||| (3,4)

(3,6)
}}}

===Concat===

_Concat_ trait lets you concatenate entities. Entities here include lists, arrays and strings. Remember an error that we've caught trying to sum two strings using `+` operator? That is the right way to do that:

{{{
ela>"Hello," ++ " world!"

Hello, world!
}}}

===Thunk===

This one is implemented by lazy data type and its primary goal is to signal to Ela virtual machine that a given value represents an unevaluated expression that should be calculated only when its value is needed for a particular operation.

===Fold===

_Fold_ trait is used by pattern matching. If a provided value implements _Fold_ it means that Ela can "fold" it, in other words - to deconstruct using `::` operator. Having this as a trait really simplifies the work with some of the data types. For example you can fold strings and even arrays. They both can pretend to be lists when it is really needed. Let's see _Fold_ in action:

{{{
ela>let foldl f z x::xs = foldl f (f z x) xs; _ z [] = z

ela>foldl (+) 0 [1,2,3]

6

ela>foldl (+) 0 [|1,2,3|]

6

ela>foldl (\x y -> x:int + y:int) 0 "abac"

391
}}}

_Fold_ trait is really important in Ela. Ela doesn't have a concept of iterators of which you probably have heard already if you ever programmed in C# or JavaScript. Basically iterators are not really needed in a functional language where a task of iterating through a sequence of elements is normally implemented through a recursion. However if you want to write generic code that can effectively iterate over containers of different types you definitely need some kind of an abstraction that can be used to work with lists, arrays, strings in a similar fashion. And _Fold_ is exactly the abstraction we are need here.

===FieldGet===

This trait defines a single operation - obtain a value of a field using `.` (dot) operator. It is pretty similar to the _Get_ trait and supports only read operation, not an assignment.

The data type that supports `FieldGet` trait in the first place is record. Another one is an array that as you remember exposes a set fields with functions for modification of its content in place:

{{{
ela>let arr = [||]

ela>arr.add

<f>:*->*
}}}

This works but not assignment is allowed:

{{{
ela>arr.add <- ()

(1,12): Warning ELA400: An expression is of type 'unit' and will always cause co
de to fail with an error.
(1,5): Error ELA903: A value '[||]' of type 'array' doesn't support trait 'FieldGet' 
(write field operation).
        in memory at line: 1, col: 5
}}}

Module is the last data type that support _FieldGet_trait.

===FieldSet===

This one is normally paired with _FieldGet_ and allows to change a value of a particular field using `.` operator. Record is the only data type that supports it. Again in order to enable assignment operation you first should declare record fields as mutable:

{{{
ela>let rec = {mutable x=0, y=0}

ela>rec.y <- 1

(1,5): Error ELA816: Field 'y' of the record '{mutable x=1,y=0}' is immutable and 
cannot be changed.
        in memory at line: 1, col: 5

ela>rec.x <- 1

ela>rec.x

1
}}}

===Bool===

_Bool_ trait tells Ela virtual machine that a particular value can be treated as boolean. And the only standard data type that supports this trait is boolean.

===Cons===

_Cons_ trait defines a construction operation that is implemented by a standard Ela operator `::`. You would normally use it to construct linked lists however lazy data type also supports it and that is the reason why the following code is legal in Ela:

{{{
ela>1::2::(& 2 + 2)

[1,2,4]
}}}

===Convert===

_Convert_ trait defines a type conversion operation that is performed using `:` operator. All Ela data types except of unit support it. However having support of this trait doesn't neccessarily mean that none of the requested conversions will fail. For example you can't convert lists to arrays or strings to tuples:

{{{
ela>"boo":tuple

(1,7): Error ELA319: Casting to the type 'tuple' is not supported.
}}}

==How to use this knowledge==

In reality you can program in Ela and don't even think about traits at all. Such trick won't work with Haskell that has a similar "type class" concept. But Ela is a dynamic language which already gives a lot of freedom in operations with types. However if you want to master programming in Ela you should definitely familiarize yourself with the trait concept. Ela comes with a rich set of built-in operations and traits is they way how you can use them in a more effective and generic manner.