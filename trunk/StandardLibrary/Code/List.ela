open Collection[elalib];

/* returns an empty list */
let empty = [];

/* returns a length of the list */
let length = Collection.listLength; //length(list)

/* returns `Some(x) where x is a head of the list if a list is not empty,
	otherwise returns `None */
let head(list) 
	on x::_ -> `Some(x)
	on [] -> `None;

/* returns `Some(xs) where xs is a tail of the list if a list is not empty,
	otherwise returns `None */
let tail(list) 
	on _::xs -> `Some(xs)
	on [] -> `None;

/* returns a new list that contains the elements of the first list 
	followed by elements of the second */
let append(list1, list2) list1 + list2;

/* return true if the list contains no elements, otherwise - false */
let isEmpty(list) list is [];
	
/* sorts a list using a given function as a comparer */
let sort = Collection.sortList; //sort(list, fun)

/* reverses a list */
let reverse = Collection.reverseList; //reverse(list)

/* converts a given array or tuple to list */
let fromArray = Collection.arrayToList; //fromArray(arr)

/* converts a given list to array */
let toArray = Collection.listToArray; //toArray(arr)

/* converts a given list to sequence */
let toSeq(list) list :> seq;

/* returns an elements of the list with the specified index */
let item = Collection.listItem; //item(list, index)

/* returns a new list whose elements are the results of applying the
	given function to each of the elements in the given list */
let map(list, fun) [ for (e in list) fun(e) ];

/* returns a new list containing only the elements of the list for which the 
	given predicate returns true */
let filter(list, pred) [ for (e when pred(e) in list) e ];
	
/* splits the list into two lists, containing the elements for which the given 
	predicate returns true and false respectively */
let partition(list, pred) {
	var trueList = [];
	var falseList = [];

	for (e in list) {
		if (pred(e))
			trueList ::= e
		else
			falseList ::= e
	}
	
	(trueList, falseList)
}

/* creates a list by calling the given function on each element */
let replicate(list, fun) match (list) 
	on x::xs -> fun(x)::replicate(xs, fun)
	on [] -> [];
	

/* splits a list of pairs into two lists */
let unzip(list) {
	var list1 = [];
	var list2 = [];

	for (e in list)
	{
		list1 = e[0]::list1;
		list2 = e[1]::list2;
	}
	
	(list1, list2)
}

/* combines the two lists into a list of pairs. The two lists must have equal lengths */
let zip(list1, list2) 
	on x1::xs1, x2::xs2 -> (x1, x2) :: zip(xs1, xs2)
	on _ -> [];