open Core

let inline ^^ x y = x:string ++ y:string

let assert =
    {
        eq  = op' "eq"  (==),
        neq = op' "neq" (<>),
        gt  = op' "gt"  (>),
        lt  = op' "lt"  (<),
        gte = op' "gte" (>=),
        lte = op' "lte" (<=),
        eqt = op' "eqt" (==) true,
        eqf = op' "eqf" (==) false
    }
    where op' m op x y | op x y = ()
                       | else   = raise AssertFailed (m)

let funData fun = (t.module.name ++ "." ++ t.name, fun)
                  where t = type fun
    
let regFun fun xs = funData fun  :: xs

let regFuns mod xs = xs ++ (vals |> filter (\x -> x is ?fun) |> map funData)
                     where vals = [ v.value \\ v <- (type mod).globals ]

let run xs = (res, failed)
        where exec (n, f) = try (f assert $ n, true, "") with 
                                 `AssertFailed m = (n, false, ": Assert failed: " ++ m)
                                 `             m = (n, false, ": Error occured: " ++ m)
           et count f xs = length <| filter f xs
           et res = map exec xs
           et failed = count (\(_,y,_) -> not y) res
              
let fmt prf (tests, failed) =
        out "Test session started" 
            (all' tests 1 "")
            "Test session finished"
            ("Executed tests: " ^^ (length tests))
            ("Successful tests: " ^^ (length tests - failed))
            ("Failed tests: " ^^ failed)
        where out v = prf v $ out
           et tag' true  = "Success "
              tag' false = "FAILED "
           et fmt' i (n, r, m) = i ^^ ". " ^^ n ^^ ": " ^^ (tag' r) ^^ " " ^^ m ^^ "\r\n"
           et all' x::xs i s = (s ++ fmt' i x) |> all' xs (i + 1)
              all' []    _ s = s
