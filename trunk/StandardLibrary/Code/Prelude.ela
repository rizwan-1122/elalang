/* 
    Ela standard Prelude module
    Created in 2011-2012 by Basil Voronkov
*/
open lang

/* Arithmetic operators */
let (+)  = add
let (-)  = sub
let (*)  = mul
let (/)  = div
let (%)  = rem
let (**) = pow
let (--) = neg

/* Bounds */
let min = min
let max = max

/* Bitwise operators */
let (&&&) = bitand
let (|||) = bitor
let (^^^) = bitxor
let (~~~) = bitnot
let (>>>) = shr 
let (<<<) = shl

/* Equality and comparison */
let (==) = eq
let (<>) = neq
let (>=) = gteq
let (<=) = lteq
let (<)  = lt
let (>)  = gt

/* Boolean operators */
let not = _not

/* Construction and concatenation */
let (::) = cons
let (++) = cat

/* Function related operators and functions */
let (>>) = __internal compforward
let (<<) = __internal compbackward
let flip = _flip

let curry f x y = f (x, y)
let uncurry f (x, y) = f x y
let curry3 f x y z = f (x, y, z)
let uncurry3 f (x, y, z) = f x y z

/* Enumerable */
let succ = succ
let pred = pred

/* List functions */
let (!!) x y = x.[y]
let nil    = _nil
let isNil  = isnil
let head   = _head
let tail   = _tail
let length = len

/* Tuple functions */
let (=>) x y = (x, y)
let swap (x, y) = (y, x)
let swap3 (x, y, z) = (y, x, z)
let fst = elem1of2
let snd = elem2of2
let fst3 = elem1of3
let snd3 = elem2of3

/* Show */
let showf = _showf
let show  = showf ""

/* Complex behaviors */
let type  = _type
let force = _force

/* Variants */
let tag   = gettag
let untag = _untag

/* Combinators */
let id x = x//I
let const x _ = x//K
let sub x y z = x z (y z)//S
let fix f = f (& fix f)
let on cmb f x y = f x `cmb` f y

/* Conversion */
let convert = conv
let toInt x     = conv 1 x
let toLong x    = conv 2 x
let toSingle x  = conv 3 x
let toDouble x  = conv 4 x
let toBool x    = conv 5 x
let toChar x    = conv 6 x
let toString x  = conv 7 x
let toList x    = conv 9 x
let toTuple x   = conv 11 x
let toRecord x  = conv 12 x
let toLazy x    = conv 16 x
let toVariant x = conv 17 x

/* Misc */
let (!) = __internal apply
let until p f x | p x  = x | else = until p f (f x)
let compare x y | x == y = EQ | x < y = LT | else = GT