open Collection[elalib];

/* returns an empty sequence */
let empty = [] :> seq;

/* returns a length of the sequence */
let length = Collection.length; //length(seq)

/* applies a function to each element of the sequence from left to right, 
	threading an init argument through the computation */
let fold(seq, init, fun) {
	var ret = init;

	for (e in seq)
		ret = fun(e, ret);
		
	ret
}

/* applies a function to each element of the sequence from right to left, 
	threading an init argument through the computation */
let foldBack(seq, init, fun) {
	var rev = Collection.reverse(seq);
	fold(rev, init, fun)
}

/* applies a function to each element of the sequence */
let apply(seq, fun) for (e in seq) fun(e);
	
/* applies a function to the elements of the sequence for which the 
	given predicate returns true */
let applyIf(list, fun, pred) for (e when pred(e) in list) fun(e);
		
/* returns true if the given predicate returns true for all the elements
	in the sequence */
let forAll(seq, pred) {
	for (e when !pred(e) in seq)
		return false;
	
	true
}

/* returns true if the given predicate returns true for at least one of the 
	elements in the sequence */
let forAny(seq, pred) {
	for (e when pred(e) in seq)
		return true;
	
	false
}

/* returns the first element for which the given function returns true */
let find(seq, pred) {
	for (e when pred(e) in seq)
		return `Some(e);
		
	`None
}

/* returns the index of the first element in the list that satisfies 
	the given predicate */
let findIndex(seq, pred) {
	var c = 0;

	for (e in seq) {
		c++;
	
		when (pred(e))
			return `Some(c);
	}
	
	`None
}

/* returns the average of the elements in the sequence */
let average(seq) {
	var len = 0;
	var total = 0;

	for (e in seq) {
		len++;
		total += e;
	}
	
	(total / len)
}

/* returns a new lazy sequence containing only the elements of the initial sequence for 
	which the given predicate returns true */
let filter(seq, pred) for (x when pred(x) in seq) -> x;

/* returns a sequence that contains no duplicate entries */
let distinct = Collection.distinct; //distinct(seq)

/* returns the average of the elements generated by applying the function to each 
	element of the list */
let averageBy(seq, fun) {
	var len = 0;
	var total = 0;

	for (e in seq) {
		len++;
		total += fun(e);
	}
	
	(total / len)
}

/* return the greatest of all elements of the sequence */
let max(seq) {
	var acc = 0;

	for (e in seq) {		
		when (e > acc)
			acc = e;
	}
	
	acc
}

/* returns the greatest of all elements of the sequence, compared on the function result */
let maxBy(seq, fun) {
	var acc = 0;

	for (e in seq) {
		let m = fun(e);
		
		when (m > acc)
			acc = m;
	}
	
	acc
}

/* return the smallest of all elements of the sequence */
let min(seq) {
	var acc = 0;

	for (e in seq) {		
		when (e < acc)
			acc = e;
	}
	
	acc
}

/* returns the smallest of all elements of the sequence, compared on the function result */
let minBy(seq, fun) {
	var acc = 0;

	for (e in seq) {
		let m = fun(e);
		
		when (m < acc)
			acc = m;
	}
	
	acc
}

/* returns the sum of the elements in the sequence */
let sum(seq) {
	var acc = 0;

	for (e in seq)	
		acc += e;
	
	acc
}

/* returns the sum of the results generated by applying the function to each element of 
	the sequence */
let sumBy(seq, fun) {
	var acc = 0;

	for (e in seq) 
		acc += fun(e);
	
	acc
}

/* applies a function to each element of the sequence, threading an accumulator argument 
	through the computation. This function applies the specified function to the first two 
	elements of the sequence. It then passes this result into the function along with the third 
	element, and so on. Finally, it returns the final result */
let reduce(seq, fun) {
	var el = ();
	
	for (e in seq) {
		if (el is void)
			el = e;
		else 
			el = fun(el, e);		
	}
	
	el
}

/* performs the same computation as reduce taking the list in the reverse order */
let reduceBack(seq, fun) reduce(seq |> Collection.reverse, fun);