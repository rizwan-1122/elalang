/* 
    Ela Core module
    Created in 2011 by Basil Voronkov
*/
open CoreInternal#elalib

/* MATH */

let abs x | x >= 0 = x
          | else   = --x

let exp = CoreInternal.exp

let gcd 0 0 = fail "Core.gcd: gcd 0 0 is undefined"
        x y = gcd' (abs x) (abs y)
              where gcd' x 0 = x
                         x y = gcd' y (x % y)
              
let cos = CoreInternal.cos

let sin = CoreInternal.sin

let tan = CoreInternal.tan

let quot = CoreInternal.quot

let lcm _ 0 = 0
        0 _ = 0
        x y = abs ((x `quot` gcd x y) * y)

let floor = CoreInternal.floor

let ceiling = CoreInternal.ceiling

let subtract = flip (-)

let atan = CoreInternal.atan

let sqrt x = x ** 0.5

let truncate = CoreInternal.truncate

let log = CoreInternal.log

let even x = x % 2 == 0

let odd x = x % 2 <> 0

let maxValue x y | x >= y = x
                 | else   = y

let minValue x y | x <= y = x
                 | else   = y

let round = CoreInternal.round

let rnd = CoreInternal.rnd

let pi = CoreInternal.pi

let e = CoreInternal.e


/* Basic */

/* a function with a recursive definition that can be
    evaluated solely for the side effects of it first argument.
    rec can be used for the function 'f' of one argument, rec2 - 
    for the function 'f' of two arguments. */
let rec f x = f x $ rec

let rec2 f x y = f x y $ rec2

let until p f x | p x  = x
                | else = until p f (f x)

let compare x y | x == y = `EQ
                | x <= y = `LT
                | else   = `GT

let chr (?int)@x = x:char

let ord (?char)@x = x:int


/* COMBINATORS */

/* id, const and sub are SKI combinators */
let id x = x//I

let const x _ = x//K

let sub x y z = x z (y z)//S

/* fixed point combinator with non strict behavior
    strict version of this function is as follows:
    let fix f x = f (fix f) x */
let fix f = f (& fix f)

let on cmb f x y = f x `cmb` f y


/* LIST FUNCTIONS */

//Ix->a->a
let !! x y = x.[y]

//Seq->a
let head x::_ = x
         []   = fail "Core.head: Empty list"

//Seq->Seq
let tail _::xs = xs
         []    = fail "Core.tail: Empty list"

//Seq->a
let last x::[] = x
         _::xs = last xs
         []    = fail "Core.last: Empty list"

//(Seq,Cons)->(Seq,Cons)
let init x::([]@n) = n
         x::xs     = x :: init xs
         []        = fail "Core.init: Empty list"

//Seq->Bool
let isNil _::_ = false 
          []   = true

//Call->(Seq,Cons)->(Seq,Cons)
let takeWhile f x::xs | f x  = x :: takeWhile f xs
                      | else = nil xs
              f []@n         = n

//Num->(Seq,Cons)->(Seq,Cons)
let take 0 xs    = nil xs
         n x::xs = x :: take (n - 1) xs
         _ []@n   = n

//Num->(Seq,Cons)->(Seq,Cons)
let skip 0 xs    = xs
         n _::xs = skip (n - 1) xs
         _ []@n  = n

//Call->Seq->u
let each f x::xs = f x $ each f xs
         _ []    = ()
       
//Call->(Seq,Cons)->(Seq,Cons)
let map f x::xs = f x :: map f xs
        _ []@n  = n
        
//Call->Seq->list
let map' f x::xs = f x :: (& map' f xs)
         _ []    = []
           
//Call->(Seq,Cons)->(Seq,Cons)
let filter p x::xs | p x  = x :: filter p xs
                   | else = filter p xs
           _ []@n         = n

//Call->Seq->list
let filter' p x::xs | p x  = x :: (& filter' p xs)
                    | else = filter' p xs
            _ []@n         = n

//Call->a->Seq->a
let foldl f z x::xs = foldl f (f z x) xs
          _ z []    = z
       
//Call->a->Seq->a
let foldr f z x::xs = f x (foldr f z xs)
          _ z []    = z

//Call->(Seq,Cons)->a
let fold f xs = foldr f (nil xs) xs

//(Seq,Cons,Concat)->(Seq,Cons,Concat)
let concat x::xs = x ++ concat xs 
           []@n  = n

//Call->(Seq,Cons)->(Seq,Cons)
let concatMap f x::xs = f x :: concatMap f xs 
              _ []@n  = n

//Seq[Num]->Num
let sum xs = sum' 0 xs
             where sum' s x::xs = sum' (s + x) xs
                        s []    = s

//Seq[Num]->Num
let product xs = product' 1 xs
                 where product' p x::xs = product' (p * x) xs
                                p []    = p

//Seq[Ord]->Ord
let minimum x::xs = minimum' x xs
                    where minimum' v x::xs | x < v = minimum' x xs
                                           | else  = minimum' v xs
                                   v []            = v

//Seq[Ord]->Ord
let maximum x::xs = maximum' x xs
                    where maximum' v x::xs | x > v = maximum' x xs
                                           | else  = maximum' v xs
                                   v []            = v

//(Seq,Cons)->(Seq,Cons)
let reverse xs = foldl (flip (::)) (nil xs) xs
        
//Call->(Seq,Cons)->(Seq,Cons)->(Seq,Cons)
let zipWith z x::xs y::ys = z x y :: zipWith z xs ys
            _ _     ys    = nil ys

//Call->Seq->bool
let any f x::xs | f x  = true
                | else = any f xs
        _ []           = false
        
//Call->Seq->bool
let all f x::xs | f x  = all f xs
                | else = false
        _ []           = false

//Num->(Seq,Cons)->tuple[(Seq,Cons)]
let splitAt 0 xs            = (nil xs,xs)
            _ []@n          = (n,n)
            n x::xs | n > 0 = (x::xs',xs2')
                              where (xs',xs2') = splitAt (n-1) xs
                              
            _ _             = fail "Core.splitAt: negative argument"

//Call->(Seq,Cons)->tuple[(Seq,Cons)]
let span p []@n = (n,n)
         p (x::xs')@xs | p x  = (x::ys, zs)
                       | else = (nil xs,xs)
                       where (ys,zs) = span p xs'

//Call->(Seq,Cons)->tuple[(Seq,Cons)]
let breakList p xs = span p' xs
                     where p' x = not (p x)

//Num->(Seq,Cons)->(Seq,Cons)
let drop 0 xs            = xs
         _ []@n          = n
         n _::xs | n > 0  = drop (n-1) xs
         _ _             = fail "Core.drop: negative argument"

//Call->(Seq,Cons)->(Seq,Cons)
let dropWhile p []@n = n
              p x::xs | p x  = dropWhile p xs
                      | else = x::xs

//Ord->Seq->int
let index e lst = index' 0 lst
                  where index' n x::xs | x <> e = index' (n+1) xs
                                       | else   = n
                               n []    = n

//Eq->Seq->bool
let elem x = any (==x)

//Call->a->Seq->bool
let elemBy _  _ []    = false
           eq y x::xs = y `eq` x || elemBy eq y xs

//Eq->Seq->bool
let notElem x = all (<>x)

//Call->a->(Seq,Cons)->(Seq,Cons)
let scanl f q x::xs = scanl f (f q x) xs
          _ _ []@n  = n

//Call->a->(Seq,Cons)->(Seq,Cons)
let scanr f q0 []@n  = q0::n
          f q0 x::xs = f x q :: qs
                       where (q::_)@qs = scanr f q0 xs

//a->list
let repeat x = x :: (& repeat x)

//Seq->list
let cycle head::tail = head :: (& cycle' tail)
                       where cycle' x::xs = x :: (& cycle' xs)
                                    []    = head :: (& cycle' tail)

//Call->a->list
let iterate f x = x :: (& iterate f (f x))

//Ord->Ord->list
let replicate n x = take n (repeat x)

//Call->a->(Seq,Cons)->(Seq,Cons)
let deleteBy p x y::ys | p x y  = ys
                       | else   = y :: deleteBy p x ys
             _ _ []@n           = n

//a->(Seq,Cons)->(Seq,Cons)
let delete = deleteBy (==)

//Call->a->(Seq,Cons)->(Seq,Cons)
let insertBy _   x []@n = x::n
             cmp x (y::ys')@ys | cmp x y is (`GT) = y :: insertBy cmp x ys'
                               | else             = x :: ys

//a->(Seq,Cons)->(Seq,Cons)
let insert = insertBy compare

//Call->(Seq,Cons)->(Seq,Cons)
let nubBy eq xs = nubBy' xs (nil xs)
                  where nubBy' []@n _ = n
                               y::ys xs | elemBy eq y xs = nubBy' ys xs
                                        | else           = y :: nubBy' ys (y::xs)

//(Seq,Cons)->(Seq,Cons)
let nub = nubBy (==)

/*  takes an element and a sequence and intersperses that element between the elements of the sequence:
intersperse ',' "abcde" = "a,b,c,d,e" */
//a->(Seq,Cons)->(Seq,Cons)
let intersperse e x::([]@n) = x :: intersperse e n
                e x::xs     = x :: e :: intersperse e xs
                _ []@n      = n

/* transposes the rows and columns of its argument:
transpose [[1,2,3],[4,5,6]] = [[1,4],[2,5],[3,6]] */
//(Seq,Cons)->(Seq,Cons)
let transpose []::xs      = transpose xs
              (x::xs)::ys = (x :: [h \\ (h::_) <- ys]) :: transpose (xs :: [t \\ (_::t) <- ys])
              []@n        = n

/* inserts the given sequence in between the sequences and concatenates the result. */
//(Seq,Cons)->(Seq,Cons)
let intercalate xs xss = concat (intersperse xs xss)

/* returns the list of all subsequences of the argument, except for the empty list:
nonEmptySubsequences [1,2] = [[1],[2],[1,2]] */
//(Seq,Cons)->(Seq,Cons)
let nonEmptySubsequences x::xs = (x::(nil xs)) :: fold f (nonEmptySubsequences xs)
                                 where f ys r = ys :: (x :: ys) :: r                         
                         []@n  = n

/* returns the list of all subsequences of the argument:
subsequences [1,2] = [[], [1],[2],[1,2]] */
//(Seq,Cons)->(Seq,Cons)
let subsequences xs = (nil xs) :: nonEmptySubsequences xs 

/* returns a sequence with all permutations of the argument:
permutations "abc" == ["abc","bac","cba","bca","cab","acb"] */
//(Seq,Cons)->(Seq,Cons)
let permutations 
                 []@n = n
                 xs0  = xs0 :: perms xs0 []
                        where perms []    _   = []
                                    t::ts is' = foldr interleave (perms ts (t::is')) (permutations is')
                                                where interleave xs r       = let (_,zs) = interleave' id xs r in zs and
                                                      interleave' _ [] r    = (ts, r)
                                                                f y::ys r = let (us,zs) = interleave' (f << (y::)) ys r
                                                                            in  (y::us, f (t::y::us) :: zs)

/* takes a predicate and two lists and returns the first list with the first 
occurrence of each element of the second list removed. */
//Call->(Seq,Cons)->(Seq,Cons)
let groupBy eq x::xs = (x::ys) :: groupBy eq zs
                       where (ys,zs) = span (eq x) xs
            _  []@n  =  n

//(Seq,Cons)->(Seq,Cons)
let group =  groupBy (==)

/* takes the list intersection of two lists. */
//Call->Seq->Seq
let intersectBy eq xs ys =  [x \\ x <- xs | any (eq x) ys]

//Seq->Seq
let intersect = intersectBy (==) 


/* TUPLE FUNCTIONS */

let => x y = (x, y)

let fst (x, _) = x

let snd (_, y) = y

let fst3 (x, _, _) = x

let snd3 (_, y, _) = y

let swap (x, y) = (y, x)

let swap3 (x, y, z) = (y, x, z)

/* currying and uncurrying for functions with pairs and
    with triples. */
let curry f x y = f (x, y)

let uncurry f (x, y) = f x y

let curry3 f x y z = f (x, y, z)

let uncurry3 f (x, y, z) = f x y z
