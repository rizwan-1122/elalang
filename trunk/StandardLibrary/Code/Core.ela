/* Core Ela functions */

/* get by index operator, can be used with tuples, records and lists */
let !! x y = x.[y]

/* TUPLE FUNCTIONS */

let => x y = (x, y)

let fst (x, _) = x

let snd (_, y) = y

let fst3 (x, _, _) = x

let snd3 (_, y, _) = y


/* LIST FUNCTIONS */
        
let head x::_ = x;
         []   = fail "Empty list"

let tail _::xs = xs;
         []    = fail "Empty list"

let last x::[] = x;
         _::xs = last xs;
         []    = fail "Empty list"

let init x::[] = [];
         x::xs = x :: init xs;
         []    = fail "Empty list"

let nil _::_ = false; [] = true
              
let takeWhile f x::xs | f x  = x :: takeWhile f xs;
                      | else = [];
              f []           = []

let take 0 _     = [];
         n x::xs = x :: take (n - 1) xs;
	     _ []    = []
	   
let skip 0 xs    = xs;
         n _::xs = skip (n - 1) xs;
         _ []    = []

let each f x::xs = f x $ each f xs;
         _ []    = ()
       
let map f x::xs = f x :: map f xs;
        _ []    = []
        
let map' f x::xs = f x :: (& map' f xs);
         _ []    = []
           
let filter p x::xs | p x  = x :: filter p xs;
                   | else = filter p xs;
           _ []           = []

let filter' p x::xs | p x  = x :: (& filter' p xs);
                    | else = filter' p xs;
            _ []           = []

let foldl f z x::xs = foldl f (f z x) xs;
          _ z []    = z
       
let foldr f z x::xs = f x (foldr f z xs);
          _ z []    = z
          
let reverse = foldl (flip (::)) []
        
let zipWith z x::xs y::ys = z x y :: zipWith z xs ys;
            _ _     _     = []
      
let repeat x = x :: (& repeat x)

let cycle head::tail = head :: (& cycle' tail)
                       where cycle' x::xs = x :: (& cycle' xs);
                                    []    = head :: (& cycle' tail)
                       end

let any f x::xs | f x  = true;
                | else = any f xs;
        f []           = false

let elem x = any (==x)

/* COMBINATORS */

/* id, const and sub are SKI combinators */
let id x = x

let const x _ = x

let sub x y z = x z (y z)

/* fixed point combinator with non strict behavior;
	strict version of this function is as follows:
	let fix f x = f (fix f) x */
let fix f = f (& fix f)

/* currying and uncurrying for functions with pairs and
	with triples. */
let curry f x y = f (x, y)

let uncurry f (x, y) = f x y

let curry3 f x y z = f (x, y, z)

let uncurry3 f (x, y, z) = f x y z

/* a function with a recursive definition that can be
	evaluated solely for the side effects of it first argument.
	rec can be used for the function 'f' of one argument, rec2 - 
	for the function 'f' of two arguments. */
let rec f x = f x $ rec

let rec2 f x y = f x y $ rec2
