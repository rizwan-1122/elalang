let private inline
    sum x y = x + y
 et even x = x % 2 == 0
 et odd x = x % 2 <> 0
 et calc x y = (x / y) * (x + y) 
 et compare x y = if x > y then Gt else NotGt
 
let partial1 {eq} =
          eq (sum 2 3) 5
        $ eq (sum2 3) 5
        $ eq (sum3 2) 5    
        where sum x y = x + y
           et sum2 = sum 2
           et sum3 = sum 3

let partial2 {eq} =
          eq (((fun 2) 3) 4) 20
        $ eq (fun 2 3 4) 20
        where fun x y = \z -> z * x + z * y
    
let partial3 {eq} =
        let f1 = fun 10 12
         et f2 = fun 1
         et f3 = fun 6 8 9 in
        eq ((f1 1) 1) 24
        $ eq (((f2 2) 3) 4) 10
        $ eq (f3 7) 30
        where fun x y z k = x + y + z + k
    
let partial4 {eq} =
        eq (fun 2 2 4 2 1) 11
        where fun x y | r > 10 = r
                      | else   = fun r
                      where r = x + y
    
let closure1 {eq} = 
        let x = 2 in
        let fun () = eq x 2 in
        fun ()
    
let closure2 {eq} = 
        let x = {!x=0} in
        let fun () = x in
        eq (fun ()).x 0
        $ x.x <- x.x + 1
        $ eq (fun ()).x 1
        $ x.x <- x.x + 2
        $ eq (fun ()).x 3
    
let flipped1 {eq} = 
        eq (sub 3 2) 1
        $ eq (flip sub 3 2) (--1)
        where sub x y = x - y
    
let flipped2 {eq} = 
        eq (sub 3 2 1) 0
        $ eq (flip sub 3 2 (--1)) 0
        where sub x y z = x - y - z

let flipped3 {eq} =  
        let xs = [1, 2, 3] et res = f xs 
        in eq res.[0] 10
        $ eq res.[1] 20
        $ eq res.[2] 30
        where fold' [] f = []
              fold' x::xs f = f x :: fold' xs f
           et f = flip fold' (*10)

let partialOperators {eq} =
          eq (add' 7 2) 9
        $ eq (add2 3) 5
        $ eq (sub 5 4) 1
        $ eq (sub2 9) 7
        $ eq (div 6 3) 2
        $ eq (div2 2) 4
        where add' = (+)
           et add2 = (+2)
           et sub = (-)
           et sub2 = (-2)
           et div = (/)
           et div2 = (8/)

let partialOperators2 {eq} =
          eq ((^^^5) 10) 5
        $ eq ((5^^^) 10) (--5)
        where ^^^ x y = x - y

let funcTok {eq} =
          eq ((`sub` 8) 20) 12
        $ eq ((sub 8) 20) (--12)
        $ eq ((8 `sub`) 20) (--12)
        where sub x y = x - y

let postfixOperators {eq} =
          eq ((3-) 2) 1
        $ eq ((10/) 2) 5
        $ eq (12 ^^^) 24
        where ^^^ x = x + x

let inline1 {eq,eqt,eqf} =
        eq (sum 2 3) 5
        $ eq (sum 4 12.2) 16.2
        $ eqt (even 4)
        $ eqf (even 3)
        $ eqt (odd 3)
        $ eqf (odd 6)

let inline2 {eq} =
        eq (calc 123 23) 730
        $ eq (calc 700 14) 35700
        $ eq (compare 10 2) Gt
        $ eq (compare 18 1.222) Gt
        $ eq (compare 13 13.9) NotGt

let inline3 {eq} = 
        eq (sum 2 3) 10
        where getFun z = let inline sum x y = x + y + z in sum
           et sum = getFun 5

let inline4 {eq} = 
        let inline sum x y = x + y + z
        in eq (sum 2 3) 8
        where z = 3
        
let inline5 {eq} = 
          eq (add 3) 5
        $ eq (div 6) 3
        where inline y = 2
           et add x = x + y
           et div x = x / y

let infix1 {eq} =
          eq (2 `add` 3) 5
        $ eq (8 `sub` 9) (--1)
        where add x y = x + y
           et sub x y = x - y

let infix2 {eq} =
        let f = 7 `fun` 4
        in eq (f 3) 0
        where fun x y z = x - y -z

let postfix1 {eqt,eqf} =
          eqt (2 `even`)
        $ eqf (5 `even`)
        $ eqt (3 `odd`)
        $ eqf (10 `odd`)
        where even x = x % 2 == 0
           et odd x = x % 2 <> 0

let postfix2 {eq} =
        let add' = 2 `add`
         et sub' = 4 `sub`
         in eq (add' 3) 5
         $ eq (sub' 3) 1
        where add x y = x + y
           et sub x y = x - y

let recursion1 {eq} =
        eq (fact 20) 2432902008176640000L
        where fact = f 1L
              where f acc 0 = acc
                    f acc n = f (n * acc) (n - 1)

let recursion2 {eq} =  
        eq (fib 24) 46368
        where fib = fib' 0 1
              where fib' a b 0 = a
                    fib' a b n = fib' b (a + b) (n - 1)

let recursion3 {eq} =
        let year_size = 365f
         et birthday' prob people | prob' < 0.5 = people + 1f
                                  | else        = birthday' prob' (people + incr)
                                  where prob' = (year_size - people) / year_size * prob
                                     et incr  = 1f
        in eq (birthday' 1f 1f) 23f

let mutualRecur {eq} =
        let mtake x::xs = x::(mskip xs); mtake [] = [] et
            mskip _::xs = mtake xs; mskip [] = [] in
        let res = mtake [1, 2, 3, 4] in
        eq res.[0] 1 $ eq res.[1] 3

let comparision {eq} =
        eq fun1 fun2
        $ eq (getFun!) (getFun!)
        where getFun () = \x y -> x + y
           et fun1 = getFun ()
           et fun2 = getFun ()

let operator1 {eq} =
      eq (rec ? "foo") "foo"
      where  x ? y = x.[y]
         et rec = { foo = "foo" }