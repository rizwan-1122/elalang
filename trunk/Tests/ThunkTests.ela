let private thunk1 = (& 2 + 2)
let private thunk2 = (& add 2 3)
                   where add x y = x + y

let simple {eq,eqt} =
        eq (t + 2) 6
        $ eq t 4
        $ eqt (t == 4)
        where t = (& 2 + 2)
     
let lazyList {eqt} =
        eqt (lst is (0::1::xs))
        where make n = n :: (& make (n + 1))
           et lst = make 0
           
let lazyList2 {eqt} =
          eqt <| xs is (1::2::3::_)
        $ eqt <| xs is (1::2::3::1::2::3::_)
        where cycle xs = xs ++ (& cycle xs)
           et xs = cycle [1,2,3]
              
let memoization {eq} =
        let x = {!x=0} in
        let fun () = x.x <- x.x + 1 $ x in
        let t = (& (fun ()).x ) in
          t + 0
        $ t + 1
        $ eq x.x 1

let sequencing {eq} = 
          (& t.val <- 2)
        $ eq t.val 2
        $ (& t.val <- t.val + t.val)
        $ eq t.val 4
        where t = {!val=0}

let fixPoint {eq} =
        let fix' f = f (& fix' f) in
        let factabs fact 0 = 1
            factabs fact x = x * fact (x - 1) in
        let res = (fix' factabs) 5 in
        eq res 120

let forceTest {eqt} = 
        let _ = eqt (th is ?lazy) in
        let _ = force th
        in eqt (th is ?int)
        where th = (& 2 + 2)

let typeCheck {eqt} =
        let t = (& 2 * 2) in
        eqt (t is ?lazy)
        $ t + 0
        $ eqt (t is ?int)
        
let lazyEquals {eqt} =
        eqt (thunk1 == 4)
        $ eqt (thunk1 <> 5)
        $ eqt (thunk2 == 5)
        $ eqt (thunk2 <> 4)

let lazyCompare {eqt,eqf} =
        eqt (thunk1 > 3)
        $ eqf (thunk1 > 4)
        $ eqt (thunk1 <= 4)
        $ eqt (thunk2 >= 5)
        $ eqf (thunk2 > 6)
        $ eqt (thunk2 < 6)

let lazyMath {eq} =
        eq (thunk1 + 2) 6
        $ eq (thunk1 - 2) 2
        $ eq (thunk1 * 3) 12
        $ eq (thunk1 / 2) 2
        $ eq (thunk1 ** 2) 16
        $ eq (thunk1 % 3) 1
        $ eq (thunk2 + 2) 7
        $ eq (thunk2 - 2) 3
        $ eq (thunk2 * 3) 15
        $ eq (thunk2 / 2) 2
        $ eq (thunk2 ** 2) 25
        $ eq (thunk2 % 2) 1

let lazyConcat {eq} =
        eq ((show <| force thunk1) ++ "str") "4str"
        $ eq ((show <| force thunk2) ++ "str") "5str"
        
let lazyBool {eqt} =
        eqt <| not (thunk1 == 5)
        $ eqt <| not (thunk2 == 4)
        
let lazyFunc {eq} =
        eq (lf 2 3) 5
        $ eq (lf2 3) (--3)
        where lf = (& \x y -> x + y)
           et lf2 = (& \x -> --x)