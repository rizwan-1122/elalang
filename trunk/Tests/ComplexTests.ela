open Test
open Debug

let firstSecond {eq} =
	let fst (x, _) = x in
    let snd (_, y) = y in
    eq (fst (2, 3)) 2 $ eq (snd (3, 4)) 4
	
let triangles {eq,eqt} =
	let head' x::xs = x in
    let triangles' = [ (a,b,c) \\ c <- [1..10], b <- [1..c], a <- [1..b] |
                        a**2 + b**2 == c**2, a+b+c == 24]
    in
    eqt ((head' triangles') ? tuple)
    $ eq (head' triangles').[0] 6
    $ eq (head' triangles').[1] 8
    $ eq (head' triangles').[2] 10
	    
let zips {eqt} =
	let zip x::xs y::ys = (x, y) :: zip xs ys;
            _ _         = [] in
    let f1 = zip [1,2,3,4,5] [5,5,5,5,5] in
    let f2 = zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"] in
    eqt (f1.[0] ? (1, 5))
    $ eqt (f1.[1] ? (2, 5))
    $ eqt (f1.[2] ? (3, 5))
    $ eqt (f1.[3] ? (4, 5))
    $ eqt (f1.[4] ? (5, 5))
    $ eqt (f2.[0] ? (5,"im"))
    $ eqt (f2.[1] ? (3,"a"))
    $ eqt (f2.[2] ? (2,"turtle"))
	
let calcFact {eq} =
	let fact = 
		let f acc 0 = acc;
		      acc n = f (n * acc) (n - 1) in			
		f 1L 
    in
	eq (fact 20) 2432902008176640000L
	
    
let skipElems {eqt} = 
	let skip lst n = 
		let ps x::xs i | i == n = xs;
                       | else   = ps xs (i + 1);
		       _ _              = () 
        in
		if ps lst 1 ? (list@r) then `Some r else `None 
    in
	let res = skip [0, 1, 2, 3] 2 in
	eqt <| res ? (`Some [2,3])

let takeElems {eqt} =
	let take lst n =
		let pt x::xs i | i == n = [x];
                       | else   = x :: pt xs (i + 1);
		       _ _              = [] 
        in	
        let r = pt lst 1 in
	    if r ? [] then `None else `Some r 
    in
	let res = take [0, 1, 2, 3, 4] 3 in
	eqt <| res ? (`Some [0,1,2])

let reverseElems {eqt} =
	let reverse' x::xs = reverse' xs ++ [x];
			     []    = [] 
    in
	let res = reverse' [0, 1, 2, 3, 4, 5] in
	eqt (res ? [5,4,3,2,1,0])

let compare {eqt} =
	let compare' x y | y >  x = `Gt;
                     | y == x = `Eq;
                     | else   = `Lt 
    in
	let compareWithHundred = compare' 100 in
	eqt <| (compareWithHundred 12) ? (`Lt)
	
let flipFold {eq} =  
	let fold' x::xs f = f x :: fold' xs f;
			  [] f    = [] in
    let list = [1, 2, 3] in
    let f = flip fold' (*10) in
    let res = f list 
    in
    eq res.[0] 10
    $ eq res.[1] 20
    $ eq res.[2] 30
	
let mutualRecur {eq} =
	let Mtake x::xs = x::(Mskip xs); [] = [] and
		Mskip _::xs = Mtake xs; [] = [] in
    let res = Mtake [1, 2, 3, 4] in
	eq res.[0] 1 $ eq res.[1] 3
	
let fixPoint {eq} =
	let fix' f = f (& fix' f) in
    let factabs fact 0 = 1;
	            fact x = x * fact (x - 1) in
    let res = (fix' factabs) 5 in
	eq res 120
	
let fibNumbers {eq} =  
	let fib =
		let fib' a b 0 = a;
			     a b n = fib' b (a + b) (n - 1) in
		fib' 0 1 
    in
	eq (fib 24) 46368
    
let iterators {eqt} =
    let counter f = 
        let mutable cc = 0 in
        let counter' e = f cc e $ cc <- cc + 1 
        in counter'             
    and comparer 0 1 = eqt true;
                 1 4 = eqt true;
                 2 7 = eqt true;
                 3 2 = eqt true;
                 4 5 = eqt true;
                 5 8 = eqt true;
                 6 3 = eqt true;
                 7 6 = eqt true;
                 8 9 = eqt true;
                 _ _ = eqt false
    and lst = [ [1,2,3], [4,5,6], [7,8,9] ]
    and iterate fun x::xs = fun x $ `Some xs;
                _   []    = `None
    and filter f lst = 
        let filter' x::xs | r ? (`Some v) = v :: filter' xs;
                          | r ? (`None)   = filter' xs
                          where r = f x end;
            []                            = []
        in 
        match filter' lst with
        [] = ();
        nl = filter f nl    
        end
    and iterate' = iterate (counter comparer)        
    in filter iterate' lst
    
let birthday {eq} =
    let year_size = 365.0 and 
        birthday' prob people | prob' < 0.5 = people + 1.0;
                              | else        = birthday' prob' (people + incr)
                              where prob' = (year_size - people) / year_size * prob and
                                    incr  = 1.0
                              end
    in eq (birthday' 1.0 1.0) 23.0