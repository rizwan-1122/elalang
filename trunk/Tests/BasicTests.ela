let equals {eq,eqt,eqf} =
          eqt (2 == 2)
        $ eqt (12L == 12)
        $ eqt true
        $ eqf false 
        $ eq "first" "first" 
        $ eq 'f' 'f'
        $ eq (1,2) (1,2)

let notEquals {neq} =
          neq 2 3 
        $ neq 12L 13
        $ neq true false
        $ neq false true
        $ neq "first" "second" 
        $ neq 'f' 'F'
        $ neq (2,3) (2,4)

let notEquals2 {eqt,eqf} =
          eqt (3 <> 4)
        $ eqf (3 <> 3)
        $ eqt (13L <> 12)
        $ eqf (13L <> 13L)
        $ eqt (true <> false)
        $ eqf (true <> true)
        $ eqt ("first" <> "second") 
        $ eqf ("first" <> "first") 
        $ eqt ('F' <> 'f')
        $ eqf ('F' <> 'F')
        $ eqt ((2,3) <> (2,4))
        $ eqf ((2,3) <> (2,3))
        
let refEquals {eqt,eqf} =
          eqf (t1 === t2)
        $ eqt (t1 == t2)
        $ eqf (s1 === s2)
        $ eqt (s1 == s2)
        where t1 = (1,2) et t2 = (1,2)
           et s1 = "str" et s2 = "str"

let compare {eqt} =
          eqt (12.3 - 12.3 < .001)
        $ eqt (146.23d - 146.23d < .001d)
        $ eqt (24 > 12)
        $ eqt (125L > 124)
        $ eqt (123.23 < 150.0)
        $ eqt (12 >= 12)
        $ eqt (45 <= 46)
        $ eqt (45 <= 45)

let compare2 {eqt,eqf} =
          eqt ("ABC" > "abc")
        $ eqf ("abc" > "ABC")
        $ eqf ("EFG" <= "efg")
        $ eqt ("EFG" >= "efg")
        $ eqt ('a' > 'A')
        $ eqf ('A' > 'a')
        $ eqf ('e' <= 'E')
        $ eqt ('e' >= 'E')
        
let simpleMath {eq,gt,lt} =
          eq (2 + 2) 4 
        $ eq (2 - 2) 0 
        $ lt (12.4 - .4 - 12.0) .001
        $ eq (23 + 112) 135 
        $ eq (2 * 2) 4 
        $ gt (12.0 * 65.3) 771.0
        $ eq (24 / 2) 12 
        $ eq (25 / 2) 12 
        $ gt (25f / 2.0) 12.0 
        $ eq (25 % 2) 1 
        $ eq (23.456 % 12.2) 11.256
        $ eq (24 % 2) 0
        $ eq (3 ** 2) 9
    
let concat {eq} =
          eq ("1" ++ "&" ++ "2") "1&2"
        $ eq ('A':string ++ 'B':string ++ 'C':string) "ABC"
    
let priorities {eq} =
          eq (2 + 2 * 3) 8 
        $ eq (14 / 2 + 4 * 6) 31 
        $ eq (2 + 6 / 3) 4 
        $ eq (1 + 12 - 4 / 2 + 144 * 24 / 12) 299

let boolOperators {eqt,eqf} =
          eqt <| not (2 <> 2)
        $ eqf <| not (2 == 2)
        $ eqt <| not ("First" == "first")
        $ eqt <| not ('A' == 'a')

let boolOperators2 {eq,neq} =
          neq (2 == 2 && 3 <> 3) 
        $ eq (2 <> 2 || 44 == 44) 
        $ eq (124 > 123 || 3 == 3 && true) 
        $ eq (1 > 2 && 2 < 1 || 1 == 1)
    
let pipeOperators {eq} =
        let fun1 x y = x + y
         et fun2 x = x * 2
         et fun3 x = x - 2 in
          eq (fun1 2 2 |> fun2 |> fun3) 6 
        $ eq (fun3 <| fun2 <| fun1 2 2) 6
    
let compositionOperators {eq} =
        let fun1 x = x + 2
         et fun2 x = x * 2
         et fun3 x = x - 2
         et comp1 = fun1 >> fun2 >> fun3
         et comp2 = fun3 << fun2 << fun1 in
         eq (comp1 2) 6 $ eq (comp2 2) 6
    
let bitwiseOperators {eq} =
        let v = 2 ||| (12 <<< 8) in
          eq v 3074
        $ eq (v &&& 255) 2
        $ eq (v >>> 8) 12

let bitwiseOperators2 {eq} = 
        let v = 0x02 ||| 0x04 in
          eq v 6
        $ eq (v ^^^ 0x04) 2
    
let cast {eq} = 
          eq ("123":int) 123
        $ eq ("12.2":single) 12.2
        $ eq (124:string) "124"
        $ eq ("True":bool) true
    
let bitNot {eq} =
          eq (~~~2) (--3)
        $ eq (~~~124) (--125)
        $ eq (~~~(--3)) 2
    
let unaryMinus {eq} =
          eq (--3) (0-3)
        $ eq (--256) (0-256)
        $ eq (--2.2) (0-2.2)
        $ eq (--45L) (0-45L)
        $ eq (--42.42D) (0-42.42D)

let succPred {eq} =
          eq (succ 1) 2
        $ eq (succ 12.2) 13.2
        $ eq (succ 12.22D) 13.22D
        $ eq (succ 'A') 'B'
        $ eq (succ (1,)) (2,)
        $ eq (pred 1) 0
        $ eq (pred 12.2) 11.2
        $ eq (pred 12.22D) 11.22D
        $ eq (pred 'B') 'A'
        $ eq (pred (1,)) (0,)

let assign {eq} =
          r.val <- 2
        $ eq r.val 2
        $ r.val <- r.val * 2
        $ eq r.val 4
        where r = {!val = 0}

let swap {eq} =
        let rec = {!x=1,!y=2,!z=3} in
        (
            rec.[0] <-> rec.[1]
            $ eq rec.[0] 2
            $ eq rec.[1] 1
        )