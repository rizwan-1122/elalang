#summary Ela overview, part 2.

== Introduction ==

If you are reading than you've probably decided to continue your acquaintance with Ela. I believe this is the time to download the latest binaries of Ela itself - you will need them during this part of Ela overview series.

Ela doesn't require installation, just extract it and copy the files to any folder you like. Ela distribution includes and Ela Console tool (_elac.exe_) that supports interactive mode. You can run it either under .NET Framework or Mono (in the latter case you have to put _mono_ ahead like: _mono.exe elac.exe_). 

If you don't specify a file name to execute Ela Console is lunched in an interactive mode. You should see the following banner (depending on the version of Ela and runtime environment):

{{{
Ela Interpreter version 0.8.0.0
Running CLR 2.0.50727.4952 64-bit

Interactive mode
Enter expressions and press <Return> to execute.
Press Ctrl+C to exit.

ela>
}}}

Interactive mode is a really neat thing which is very handy when you want to test some language constructs or debug your program. Just type Ela expressions and press `Return` key to execute them:

{{{
ela>"Hello, world!"

Hello, world!

ela>12 + 2 * 4

20

ela>(1,3) + (12,3)

(13,6)
}}}

But that is not the only cool thing.

With interactive mode you can compose your programs chunk by chunk. Ela interpreter "remembers" all the previous declarations you did:

{{{
ela>let x = 2

ela>let y = x + 2

ela>y

4
}}}

(As you can see you can simply check what value is bound to a particular name by typing this name and pressing `Return`).

While in interactive mode if you enter code that doesn't even compile you will see an error message (or several messages and warnings if you did something really bad) and of course this code is never executed:

{{{
ela>let z = x1 + 2

(1,9): Error ELA313: Undefined name 'x1'.
}}}

As a result the name `z` wasn't declared which you can double check by entering `z` in console:

{{{
ela>z

(1,1): Error ELA313: Undefined name 'z'.
}}}

However if you write code that fails at runtime like so

{{{
ela>let z = 12 / 0

(1,14): Error ELA803: Division by zero of value '12' of type 'int'.
        in <memory> at line: 1, col: 14
}}}

a name `z` actually gets declared - this is just initialization block that fails with an error. So we have a declared name which is not initialized - and that is not an allowed situation in Ela. In order to deal with this problem Ela Interactive initializes `z` with `unit` in such cases (if you don't understand what a unit is you can think of it as an Ela replacement for `null`).

(Small hint - enter `#clear` and hit `Return` if you want to clear the messages in console).

That is probably all you need to know about Ela interactive mode right now. Enough for the introduction, let's get started already.

== Data types ==

Ela comes with a collection of standard data types which includes boolean and unit types, four numeric types, linked lists that we've tested a little bit in a previous article, dynamic indexed arrays, tuples, strings, chars, tuples, records, variant data types and of course functions. We will reviews all these data types in this section.

=== Boolean type ===

Most of modern programming languages have a notion of a boolean data type (which is called `bool` in Ela) and Ela is not an exception here. Boolean type is pretty straitforward and values of these type can have only two values - either `true` or `false`.

You can create a boolean value using the literal form. Try the following in Ela Console:

{{{
ela>let b = true

ela>let b2 = false

ela>b

True

ela>b2

False
}}}

Ela doesn't allow implicit conversions between booleans and integers therefore the following code is not correct:

{{{
ela>let zero = 0

ela>if zero then "zero" else "not zero"

<memory>(1,1): Error ELA912: A value '' of type 'int' doesn't support trait 'Bool' (boolean operations).
        in memory at line: 1, col: 1
}}}

Boolean types support equality operations such as `==` (equals) and `<>` (not equals):

{{{
ela>b == b2

False

ela>b <> b2

True
}}}

As you can see from this example a result of equality operations is a value of a boolean type. Therefore we can change the erroneous code above like so:

{{{
ela>if zero == 0 then "zero" else "not zero"

zero
}}}

The result of comparison operations such as `>` (greater), `<` (lesser), `>=` (greater or equals) and `<=` (lesser or equals) is also a value of a boolean type however booleans itself don't support comparisons. Which is perfectly logical as soon as there is not much sense to test whether `true` is greater than `false` or vice versa.

Ela has a set of operations that are predefined for boolean types. First of all these are boolean and `&&` and boolean or `||` operators. They work exactly the same way as in C, C#, Java, etc. It is important to understand that these operators are lazy (which is also a typical behavior in other languages as well). Operator `&&` returns `true` if both operands are `true` and operator `||` returns `true` if at least one of its operands is `true`:

{{{
ela>if b && b2 then "Yes" else "No"

No

ela>if b || b2 then "Yes" else "No"

Yes
}}}

"Lazy" here means that these operators are executed like so:

{{{
ela>if b then (if b2 then "Yes" else "No") else "No"

No

ela>if b then "Yes" else if b2 then "Yes" else "No"

Yes
}}}

As soon as `&&` yields `true` if both operands are `true` there is no need to evaluate both operands if we see that the first doesn't satisfy the condition. The same for `||`. If we see that the first operand satisfies the condition there is no need to evaluate the second operand as soon as it won't affect the result. It may come up pretty handy because you can use not just variable reference as operands but also much more complex expressions, costy function calls, etc.

The last thing to mention about boolean operators is that unlike many other operators in Ela these two are not functions but just special forms therefore if you try to use them as function you will have a compile time error. This is because Ela is a language with strict evaluation and it is not possible to implement a function with two parameters that will evaluate the second parameter only if it is needed. 

=== Unit type ===

Unit is somewhat similar to the notion of _void_ from C style languages. It is different in certain aspects however. In Ela `unit` is a real data type and you can create a value of this type. This is a first class value in a sense that you can pass it as an argument to a function, return it from a function, add it as an element to array, etc. Unit even has it own literal in Ela. This is how you can create a value of type `unit`:

{{{
ela>let u = ()
}}}

Unit is an immutable data type - you cannot change it in place like you do with an array (and there is nothing to change really). Because of this there is only one global instance of `unit`. If you create two values of type `unit` and try to test them for equality this will always evaluate to `true`:

{{{
ela>let u2 = ()

ela>u == u2

True
}}}

Actually equality operators `==` and `<>` are the only two operators that are supported by `unit`. You are probably wondering what is the purpose of this data type which at the first glanse cannot do anything useful.

The real application for `unit` is when there is no other meaningful value. Let's say that you want to implement a function just for the sake of the side effect. This is perfectly valid in Ela as soon as Ela is not a pure functional language. This function take take another function, a list and apply a given function to all elements of the list. This hypothetical function will also ignore a value that is returned by the supplied function. This is how we can implement it:

{{{
let each f x::xs = f x $ each f xs;
         _ []    = ()
}}} 

I hope that this definition is clear for you. 

As you can see we have defined this function by pattern matching as we did with `sum` and `filter` functions in the previous article. We pattern match against a linked list. The `$` operator in the first entry is a sequencing operator which is pretty similar to `;` in C. It simply says - evaluate the first expression, _ignore_ its return value and return the result of the second expression. And that is exactly what we need here. The second entry `_ [] = ()` matches against an empty list and returns `unit` as soon as we have to return something but there is nothing else except unit that we can return here.

Another good example is a function that doesn't accept any arguments. As you know you cannot really declare one in Ela. However in certain cases when writing code with side effects you might need it. And this is how you can use `unit` to accomplish this task:

{{{
let nonsense () = ()
}}}

Here we have a `nonsense` function that accepts one argument of type `unit` and returns `unit`. This function is defined by pattern matching. As you remember from previous article with pattern matching you can use literal forms not only to create objects but to match against them as well. And that is exactly what we see here. A pattern `()` is used to match against a value of type `unit`. If you try to pass a value of other type a match will fail. This is how you can legally call this `nonsense` function:

{{{
ela>nonsense ()

ela>nonsense u

ela>nonsense u2
}}}

And this is an illegal call:

{{{
ela>nonsense 0

<memory>(1,5): Error ELA809: Match failed. None of the patterns were successful.
        in memory.nonsense at line: 1, col: 5
        in memory at line: 1, col: 1
}}}

In other words we haven't tricked anyone here. We have created a function that accepts one argument and it truly does however by using `unit` we simply say that we don't really need anything meaningful with this argument and we are perfectly OK to accept a unit. What you see here is just a convention of representing functions without arguments. Of course you can do it differently like so:

{{{
let nonsense2 _ = ()
}}}

Here we used a "throw away" pattern which which we also have acquainted before. It might seem as a good alternative but in reality it is not because you will be to apply this function to a value of any type which is quite misleading:

{{{
ela>nonsense2 u

ela>nonsense2 0

ela>nonsense2 "Hello, world!"
}}}

In the conslusion of this section I should that it is important to understand here that unlike many other languages Ela doesn't have a notion of `null`. That is because Ela is a dynamically typed language and the type is not associated with variable but with the value itself. In other words it is not correct to say that in the code like `let u = ()` we have a variable `u` of type `unit`. In reality what we have here is a value of type `unit` which is bound to the name `u`. As a result you cannot declare a variable of type, say, array and assign it to a `null` like you do in C# or similar languages. The `unit` type might seem as something similar to the `null` which might be used as its replacement however `unit` is not `null` and is not here to serve the same purposes as `null`. You can use it only when no other value is applicable. That is it. And it is a typical case for the functions with side effects when in C# you will have a procedure that returns void or accepts zero arguments. Ela doesn't have `null` and it doesn't need `null`. Also Ela doesn't have a lot of problems connected with `null` such as annoying "null reference" exceptions. If you used `null` in functions that could return something or nothing there is a much better way to do the same thing in Ela - polymorphic variants. Don't worry, we'll deal with them a little bit later.

=== Numeric types ===

Ela has four built-in numeric types - signed 32-bit integers (`int`), signed 64-bit integers (`long`), single precision floating point numbers (`single`) and double precision floating point numbers (`double`). (As a remark that you might find useful - all these types are directly mapped to .NET data types: System.Int32, System.Int64, System.Single and System.Double).

This is how you create values of these types:

{{{
ela>let int = 42

ela>let long = 42L

ela>let single = 1.42

ela>let double = 1.42D
}}}

You have probably noticed the postfixes `L` and `D`. A postfix `L` is used to denote that you need a value of type `long` and `D` that you need `double`, not just `single` which is used by default.

Numeric types are somewhat different from other data types. That is the place where Ela type system is not too strict for the sake of convinience and does support some implicit conversions from one type to another. The rules for implicit conversions are pretty straigtforward. In other to better undestand them I will put all the numeric types in order like so:

  # int
  # long
  # single
  # double

And that is what happens - `int` can be implicitly converted to `long`, `single` and `double`, `long` - only to `single` and `double`, `single` - just to `double` and life is not fair to `double`, it cannot be converted to any other numeric type at all. That is because this "conversion chain" doesn't work backwards - `long` is never implicitly converted to `int`, `single` - to `long`, etc.

Here is a small example of how implicit conversions work:

{{{
ela>12 + 24.2

36.2

ela>25 / 12

2

ela>25D / 12

2.08333333333333

ela>4.3 * 120

516
}}}

As you can see numeric types support all basic arithmetic operations including addition `+`, substraction `-`, multiplication `*`, division `\`, modulus `%`, power `**` and negation which is written `--` unlike many other languages where negation uses the same identifer as binary minus. These operators has the same priority as in C style languages. Power and modulus operators has the same priority as multiplication and division:

{{{
ela>14 % 5

4

ela>3 ** 3

27

ela>2 + 4 ** 3

66

ela>12 - 40 % 3

11

ela>155 * 20 / 2

1550
}}}

A couple of other samples to illustrate negation operation:

{{{
ela>-42 //This is not a valid syntax in Ela

<memory>(1,1): Error ELA210: Invalid syntax.

ela>(-42) //This is a partial application of a '-' function

<f>:*->*

ela>--42 //Finally, a correct negation syntax

-42
}}}

Types `int` and `long` also support bitwise operations such as bitwise and `&&&`, bitwise or `|||`, bitwise xor `^^^`, left shift `<<<`, right shift `>>>` and bitwise not `~~~`. These have the same behavior as operators `&`, `|`, `^`, `<<`, `>>` and `~` in C however their priority is different. Bitwise or, and and xor have one of the highest priorities among Ela operators:

{{{
ela>let sn = 48 ||| (134 <<< 8)

ela>sn

34352

ela>sn >>> 8

134

ela>sn &&& 255

48
}}}

Numeric types also support a bunch of other operations. They can be tested for equality using operators `==` and `<>`, compared using operators `>`, `<`, `>=` and `<=`. They also support operations successor and predecessor (`succ` and `pred`) and taking a minimum and a maximum value (`min` and `max`):

{{{
ela>succ 42

43

ela>pred 42

41

ela>max 1

2147483647

ela>max 1L

9223372036854775807

ela>min 1L

-9223372036854775808

ela>max 1D

1.79769313486232E+308
}}}

The functions `succ`, `pred`, `max` and `min` are built-in Ela functions. Besides the fact that they are built-in they are just like any other regular functions - you can assign them to variables, pass as arguments to other functions, etc.

Ela like some other languages doesn't perform overflow check so you should be careful with your calculations. Here is simple example of factorial calculation that overflows:

{{{
ela>let factorial 0 = 1; n = n * factorial (n - 1) //naive implementation of factorial function

ela>factorial 13 //works OK

1932053504

ela>factorial 20 //overflows

-2102132736
}}}

=== Strings and char ===

Strings and chars are yet another couple of data types that are well known by other programming languages. 

Strings in Ela are unicode sequences of characters. In the current implementation they do map directly to the .NET Framework data type System.String. This is how you can create a string in Ela:

{{{
ela>let str = "Hello, world!"

ela>str

Hello, world!
}}}

Strings in Ela (as well as chars) support C style escape codes. For example this is how you can create a two line string with double quotes:

{{{
ela>let str2 = "Hello,\r\n\"Basil\""

ela>str2

Hello,
"Basil"
}}}

Also strings are immutable - you cannot change them in-place.

Unlike many programming languages strings in Ela doesn't support `+` operator. This one is reserved in Ela only for arithmetic. You can use another polymorphic operator `++` which is called a _concatenation operator_ if you want to concatenate strings:

{{{
ela>str ++ "\r\n" ++ str2

Hello, world!
Hello,
"Basil"
}}}

As soon as strings are immutable concatenation operation creates a new string. Also this operation doesn't perform implicit type casts - its both operands should be strings otherwise a runtime error will be raised.

You can test strings for equality and compare them using comparison operator:

{{{
ela>str == str2

False

ela>str > str2

False

ela>str <= str2

True
}}}

You can also use built-in `length` function to calculate string length:

{{{
ela>let str = "Hello, world!"

ela>length str

13
}}} 

You can use an indexing operator to obtain a char by a given offset like so:

{{{
ela>str.[0]

H

ela>str.[12]

!
}}}

Indexing operator in Ela is pretty similar to that in C# with the only exception that it uses a extra dot before the square braces. If you already get used to the indexer in the form `newList[2]` it is really important to remember that this dot is required. This is because `newList[2]` is also a valid syntax in Ela but has a completely different meaning. As you remember Ela uses a simple juxtaposition for a function call, e.g. `x y` in Ela means that we apply an `x` function to the `y` argument. The same thing happens with `newList[2]` expression which is understood by Ela as: apply a function `newList` to the expression `[2]` which in turn creates a list with a single element.

As it was mentioned above indexing operator when applied to a string return a value of type `char`. Char is a pretty basic data type that is used to represent a single unicode character. It also has its own literal in Ela similar to the one that is used in C style languages:

{{{
ela>let c = 'H'

ela>c

H
}}}

Chars as well as string can be tested for equality and compared. Also chars support built-in 'succ' and 'pred' functions:

{{{
ela>succ 'a'

b

ela>pred 'b'

a
}}}

These are basically all the things that you can do with chars. Unlike some other languages chars in Ela are not numeric types and cannot be implicitly converted to numeric types. Therefore code like `'a' + 'b'` is errorneous in Ela and won't work. You will have to explicitly convert chars to integers in order to fix it: `'a':int + 'b':int`.

=== Lists ===

List is one of the fundamental types in Ela. Lists in Ela are _single linked lists_. In a case if you haven't heard of such data structure before you can check it out in [http://en.wikipedia.org/wiki/List_(computing) Wikipedia]. 

In short single linked list in an ordered sequence of elements where each element holds a reference to the next element. The very last item in a list points to a thing that is called a _nil list_, which is nothing more than an empty list.

All elements of the linked list are also lists. Basically a single linked list can be seen as a very straightforward data structure that wrappes some value and a reference to the next element. If have you ever coded in such language as C# this is how a minimalistic linked list can be implemented in this language:

{{{
class LinkedList<T>
{
  public static readonly LinkedList Nil = new LinkedList();

  private LinkedList() { }

  public LinkedList(T value, LinkedList next)
  {
    Value = value;
    Next = next;
  }

  public LinkedList Next { get; private set; }
  public T Value { get; private set; }
}
}}}

That is really it. As soon as list in an immutable data structure - you cannot change it in place like you do with an array - an empty (_nil_) list is represented as a "global" value. You don't have to create it "on demand" as soon as it never gets change and therefore can be initialized just once and used everywhere. As a result when you create an empty list in Ela nothing is actually gets created - you just reference this special global _nil_ variable. This is how you can do it:

{{{
let lst = []
}}}

A `[]` is a special literal form that is used to denote an empty list.

If you need to create a list with just one element - e.g. an integer `42` - you basically have to initialize this simple linked list structure and to pass `42` as its value and a `nil` list as an element sitting nearby. This is how you can do it in C# using the `LinkedList` class that we've just created:

{{{
var lst = new LinkedList(42, LinkedList.Nil);
}}}

The same for the list with two elements:

{{{
var lst = new LinkedList(43, new LinkedList(42, LinkedList.Nil));
}}}

As you can see it looks quite cumbersome. That is why Ela has a special operator `::` that can be used to construct list. Let's try it in console:

{{{
>let lst = 43::(42::[])

[43,42]
}}}

An operator `::` is called a list construction operator and it is right associative. It means that can omit braces from the previous sample and get exactly the same result:

{{{
>let lst2 = 43::42::[]

[43,42]
}}}

There is also a syntax sugar for this operator - as soon as it is still not visual enough for list construction - a special literal form of the list. The code above can also be written like so:

{{{
let lst2 = [43, 42]
}}}

Another useful operator that can be used with lists is a _list concatenation operator_. This is how you can use it:

{{{
>lst ++ lst2

[43, 42, 43, 42]
}}}

A `++` operator can be used to concatenate two lists, you can't use it to append an element to a list. Actually because of the way how linked lists are organized there is no direct way to append an element to the end of the list - only to the head. If you desperately need it however this is how you can accomplish this:

{{{
>lst ++ [41]

[43, 42, 41]
}}}

(However bear in mind that this a very ineffecient operation - not only in Ela but in all languages that support lists and a similar set of operators).

Here we actually create a new list that contains a single element, number `41`, and then concatenate the two lists.

As soon as every list element holds a reference to the next element lists come up very handy when you need to iterate over their elements. In other words each item in a list basically know what it's neigbor is and it renders looping through the list as a pretty trivial task.

However Ela is a functional language and it doesn't even have a concept of iterators that you might've heard of in such languages as C#. In Ela one should use recursion instead of cycles. And that is again the place where _pattern matching_ becomes really helpful. As you remember from the previous article pattern matching allows us to deconstruct an element using its literal syntax which is in a case of linked lists a construction operator `::`. That is a simple example of how you can iterate over list elements:

{{{
ela>let iter f x::xs = f x $ iter f xs; _ []    = ()
}}}

This function is basically an alternative to impertive cycle and you can use it like so (the following example prints all list elements to console):

{{{
ela>iter cout [1,2,3,4,5]

1
2
3
4
5
}}}

You've already seen a similar trick in functions from the previous article. Lists and pattern matching against list is widely used in Ela code. As you remember a pattern in the form `x::xs` matches against a list that has at least one element. If a list really contains just a single item `xs` gets bound the `nil`. Usually in expressions like the one above we call `x` a _head_ of the list and `xs` a list tail. 

The list deconstruction pattern can contain an arbitrary number of elements. You can use both variables and actual values in it, e.g. the following patterns are perfectly legal: `1::2::xs`, `x::(2,3)::xs`, `x::(y::ys)::xs`, `x::y::[]`. I will explain how this thing works with more detail in the chapter about pattern matching. 

The last pattern `x::y::[]` is used to match a list that has _exactly_ two elements. We basically say here that we want a list tail to match a nil list. It is useful when you want to ensure that a given list has an exact number of items. As with construction syntax there is an alternate more readable form to write this - `[x,y]` which is fully equivavlent to `x::y::[]`.

Another example of how you write a function that iterates over list elements using recursion and pattern matching:

{{{
ela>let length' _::xs = 1 + length' xs; [] = 0

ela>length' [1,2,3,4,5]

5
}}}

The function above can be used to calculate the length of a list. It is not a very effective implementation but it works OK as an example. We again deconstruct a list using recursion until we actually reach the `nil` list. This function is executed as a chain of additions - because of this we don't have to declare mutable variables. The result of this function when the given list is a not a nil list is always `1` plus the length of the rest list, list tail.

Of course you don't have to code `length` function each time you need it. Ela already has a built-in polymorphic `length` function that you can with any list:

{{{
ela>length [1,2,3,4,5]

5
}}}

Another useful operation that is available for lists is an ability to obtain a list element by its index. This is done using indexing syntax like so:

{{{
ela>let newList = [0,1,2,3,4]

ela>newList.[2]
}}}

You should also remember that accessing list elements by index is not a very effective operation. We have to iterate through the whole list and count each iteration - that is really the only way to do that. If you need to access elements by index frequently you might consider to use a different data structure instead - e.g. _array_ which has a constant access time.

=== Arrays ===

Arrays in Ela are pretty similar to such type as `ArrayList` in .NET Framework. These are basically dynamic indexed polymorphic arrays. This is how you can create one:

{{{
ela>let arr = [|1,2,3,4,5|]

ela>arr

[|1,2,3,4,5|]
}}}

Arrays also support indexing operator and you can a built-in `length` function to calculate their length:

{{{
ela>arr.[4]

5

ela>arr.[1+2]

4

ela>length arr

5
}}}

Besides this array support a set of specific function that allows to perform its modification in-place. These are functions `add`, `removeAt`, `insert` and `clear`. These functions are exposes as array fields. Field access in Ela is pretty similar to that one in C style languages:

{{{
ela>arr.insert

<f>:*->*->*
}}}

Function `add` accepts a single arguments, appends it to the end of the list and returns `unit`:

{{{
ela>arr.add 6

ela>arr

[|1,2,3,4,5,6|]
}}}

Function `insert` allows you to insert elements into the list at a given position. The first argument is a zero based position, the second argument is a value to insert and the return value is unit:

{{{
ela>arr.insert 1 100

ela>arr

[|1,100,2,3,4,5,6|]
}}}

Function `removeAt` removes an element from a given position. It takes a position index and returns unit:

{{{
ela>arr.removeAt 1

ela>arr

[|1,2,3,4,5,6|]
}}}

And `clear` function just allows to remove all elements from the list:

{{{
ela>arr.clear ()

ela>arr

[||]
}}}

That is basically all that you should know about arrays.

=== Tuples ===

Tuples are yet another fundamental data type in Ela. Well, probably not that fundametal as a list but still pretty important. Tuples are grouped sequence of elements. You can access each element of a tuple using an indexer syntax and this operation is as effecient as with arrays, however unlike arrays tuples are immutable - you cannot change them in place, append or remove items, etc.

This is how you can create a tuple in Ela:

{{{
ela>let t = (1,2,3)

ela>let t1 = (1,)

ela>t1

(1,)

ela>t

(1,2,3)
}}}

Tuple literal is pretty straitforward - you just list a sequence of elements separated by comma and enclose them in parentheses. However a single expression in parentheses like `(1)` doesn't create a tuple. As soon as parentheses are used as a grouping construct in the same manner as in C style languages the expression `(1)` is completely equivalent to just `1` (but of course `1 + 2 * 3` is pretty different from `(1 + 2) * 3` exactly like in C). If you want to create a tuple with just one element you can put a trailing comma like in the example above: `(1,)`.

You can pattern match tuples using tuple literal syntax, i.e.:

{{{
ela>match t with (1,2,x) = x end

3

ela>let (y,) = t1

ela>y

1
}}}

Tuples are really useful in certain cases. For example with tuples and pattern matching you can initialize multiple variables with a single expression like so:

{{{
ela>let (x1, y1, z1) = (1, "Hello, world", 42.12)

ela>x1

1

ela>y1

Hello, world

ela>z1

42.12
}}}

You can return multiple values from a function:

{{{
ela>let divMod x y = (x / y, x % y)

ela>divMod 43 12

(3,7)
}}}

In the example above I have created a function that accepts two arguments, divides first of them by second and returns the integral part of the division result and the remainder.

You can also use tuples to pass grouped arguments to a function:

{{{
ela>let sumTup (x, y) = x + y

ela>sumTup (1, 3)

4
}}}

Here we have created a function that actually accepts just one argument. This function pattern match this argument and binds the first element of a tuple to `x` and the second - to `y`. This function might look as if it accepts two arguments not just one if you have programmed in C style languages before that use such a convention for function declaration and call however this is not the case in Ela:

{{{
ela>sumTup 1 4

<memory>(1,5): Error ELA809: Match failed. None of the patterns were successful.
        in memory.sumTup at line: 1, col: 5
        in memory at line: 1, col: 1
}}}

You can think that `sumTup` declaration is equivalent to the following:

{{{
ela>let sumTup2 t = t.[0] + t.[1]
}}}

However it is not. We can see why in a simple test:

{{{
ela>sumTup2 t

3

ela>sumTup t

<memory>(1,5): Error ELA809: Match failed. None of the patterns were successful.
        in memory.sumTup at line: 1, col: 5
        in memory at line: 1, col: 1
}}}

As you remember `t` is a tuple with three elements that we have declared before. The `sumTup2` function works without errors - it doesn't care how long our tuple is and will accept a tuple with three, thirty three or just one argument. In the latter case it will fail with a runtime error while trying to obtain a non-existent element, in other cases it will simply ignore all tuple elements except of the first two. Sometimes this is not the behavior that actually need.

And here comes our original `sumTup` function. As you can see it doesn't really want to accept a three element tuple. That is because a three element tuple doesn't match the pattern in the function declaration where we have explicitly specified that we want a pair of elements, not a triple. This is how we can make it work:

{{{
ela>let t2 = (12, 24)

ela>sumTup t2

36
}}}

Another interesting pecularity of tuples is that unlike arrays tuples are always flat. In other words you cannot create a tuple that has other tuples as its elements. If you need something like that you should probably stick with lists or arrays. With tuples the hierarchy will be always flattened:

{{{
ela>(1,(2,3,(4,5)),6)

(1,2,3,4,5,6)
}}}

You can use the built-in `length` function to calculate the length of tuples:

{{{
ela>length t

3

ela>length t2

2
}}}

Length calculation is a pretty efficient operation with tuples - pretty much like with arrays. Tuples don't have any built-in fields like arrays however they might be a much more powerful data structure in certain cases.

A cool thing about tuples is that they support a lot of standard operators including comparison operators, arithmetic operators, bitwise, `succ` and `pred` functions and event concatenation operator. How all these things works with tuples? Let's take a look:

{{{
ela>(1, 2) == (1, 2)

True

ela>(1, 2) < (3, 4)

True

ela>succ (1, 2)

(2,3)

ela>(12, 5.5) + (1, 4.32)

(13,9.82)

ela>(4, 8) * (1, 2)

(4,16)
}}}

=== Records ===

The first thing you should know about records is that records _are_ tuples. They really are just special versions of tuples and everything from the previous section is true for records as well. You can think of records as extensions to tuples that basically adds two things:

  # Access elements by names. With tuples you can only access an element by index when record allows you to give an alias to a particular element and to access this element using a given alias which might be more convinient in some cases.
  # Mutability. Records are immutable by default but you can make them mutable if you need to do so (which cannot be achived with tuples)

Records in Ela are created like so:

{{{
ela>let r = {x = 1, y = 2 }

ela>r

{x=1,y=2}
}}}

You can access elements of records using either their index or name. The latter one has a C style syntax:

{{{
ela>r.[1]

2

ela>r.y

2
}}}

You can also declare a tuple with field names that are not valid Ela identifiers (i.e. contain special characters or spaces):

{{{
ela>let style = {"text-decoration" = "underline"}

ela>style

{text-decoration=underline}
}}}

In this case you will have to use indexer syntax to access a tuple element however you can still specify an element name through an indexer like so:

{{{
ela>r.["x"]

1

ela>style.["text-decoration"]

underline
}}}

It is important to understand that tuples in Ela are not hash tables. They are associative arrays. All elements are stored in order and you can even pattern match a record using tuple pattern:

{{{
ela>sumTup r

3
}}}