#summary Ela overview 2. Data types

== Introduction ==

If you are reading this introduction than you've probably decided to continue your acquaintance with Ela. I believe this is the time to download the latest binaries of Ela itself - you will need them during this part of Ela overview series.

Ela doesn't require installation, just extract it and copy the files to any folder you like. Ela distribution includes Ela itself (_ela.dll_) and Ela Console tool (_elac.exe_) that supports interactive mode. You can run it either under .NET Framework or Mono (in the latter case you have to put _mono_ ahead like so: _mono.exe elac.exe_). 

If you don't specify a file name to execute, Ela Console is lunched in an interactive mode. You should see the following banner (depending on the Ela version and runtime environment):

{{{
Ela Interpreter version 0.8.1.0
Running CLR 2.0.50727.4952 64-bit

Interactive mode
Enter expressions and press <Return> to execute.
Press Ctrl+C to exit.

ela>
}}}

Interactive mode is a really neat thing which is very handy when you want to test some language constructs or debug your programs. Just type Ela expressions and press `Return` key to execute them:

{{{
ela>"Hello, world!"

Hello, world!

ela>12 + 2 * 4

20

ela>(1,3) + (12,3)

(13,6)
}}}

But that is not the only cool thing.

With interactive mode you can compose your programs chunk by chunk. Ela interpreter "remembers" all the previous declarations you did:

{{{
ela>let x = 2

ela>let y = x + 2

ela>y

4
}}}

(As you can see you can simply check what value is bound to a particular name by typing this name and pressing `Return`).

While in interactive mode if you enter code that doesn't even compile you will see an error message (or several messages and warnings if you did something really bad) and of course such code is never executed:

{{{
ela>let z = x1 + 2

(1,9): Error ELA313: Undefined name 'x1'.
}}}

As a result the name `z` wasn't declared which you can double check by entering `z` in console:

{{{
ela>z

(1,1): Error ELA313: Undefined name 'z'.
}}}

However if you write code that fails at runtime like so

{{{
ela>let z = 12 / 0

(1,14): Error ELA803: Division by zero of value '12' of type 'int'.
        in <memory> at line: 1, col: 14
}}}

a name `z` actually gets declared - this is just initialization block that fails with an error. So we have a declared name which is not initialized - and that is not an allowed situation in Ela. In order to deal with this problem Ela Interactive initializes `z` with `unit` in such cases (if you don't understand what is unit is you can think of it as an Ela replacement for `void`).

(Small hint - enter `#clear` and hit `Return` if you want to clear the messages in console).

That is probably all you need to know about Ela interactive mode right now. Enough for the introduction, let's get started already.

== Data types ==

Ela comes with a wide collection of built-in data types. The basic types includes boolean and unit types, four numeric types, linked lists that we've tested a little bit in a previous article, dynamic indexed arrays, strings, chars, tuples, records, variant data types and of course functions. We will reviews all these data types in this section.

=== Boolean type ===

Most of modern programming languages have a notion of a boolean data type (which is called `bool` in Ela) and Ela is not an exception here. Boolean type is pretty straitforward and instances of these type can be either `true` or `false`- and no third option.

You can create a boolean value using the literal form. Try the following in Ela Console:

{{{
ela>let b = true

ela>let b2 = false

ela>b

True

ela>b2

False
}}}

Ela doesn't allow implicit conversions between booleans and integers therefore the following code is not correct:

{{{
ela>let zero = 0

ela>if zero then "zero" else "not zero"

<memory>(1,1): Error ELA912: A value '' of type 'int' doesn't support trait 'Bool' (boolean operations).
        in memory at line: 1, col: 1
}}}

Boolean types support equality operations such as `==` (equals) and `<>` (not equals):

{{{
ela>b == b2

False

ela>b <> b2

True
}}}

As you can see from this example a result of equality operations is a value of a boolean type. Therefore we can change the erroneous code above like so:

{{{
ela>if zero == 0 then "zero" else "not zero"

zero
}}}

The result of comparison operations such as `>` (greater), `<` (lesser), `>=` (greater or equals) and `<=` (lesser or equals) is also a value of a boolean type however booleans itself don't support comparisons. Which is perfectly logical as soon as there is not much sense to test whether `true` is greater than `false` or vice versa.

Ela has a set of operations that are predefined for boolean types. First of all these are _boolean and_ (`&&`) and _boolean or_ (`||`) operators. They work exactly the same way as in C, C#, Java, etc. It is important to understand that these operators are lazy (which is also a typical behavior in other languages as well). Operator `&&` returns `true` if both operands are `true` and operator `||` returns `true` if at least one of its operands is `true`:

{{{
ela>if b && b2 then "Yes" else "No"

No

ela>if b || b2 then "Yes" else "No"

Yes
}}}

"Lazy" here means that these operators are executed like so:

{{{
ela>if b then (if b2 then "Yes" else "No") else "No"

No

ela>if b then "Yes" else if b2 then "Yes" else "No"

Yes
}}}

As soon as `&&` yields `true` if both operands are `true` there is no need to evaluate both operands if we see that the first doesn't satisfy the condition. The same for `||`. If we see that the first operand satisfies the condition there is no need to evaluate the second operand as soon as it won't affect the result. It may come up pretty handy because you can use not just variable reference as operands but also much more complex expressions, costy function calls, etc.

The last thing to mention about boolean operators is that unlike many other operators in Ela these two are not functions but just special forms therefore if you try to use them as function you will have a compile time error. This is because Ela is a language with strict evaluation and it is not possible to implement a function with two parameters that will evaluate the second parameter only if it is needed. 

=== Unit type ===

Unit is somewhat similar to the notion of _void_ from C style languages. It is different in certain aspects however. In Ela `unit` is a real data type and you can create a value of this type. This is a first class value in a sense that you can pass it as an argument to a function, return it from a function, add it as an element to array, etc. Unit even has it own literal in Ela. This is how you can create a value of type `unit`:

{{{
ela>let u = ()
}}}

Unit is an immutable data type - you cannot change it in place like you do with an array (and there is nothing to change really). Because of this there is only one global instance of `unit`. If you create two values of type `unit` and try to test them for equality this will always evaluate to `true`:

{{{
ela>let u2 = ()

ela>u == u2

True
}}}

Actually equality operators `==` and `<>` are the only two operators that are supported by `unit`. You are probably wondering what is the purpose of this data type which at the first glance cannot do anything useful.

The real application for `unit` is when there is no other meaningful value. Let's say that you want to implement a function just for the sake of the side effect. This is perfectly valid in Ela as soon as Ela is not a pure functional language. This function accepts another function, a list and applies a given function to all elements of the list. This hypothetical function will also ignore a value that is returned by the supplied function. This is how we can implement it:

{{{
let each f x::xs = f x $ each f xs;
         _ []    = ()
}}} 

I hope that this definition is clear for you. 

As you can see we have defined this function by pattern matching as we did with `sum` and `filter` functions in the previous article. We pattern match against a linked list. The `$` operator in the first entry is a sequencing operator which is pretty similar to `;` in C. It simply says - evaluate the first expression, _ignore_ its return value and return the result of the second expression. And that is exactly what we need here. The second entry `_ [] = ()` matches against an empty list and returns `unit` as soon as we have to return something but there is nothing else except unit that we can return here.

Another good example is a function that doesn't accept any arguments. As you know you cannot really declare one in Ela. However in certain cases when writing code with side effects you might need it. And this is how you can use `unit` to accomplish this task:

{{{
let nonsense () = ()
}}}

Here we have a `nonsense` function that accepts one argument of type `unit` and returns `unit`. This function is defined by pattern matching. As you remember from previous article with pattern matching you can use literal forms not only to create objects but to match against them as well. And that is exactly what we see here. A pattern `()` is used to match against a value of type `unit`. If you try to pass a value of other type a match will fail. This is how you can legally call this `nonsense` function:

{{{
ela>nonsense ()

ela>nonsense u

ela>nonsense u2
}}}

And this is an illegal call:

{{{
ela>nonsense 0

<memory>(1,5): Error ELA809: Match failed. None of the patterns were successful.
        in memory.nonsense at line: 1, col: 5
        in memory at line: 1, col: 1
}}}

In other words we haven't tricked anyone here. We have created a function that accepts one argument and it truly does however by using `unit` we simply say that we don't really need anything meaningful with this argument and we are perfectly OK to accept a unit. What you see here is just a convention of representing functions without arguments. Of course you can do it differently like so:

{{{
let nonsense2 _ = ()
}}}

Here we used a "throw away" pattern which we also have seen before. It might seem as a good alternative but in reality it is not because you will be able to apply this function to a value of any type which is quite misleading:

{{{
ela>nonsense2 u

ela>nonsense2 0

ela>nonsense2 "Hello, world!"
}}}

In the conclusion of this section I should say that it is important to understand here that unlike many other languages Ela doesn't have a notion of `null`. That is because Ela is a dynamically typed language and the type is not associated with variable but with the value itself. In other words it is not correct to say that in the code like `let u = ()` we have a variable `u` of type `unit`. In reality what we have here is a value of type `unit` which is bound to the name `u`. As a result you cannot declare a variable of type, say, array and assign it to a `null` like you do in C# or similar languages. The `unit` type might seem as something similar to the `null` which might be used as its replacement however `unit` is not `null` and is not here to serve the same purposes as `null`. You can use it only when no other value is applicable. That is it. And it is a typical case for the functions with side effects when in C# you will have a procedure that returns void or accepts zero arguments. Ela doesn't have `null` and it doesn't need `null`. Also Ela doesn't have a lot of problems connected with `null` such as annoying "null reference" exceptions. If you used `null` in functions as a return value to denote that there is "nothing" we can return please bear in mind: a much better way to do the same thing exists in Ela, polymorphic variants. Don't worry, we'll deal with them a little bit later.

=== Numeric types ===

Ela has four built-in numeric types - signed 32-bit integers (`int`), signed 64-bit integers (`long`), single precision floating point numbers (`single`) and double precision floating point numbers (`double`). (As a remark that you might find useful - all these types are directly mapped to .NET data types: System.Int32, System.Int64, System.Single and System.Double).

This is how you create values of these types:

{{{
ela>let int = 42

ela>let long = 42L

ela>let single = 1.42

ela>let double = 1.42D
}}}

You have probably noticed the postfixes `L` and `D`. A postfix `L` is used to denote that you need a value of type `long` and `D` - that you need `double`, not just `single` which is used by default.

Numeric types are somewhat different from other data types. That is the place where Ela type system is not too strict for the sake of convinience and does support some implicit conversions from one type to another. The rules for implicit conversions are pretty straigtforward. In other to better undestand them I will put all the numeric types in order like so:

  # int
  # long
  # single
  # double

And that is what happens - `int` can be implicitly converted to `long`, `single` and `double`, `long` - only to `single` and `double`, `single` - just to `double` and life is not fair to `double`, it cannot be converted to any other numeric type at all. That is because this "conversion chain" doesn't work backwards - `long` is never implicitly converted to `int`, `single` - to `long`, etc.

Here is a small example of how implicit conversions work:

{{{
ela>12 + 24.2

36.2

ela>25 / 12

2

ela>25D / 12

2.08333333333333

ela>4.3 * 120

516
}}}

As you can see numeric types support all basic arithmetic operations including addition `+`, substraction `-`, multiplication `*`, division `\`, modulus `%`, power `**` and negation which is written `--` unlike many other languages where negation uses the same identifer as binary minus. These operators has the same priority as in C style languages. Power and modulus operators has the same priority as multiplication and division:

{{{
ela>14 % 5

4

ela>3 ** 3

27

ela>2 + 4 ** 3

66

ela>12 - 40 % 3

11

ela>155 * 20 / 2

1550
}}}

A couple of other samples to illustrate negation operation:

{{{
ela>-42 //This is not a valid syntax in Ela

<memory>(1,1): Error ELA210: Invalid syntax.

ela>(-42) //This is a partial application of a '-' function

<f>:*->*

ela>--42 //Finally, a correct negation syntax

-42
}}}

Types `int` and `long` also support bitwise operations such as _bitwise and_ (`&&&`), _bitwise or_ (`|||`), _bitwise xor_ (`^^^`), _left shift_ (`<<<`), _right shift_ (`>>>`) and _bitwise not_ (`~~~`). These have the same behavior as operators `&`, `|`, `^`, `<<`, `>>` and `~` in C however their priority is different. Operators `&&&`, `|||` and `^^^` have one of the highest priorities among Ela operators:

{{{
ela>let sn = 48 ||| (134 <<< 8)

ela>sn

34352

ela>sn >>> 8

134

ela>sn &&& 255

48
}}}

Numeric types also support a bunch of other operations. They can be tested for equality using operators `==` and `<>`, compared using operators `>`, `<`, `>=` and `<=`. They also support operations successor and predecessor (`succ` and `pred`) and taking a minimum and a maximum value (`min` and `max`):

{{{
ela>succ 42

43

ela>pred 42

41

ela>max 1

2147483647

ela>max 1L

9223372036854775807

ela>min 1L

-9223372036854775808

ela>max 1D

1.79769313486232E+308
}}}

The functions `succ`, `pred`, `max` and `min` are built-in Ela functions. Besides the fact that they are built-in they are just like any other regular functions - you can assign them to variables, pass as arguments to other functions, etc.

Ela like some other languages doesn't perform overflow check so you should be careful with your calculations. Here is simple example of factorial calculation that overflows:

{{{
ela>let factorial 0 = 1; n = n * factorial (n - 1) //naive implementation of factorial function

ela>factorial 13 //works OK

1932053504

ela>factorial 20 //overflows

-2102132736
}}}

=== Strings and char ===

Strings and chars are yet another couple of data types that should be well known from other programming languages. 

Strings in Ela are unicode sequences of characters. In the current implementation they do map directly to the .NET Framework data type System.String. This is how you can create a string in Ela:

{{{
ela>let str = "Hello, world!"

ela>str

Hello, world!
}}}

Strings in Ela (as well as chars) support C style escape codes. For example this is how you can create a two line string with double quotes:

{{{
ela>let str2 = "Hello,\r\n\"Basil\""

ela>str2

Hello,
"Basil"
}}}

Also strings are immutable - you cannot change them in-place.

Unlike many programming languages strings in Ela don't support `+` operator. This one is reserved in Ela only for arithmetic. You can use another polymorphic operator `++` which is called a _concatenation operator_ if you want to concatenate strings:

{{{
ela>str ++ "\r\n" ++ str2

Hello, world!
Hello,
"Basil"
}}}

As soon as strings are immutable concatenation operation always creates a new string. Also this operation doesn't perform implicit type casts - its both operands should be strings otherwise a runtime error is raised.

You can test strings for equality and compare them using comparison operator:

{{{
ela>str == str2

False

ela>str > str2

False

ela>str <= str2

True
}}}

You can also use built-in `length` function to calculate string length:

{{{
ela>let str = "Hello, world!"

ela>length str

13
}}} 

You can use an indexing operator to obtain a char by a given offset like so:

{{{
ela>str.[0]

H

ela>str.[12]

!
}}}

Indexing operator in Ela is pretty similar to that in C# with the only exception that it uses a extra dot before the square braces. If you already get used to the indexer in the form `newList[2]` it is really important to remember that this dot before the squate braces is required. This is because `newList[2]` is also a valid syntax in Ela but has a completely different meaning. As you remember Ela uses a simple juxtaposition for a function call, e.g. `x y` in Ela means that we apply an `x` function to the `y` argument. The same thing happens with `newList[2]` expression which is understood by Ela as: apply a function `newList` to the expression `[2]` which in turn creates a list with a single element.

As it was mentioned above indexing operator when applied to a string return a value of type `char`. Char is a pretty basic data type that is used to represent a single unicode character. It also has its own literal in Ela similar to the one that is used in C style languages:

{{{
ela>let c = 'H'

ela>c

H
}}}

Chars as well as strings can be tested for equality and compared. Also chars support built-in 'succ' and 'pred' functions:

{{{
ela>succ 'a'

b

ela>pred 'b'

a
}}}

These are basically all the things that you can do with chars. Unlike some other languages chars in Ela are not numeric types and cannot be implicitly converted to numeric types. Therefore code like `'a' + 'b'` is errorneous in Ela and won't work. You will have to explicitly convert chars to integers in order to fix it: `'a':int + 'b':int`.

=== Lists ===

List is one of the fundamental types in Ela. Lists in Ela are _single linked lists_. In a case if you haven't heard of such data structure before you can check it out in [http://en.wikipedia.org/wiki/List_(computing) Wikipedia]. 

In short single linked list is an ordered sequence of elements where each element holds a reference to the next element. The very last item in a list points to a thing that is called a _nil list_, which is nothing more than an empty list.

All elements of the linked list are also lists. Basically a single linked list can be seen as a very straightforward data structure that wraps some value and a reference to the next element. If have you ever coded in such language as C# this is how a minimalistic linked list can be implemented in this language:

{{{
class LinkedList<T>
{
  public static readonly LinkedList Nil = new LinkedList();

  private LinkedList() { }

  public LinkedList(T value, LinkedList next)
  {
    Value = value;
    Next = next;
  }

  public LinkedList Next { get; private set; }
  public T Value { get; private set; }
}
}}}

That is really it. As soon as list is an immutable data structure - you cannot change it in place like you do with an array - an empty (_nil_) list is represented as a "global" value. You don't have to create it "on demand" as soon as it never gets change and therefore can be initialized just once and used everywhere. As a result when you create an empty list in Ela nothing actually gets created - you just reference this special global _nil_ variable. This is how you can do that:

{{{
let lst = []
}}}

A `[]` is a special literal form that is used to denote an empty list.

If you need to create a list with just one element - e.g. an integer `42` - you basically have to initialize this simple linked list structure and to pass `42` as its value and a `nil` list as an element sitting nearby. This is how you can do it in C# using the `LinkedList` class that we've just created:

{{{
var lst = new LinkedList(42, LinkedList.Nil);
}}}

The same for the list with two elements:

{{{
var lst = new LinkedList(43, new LinkedList(42, LinkedList.Nil));
}}}

As you can see it looks quite cumbersome. That is why Ela has a special operator `::` that can be used to construct lists. Let's try it in console:

{{{
>let lst = 43::(42::[])

[43,42]
}}}

An operator `::` is called a list construction operator and it is right associative. It means that can omit braces from the previous sample and get exactly the same result:

{{{
>let lst2 = 43::42::[]

[43,42]
}}}

There is also a syntax sugar for this operator - as soon as it is still not visual enough for list construction - a special literal form of the list. The code above can also be written like so:

{{{
let lst2 = [43, 42]
}}}

Another useful operator that can be used with lists is a _concatenation operator_. This is how you can use it:

{{{
>lst ++ lst2

[43, 42, 43, 42]
}}}

A `++` operator can be used to concatenate two lists, you can't use it to append an element to a list. Actually because of the way how linked lists are organized there is no direct way to append an element to the end of the list - only to the head. If you desperately need it there is a way to do that of course:

{{{
>lst ++ [41]

[43, 42, 41]
}}}

(However bear in mind that this a very ineffecient operation - not only in Ela but in all languages that support lists and a similar set of operators).

Here we actually create a new list that contains a single element, number `41`, and then concatenate the two lists.

As soon as every list element holds a reference to the next element lists come up very handy when you need to iterate over their elements. In other words each item in a list basically know what it's neigbor is and it renders looping through the list as a pretty trivial task.

However Ela is a functional language and it doesn't even have a concept of iterators that you might've heard of in such languages as C#. In Ela one should use recursion instead of cycles. And that is again the place where _pattern matching_ becomes really helpful. As you remember from the previous article pattern matching allows us to deconstruct an element using its literal syntax which is in a case of linked lists a construction operator `::`. Here is a simple example of how you can iterate over list elements:

{{{
ela>let iter f x::xs = f x $ iter f xs; _ []    = ()
}}}

This function is basically an alternative to imperative cycle and you can use it like so (the following example prints all list elements to console):

{{{
ela>iter cout [1,2,3,4,5]

1
2
3
4
5
}}}

You've already seen a similar trick in functions from the previous article. Lists and pattern matching against lists are widely used in Ela code. As you remember a pattern in the form `x::xs` matches against a list that has at least one element. If a list really contains just a single item `xs` gets bound to the `nil`. Usually in expressions like the one above we call `x` a _head_ of the list and `xs` a list tail. 

The list deconstruction pattern can contain an arbitrary number of elements. You can use both variables and actual values in it, e.g. the following patterns are perfectly legal: `1::2::xs`, `x::(2,3)::xs`, `x::(y::ys)::xs`, `x::y::[]`. I will explain how this thing works with more detail in the chapter about pattern matching. 

The last pattern `x::y::[]` is used to match a list that has _exactly_ two elements. We basically say here that we want a list tail to match a nil list. It is useful when you want to ensure that a given list has an exact number of items. As with construction syntax there is a more readable form to write this - `[x,y]` which is fully equivavlent to `x::y::[]`.

Another example of how you write a function that iterates over list elements using recursion and pattern matching:

{{{
ela>let length' _::xs = 1 + length' xs; [] = 0

ela>length' [1,2,3,4,5]

5
}}}

The function above can be used to calculate the length of a list. It is not a very effective implementation but it works OK as an example. We again deconstruct a list using recursion until we actually reach the `nil` list. This function is executed as a chain of additions - because of this we don't have to declare mutable variables. The result of this function when the given list is a not a nil list is always `1` plus the length of the rest list, list tail.

Of course you don't have to code `length` function each time you need it. You can use a polymorphics built-in `length` function that you've already seen in the section about strings:

{{{
ela>length [1,2,3,4,5]

5
}}}

Another useful operation that is available for lists is an ability to obtain a list element by its index. This is done by using indexing syntax like so:

{{{
ela>let newList = [0,1,2,3,4]

ela>newList.[2]
}}}

You should also remember that accessing list elements by index is not a very effective operation. We have to iterate through the whole list and count each iteration - that is really the only way to do it. If you need to access elements by index frequently you might consider to use a different data structure instead - e.g. _array_ which has a constant access time.

=== Thunks and lazy lists ===

Thunks allow you to do deferred evaluation. With this data type you mark a certain expression in your code as the one that should be evaluated in a lazy manner - not immediately after it is declared but only when you actually need its value (e.g. to perform some kind of an operation with it).

This is how you can initialize a thunk in Ela:

{{{
ela>let thunk = (& let temp = 2 + 2 in cout temp $ temp)
}}} 

As you can see we have an expression that initializes a local variable with a result of an addition of two numbers, prints this result to the output and returns it. But when you copy the code above to Ela Console you see nothing. That is because an expression in `(& ... )` braces is not evaluated. Instead an instance of a special data type is created that wraps this expression and `thunk` variable is initialized with an instance of this data type.

But now we know that when Ela will finally calculate our lazy expression a console output in it will be triggered and signal us that calculation is finally done.

Let's see what happens if we pass `thunk` variable to the function as follows:

{{{
ela>let isThunk x = if x ? lazy then "Yep, it's lazy!" else "No, it's not!"

ela>isThunk thunk

Yep, it's lazy!
}}}

OK, it wasn't evaluated. Why? Because type check that we have performed in the `isThunk` function doesn't require an expression to be evaluated - and as the result it wasn't.

Let's try another way:

{{{
ela>thunk * 2

4
8
}}}

And now we have what we needed. We tried to multiply the value of `thunk` by two however in order to do so we obviosly need to calculate it. And that is the thing that was done here as you can see by the console output.

But what is going to happen if we try to use `thunk` in another calculation?

{{{
ela>thunk / 2

2
}}}

It is not calculated anymore! That is because it already was evaluated and its value was effectively remembered in order to prevent unneccessary calculations in future. The rule is pretty simple - every thunk is calculated just once and after that it becomes just an ordinary value:

{{{
ela>isThunk thunk

No, it's not!

ela>thunk ? int

True
}}}

Thunks are also useful when you need to create a lazy list - that is a linked list which is created on demand, only when you need a value of a particular element. The cool thing about lazy lists is that you can use them to represent infinite lists - lists that basically never end.

Let's try this. First we will need to declare a pretty typical `take` function that can take a specified amount of elements from a given list:

{{{
ela>let take 0 _ = []; n x::xs = x :: take (n - 1) xs; _ []    = []
}}}

Now we need to create our infinite list. We can do it through a function that accepts a number, increments it and uses the result to create list elements:

{{{
ela>let inf x = y :: (& inf y) where y = x + 1 end

ela>let lst = inf 0
}}}

OK, but what we can do with an infinite list? For example we can take a finite number of elements from it using our previously defined `take` function:

{{{
ela>take 10 lst

[1,2,3,4,5,6,7,8,9,10]
}}}

=== Arrays ===

Arrays in Ela are pretty similar to such type as `ArrayList` in .NET Framework. These are basically dynamic indexed polymorphic arrays. This is how you can create one:

{{{
ela>let arr = [|1,2,3,4,5|]

ela>arr

[|1,2,3,4,5|]
}}}

Arrays also support indexing operator and you can use built-in `length` function to calculate their length:

{{{
ela>arr.[4]

5

ela>arr.[1+2]

4

ela>length arr

5
}}}

Besides this arrays support a set of specific functions that allow to perform its modification in-place. These are functions `add`, `removeAt`, `insert` and `clear`. These functions are exposed as array fields. Field access in Ela is pretty similar to that one in C style languages.

Let's see which functions are supported by arrays.

Function `add` accepts a single arguments, appends it to the end of the list and returns `unit`:

{{{
ela>arr.add 6

ela>arr

[|1,2,3,4,5,6|]
}}}

Function `insert` allows you to insert elements into the list at a given position. The first argument is a zero based position, the second argument is a value to insert and the return value is `unit`:

{{{
ela>arr.insert 1 100

ela>arr

[|1,100,2,3,4,5,6|]
}}}

Function `removeAt` removes an element from a given position. It takes a position index and returns `unit`:

{{{
ela>arr.removeAt 1

ela>arr

[|1,2,3,4,5,6|]
}}}

And `clear` function just allows you to remove all elements from the list:

{{{
ela>arr.clear ()

ela>arr

[||]
}}}

That is basically all that you should know about arrays.

=== Tuples ===

Tuples are yet another fundamental data type in Ela. Well, probably not that fundametal as a list but still pretty important. Tuples are grouped sequences of elements. You can access each element of a tuple using an indexer syntax and this operation is as effecient as with arrays, however unlike arrays tuples are immutable - you cannot change them in place, append or remove items, etc.

This is how you can create a tuple in Ela:

{{{
ela>let t = (1,2,3)

ela>let t1 = (1,)

ela>t1

(1,)

ela>t

(1,2,3)
}}}

Tuple literal is pretty straitforward - you just list a sequence of elements separated by commas and enclose them in parentheses. However a single expression in parentheses like `(1)` doesn't create a tuple. As soon as parentheses are used as a grouping construct in the same manner as in C style languages the expression `(1)` is completely equivalent to just `1` (but of course `1 + 2 * 3` is pretty different from `(1 + 2) * 3` exactly like in C). If you want to create a tuple with just one element you can put a trailing comma like in the example above: `(1,)`.

You can pattern match tuples using tuple literal syntax, i.e.:

{{{
ela>match t with (1,2,x) = x end

3

ela>let (y,) = t1

ela>y

1
}}}

Tuples are really useful in certain cases. For example with tuples and pattern matching you can initialize multiple variables with a single expression like so:

{{{
ela>let (x1, y1, z1) = (1, "Hello, world", 42.12)

ela>x1

1

ela>y1

Hello, world

ela>z1

42.12
}}}

You can return multiple values from a function:

{{{
ela>let divMod x y = (x / y, x % y)

ela>divMod 43 12

(3,7)
}}}

In the example above I have created a function that accepts two arguments, divides first of them by second and returns the integral part of the division result and the remainder.

You can also use tuples to pass grouped arguments to a function:

{{{
ela>let sumTup (x, y) = x + y

ela>sumTup (1, 3)

4
}}}

Here we have created a function that actually accepts just one argument. This function pattern match this argument and binds the first element of a tuple to `x` and the second - to `y`. This function might look like as if it accepts two arguments not just one if you have programmed in C style languages before that use such a convention for all function declarations and calls however this is not the case in Ela:

{{{
ela>sumTup 1 4

<memory>(1,5): Error ELA809: Match failed. None of the patterns were successful.
        in memory.sumTup at line: 1, col: 5
        in memory at line: 1, col: 1
}}}

You can think that `sumTup` declaration is equivalent to the following:

{{{
ela>let sumTup2 t = t.[0] + t.[1]
}}}

However it is not. We can see why in a simple test:

{{{
ela>sumTup2 t

3

ela>sumTup t

<memory>(1,5): Error ELA809: Match failed. None of the patterns were successful.
        in memory.sumTup at line: 1, col: 5
        in memory at line: 1, col: 1
}}}

As you remember `t` is a tuple with three elements that we have declared before. The `sumTup2` function works without errors - it doesn't care how long our tuple is and will accept a tuple with three, thirty three or just one argument. In the latter case it will fail with a runtime error while trying to obtain a non-existent element, in other cases it will simply ignore all tuple elements except of the first two. Sometimes this is not the behavior that we actually need.

And here comes our original `sumTup` function. As you can see it doesn't really want to accept a three element tuple. That is because a three element tuple doesn't match the pattern in the function declaration where we have explicitly specified that we want a pair of elements, not a triple. This is how we can make it work:

{{{
ela>let t2 = (12, 24)

ela>sumTup t2

36
}}}

Another interesting pecularity of tuples is that unlike arrays tuples are always flat. In other words you cannot create a tuple that has other tuples as its elements. If you need something like that you should probably stick with lists or arrays. With tuples the hierarchy will be always flattened:

{{{
ela>(1,(2,3,(4,5)),6)

(1,2,3,4,5,6)
}}}

You can use the built-in `length` function to calculate the length of tuples:

{{{
ela>length t

3

ela>length t2

2
}}}

Length calculation is a pretty efficient operation with tuples - pretty much like with arrays. Tuples don't have any built-in fields like arrays however they might be a much more powerful data structure in certain cases.

A cool thing about tuples is that they support a lot of standard operators including comparison operators, arithmetic operators, bitwise, `succ` and `pred` functions and event concatenation operator. How all these things work with tuples? Let's take a look:

{{{
ela>(1, 2) == (1, 2)

True

ela>(1, 2) < (3, 4)

True

ela>succ (1, 2)

(2,3)

ela>(12, 5.5) + (1, 4.32)

(13,9.82)

ela>(4, 8) * (1, 2)

(4,16)
}}}

=== Records ===

The first thing you should know about records is that records _are_ tuples. They really are just special versions of tuples and everything from the previous section is true for records as well. You can think of records as extension to tuples that basically adds two things:

  # Access elements by names. With tuples you can only access an element by index when record allows you to give an alias to a particular element and to access this element using a given alias which might be more convinient in some cases.
  # Mutability. Records are immutable by default but you can make them mutable if you need to do so (which cannot be done with tuples)

Records in Ela are created like so:

{{{
ela>let r = {x = 1, y = 2 }

ela>r

{x=1,y=2}
}}}

You can access elements of records using either their index or name. The latter one has a C style syntax:

{{{
ela>r.[1]

2

ela>r.y

2
}}}

You can also declare a record with field names that are not valid Ela identifiers (i.e. contain special characters or spaces):

{{{
ela>let style = {"text-decoration" = "underline"}

ela>style

{text-decoration=underline}
}}}

In this case you will have to use indexer syntax to access a record element however you can still specify an element name through an indexer like so:

{{{
ela>r.["x"]

1

ela>style.["text-decoration"]

underline
}}}

It is important to understand that records in Ela are not hash tables. They are associative arrays. All elements in records are stored in order - just like in tuples - and you can even pattern match a record using tuple pattern. As a result we can use our previously defined `sumTup` function with a record:

{{{
ela>sumTup r

3
}}}

Of course there is more specific pattern that is applied to records only. This pattern allows you to both match a record with the specified fields and bind values of these fields to local variables:

{{{
ela>let {x=x',y=y'} = r

ela>x'

1

ela>y'

2
}}}

First you have to specify the name of the field, followed by an equality operator and a name of a local variable. In the example above we test if a given record contains fields `x` and `y` and bind the values of these fields to variables `x'` and `y'`. If a given records doesn't have any of the specified fields the match will fail. However if record contains other fields, not just `x` and `y`, it will still be a match.

There is also a syntax sugar that allows you to save up some key strokes when you want to bind field values to the variables of the same names. Instead of writing code like `{x=x,y=y}` you can simply write `{x,y}` - the latter syntax is fully equivalent to the first one.

The second important difference between records and tuples is that records can be mutable - you can change values of record fields in place without the need to create a new record. However this behavior is not supported by default. So if you try to change a value of our previously defined record `r` you will get the following error:

{{{
ela>r.x <- 2

<memory>(1,3): Error ELA816: Field 'x' of the record '{x=1,y=2}' is immutable and
cannot be changed.
        in memory at line: 1, col: 3
}}}

In order to make such an operation possible you have to explicitly declare a particular field as mutable using a `mutable` keyword:

{{{
ela>let recMut = { mutable x = 1, y = 2 }

ela>recMut.x <- 2

ela>recMut.y <- 3

<memory>(1,8): Error ELA816: Field 'y' of the record '{mutable x=2,y=2}' is immutable and cannot be changed.
        in memory at line: 1, col: 8

ela>recMut

{mutable x=2,y=2}
}}}

And that is basically all you should know about records.

=== Polymorphic variants ===

This one is much more straightforward than its title. The idea behind variants is really simple. Sometimes you might need to _tag_ some values. If you ever programmed in C# it offers a similar yet pretty limited infrastructure called _nullable types_. Imagine that you write a function that might return either an integer value or nothing. How to return this "nothing"? Of course you can generate an exception but in many cases it is not a good idea as soon as we don't have any _exceptional situation_ here - we just have nothing to return.

That is a place where nullable types comes very handy. With nullable types you simply create a structure that wraps your actual return value and a boolen flag that indicates whether this value was trully initialized. Let's implement a simple function in C# that accepts a single integer argument, tests whether this argument is odd and if it is returns the remainder of its division by 2, otherwise - returns "nothing":

{{{
int? getOdd(int x) {
  var r = x % 2;
 
  if (r > 0)
    return r;
  else
    return null;
}
}}}

Ela doesn't have nullable types. But Ela has something that might be a little bit more flexible. This is how this `getOdd` function will be implemented in Ela:

{{{
let getOdd x | r > 0 = `Odd r;
             | else  = `Even
             where r = x % 2 end
}}}

In Ela you can also create a wrapping structure that can be used to attach any custom tag to a value if you want to associate some additional data with this value that can be used in further analysis. You can also attach a tag to _unit_ (in a case if there is no meaningful value for the particular situation). It is done like so: ``None ()` or even shorter like so: ``None` - these two expressions are equivalent.

And that is what we have done in the example above - for an odd value we attach a tag "Odd" to the remainder and for the even value (as soon as there is no remainder) we just return a plain tag. (Please bear in mind that tags always start from a _back apostrophe_).

As usual you can pattern match agains variants using their literal syntax:

{{{
ela>let getOdd x | r > 0 = `Odd r; | else = `Even where r = x % 2 end

ela>match getOdd 13 with `Odd x = x; `Even = 0 end

1
}}}

Tags can be attached to values of any types - it can be arrays, tuples, lists, records - whatever you can think of. When pattern matching you should specify a tag name followed by pattern that is used to match against a value to which this tag is attached. Function `getOdd` uses a simple integer literal pattern but it can be head/tail pattern, array pattern, tuple pattern, etc.

Another cool thing about variants is that they are completely transparent for the client code. Let's see what it means:

{{{
ela>let rem = getOdd 15

ela>rem

`Odd 1

ela>rem + 3

4

ela>rem < 0

False
}}}

If you try to perform any operation with a variant this operation will be actually performed with the wrapped value. So if you have a variant that wraps an integer you can still use all your arithmetic functions with this variant:

{{{
ela>let pow x y = x ** y

ela>pow (`SomeNumber 14) (`AnotherNumber 5)

537824
}}}

Polymorphic variants are used very widely in Ela. In many cases they are a much better alternative to exceptions (which are also supported in Ela but used less extensively than in languages like C#). Moreover variants are actually the only way how you can create your own data types in Ela:

{{{
ela>let cellp = `Cellphone { Model="E75", Maker="Nokia", Color="Black" }

ela>if cellp ? (`Cellphone {Model="E75"}) then "This is a E75 smartphone!" else
"Don't know what is is."

This is a E75 smartphone!
}}}

As soon as variants fully support pattern matching even exceptions in Ela are based on variants. Also a lot of standard functions use ``Some` and ``None` tags in their return values to indicate whether a value is actually there.

=== Modules ===

You could probably think that modules are a little bit misplaced in the chapter devoted to Ela data types however that is not exactly true. But let's start from the beggining.

I assume that you are already acquainted with the concept of modules from other programming languages. It is not much different in Ela. If you want to split your code into several files, to implement some generic functionality that might be used by several programs than modules is the only way to go. In Ela module is strictly bound to a file - you can't create several modules in a single file or a big module that includes several files. For that reason there is no specific syntax that can be used to declare a module - creating a file automatically does so.

You can reference Ela modules within your code using `open <Module Name>` statement. Let's see that in action. Create a file `Foo.ela` in the same directory where you have your `elac.exe` executable, and place the following code into this file:

{{{
let message = "Hello from Foo!"
}}}

Now we can open this module directly from interactive console like so:

{{{
ela>open Foo

ela>Foo.message

Hello from Foo!
}}}

Yes, it works. By default Ela looks for referenced modules in the directory where it is installed and in the directory where the currently executing Ela file is located. You can configure Ela to use other lookup directories as well. In order to so you need to create `elac.exe.config` file nearby `elac.exe` with the following content:

{{{
<configuration>   
	<appSettings>     
		<add key="ref" value="c:\myLib;c:\myAnotherLib" />   
	</appSettings> 
</configuration>
}}}

However it is not always practical to alter configuration in order to open module from other than default directory. That is why you can specify a module path directly in the `open` statement. Let's test it. Create an _Includes_ directory nearby _elac.exe_ and create a `Bar.ela` file inside it with the following code:

{{{
let message = "Hello from Bar!"

let message2 = "See you, Bar!"
}}}

Now let's try to open it from Ela Console:

{{{
ela>open Bar

Bar.ela(1,1): Error ELA608: Unable to find referenced module 'Bar'.
}}}

Oops, that didn't work. Let's try it differently:

{{{
ela>open Bar at "Includes"

ela>Bar.message

Hello from Bar!
}}}

OK, but what if you have two completely different modules with the same name. Taking into account that different people could work on them that is a possibility. In order to deal with such situations Ela has an ability to define module aliases:

{{{
ela>open Foo as Foo2

ela>Foo2.message

Hello from Foo!
}}}

Last but not least you can provide an import list directly inside the `open` statement:

{{{
ela>open Bar at "Includes" as Bar2 with message, message2

ela>message

Hello from Bar!

ela>message2

See you, Bar!
}}}

By doing so you actually declare local module variables that are initialized by corresponding variables from another module. You can also give them different names if you wish so:

{{{
open Bar with myMessage = message, myMessage2 = message2
}}}

That is all that you should know about `open` statement. However you might still be wondering why this section is placed in the chapter about data type. That is because modules are first class values in Ela.

It means that you can treat module like any other value. For example you can assign it to a variable:

{{{
ela>let mod = Bar

ela>mod

[module:Includes\Bar]
}}}

Or you can pass an instance of a module to a function:

{{{
ela>let getMsg mod = mod.message

ela>getMsg Foo

Hello from Foo!

ela>getMsg Bar

Hello from Bar!
}}}

As you can see you can even create generic functions that operates on modules.

=== Functions ===

Finally we've got to the most important data type in Ela. Function. But functions are so important and fundamental - and there is so much to tell about them - that they will definitely require a separate article.

The next part of Ela overview is fully devoted to functions, their pecularities in Ela, declaration syntax and operations available for them. 