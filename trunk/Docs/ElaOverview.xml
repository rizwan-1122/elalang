<?xml version="1.0" encoding="UTF-8" ?>
<ARTICLE>
  <TITLE>Краткий обзор языка Ela</TITLE>
  <KEYWORDS>языки программирования; функциональное программирование; .NET</KEYWORDS>
  <ABSTRACT>Краткий обзор языка программирования Ela.</ABSTRACT>
  <AUTHOR e-mail="адрес" rsdn-profile="16070" phone="(код города) телефон" address="почтовый адрес" place-of-employment="Сокращенное название места работы в именительном падеже" job="Название должности" place-of-study="наименование учебного заведения в именительном падеже" scientific-degree="сокращенное название" scientific-rank="звание" href="http://www.rsdn.ru/Users/16070.aspx">Воронков Василий Владимирович</AUTHOR>
  <DATE>04.06.2010</DATE>
  <VERSION>1.0</VERSION>
  <METADATA-EN>
    <KEYWORDS>programming languages; .NET; functional programming</KEYWORDS>
    <ABSTRACT>Overview of Ela programming language.</ABSTRACT>
    <AUTHOR e-mail="address" rsdn-profile="16070" phone="phone" address="postal address" place-of-employment="Company name" job="Job position" place-of-study="place of study" scientific-degree="academic degree" scientific-rank="academic rank" href="http://www.rsdn.ru/Users/16070.aspx">Basil Voronkov</AUTHOR>
    <DATE>04.06.2010</DATE>
    <VERSION>1.0</VERSION>
    <TITLE>Ela language overview</TITLE>
  </METADATA-EN>
  <CONTENTS />
  <LITERATURE />
  <PART>
    <HEADER>Цель данной статьи</HEADER>
    <P>Данная статья не ставит перед собой целью дать исчерпывающее описание языка, всех его операторов и конструкций. Цель статьи – показать наиболее яркие особенности Ela и стать своего рода введением в этот язык. Также эта статья не может быть использована для знакомства с основными концепциями функционального программирования – предполагается, что читатель уже с знаком с такими понятиями как паттерн-матчинг, функции как первоклассные значения, вариантные типы данных и др. В статье дается лишь краткое описание этих концепций – для более полного их понимания я рекомендую обратиться к учебной литературе по языку OCaml, с которым у Ela больше всего общего.</P>
  </PART>
  <PART>
    <HEADER>Синтаксис и семантика</HEADER>
    <P>Здесь я буду сравнивать Ela с языками C# (на котором Ela написана и который является самым распространенным языком под платформу .NET) и JavaScript (который также является одним из наиболее широко известных динамических языков программирования и, подобно Ela, имеет C-подобный синтаксис).</P>
    <P>Итак, Ela является языком с С-подобным синтаксисом, а это значит, что в коде будет много фигурных скобок и точек с запятой. В большинстве случаев синтаксис не должен вызывать вопросов у программистов, знакомых хотя бы с одним С-подобным языком. Однако есть и небольшие отличия от того, к чему привыкли программисты того же JavaScript.</P>
    <P>В Ela не используется механизм аналогичный semicolon insertion в JavaScript, однако правила по расстановке точек с запятой все же не такие строгие, как в C#. Точки с запятой в Ela можно опускать у последнего выражения в блоке, а также если выражение завершается на фигурную скобку или же сразу после него идет фигурная скобка. Фигурные скобки также можно опускать в тех случаях, когда у вас есть лишь одно выражение. Например, если функция состоит из одного выражения — то фигурные скобки необязательны:</P>
    <CODE><KEYWORD>let</KEYWORD> item(arr, index) <KEYWORD>if</KEYWORD> (arr.length &gt; index) `Some(arr[index]) <KEYWORD>else</KEYWORD> `None;
</CODE>
    <P>При желании вы можете записать эту функцию и так:</P>
    <CODE><KEYWORD>let</KEYWORD> item(arr, index) {
  <KEYWORD>if</KEYWORD> (arr.length &gt; index) 
    `Some(arr[index]) 
  <KEYWORD>else </KEYWORD>
    `None
}</CODE>
    <P>Другое важное отличие от JavaScript – это то, что в Ela используется лексическая область видимости, т.е. такая же, как и в «прародителе» обсуждаемого синтаксиса, в языке С. В этом смысле Ela ближе к C#, чем к JavaScript, однако, в отличие от C#, Ela допускает затенение переменных в родительском блоке, так же как и С/C++.</P>
    <P>Например, следующий код является совершенно корректным в Ela и приведет к ошибке компиляции в C#:</P>
    <CODE><KEYWORD>var</KEYWORD> x = 1;

{
  <KEYWORD>var</KEYWORD> x = 2;
}</CODE>
    <P>Фигурные скобки в Ela всегда задают лексический блок. Также лексический блок задают и конструкции вроде объявления функции, организации цикла (for, while), условные операторы (if, when, unless), обработки исключений (try/catch) и паттерн-матчинга (match, is). Об этих конструкциях более  подробно будет рассказано ниже.</P>
    <P>Еще одна существенная черта синтаксиса Ela – это то, что в Ela все является выражением (expression) , все возвращает значение. </P>
    <P>Например, следующий код является совершенно корректным:</P>
    <CODE><KEYWORD>var</KEYWORD> x = 
  <KEYWORD>if</KEYWORD> ($param &gt; 0) 
    createList($param) 
  <KEYWORD>else </KEYWORD>
    [];</CODE>
    <P>Корректным является даже такой код на Ela:</P>
    <CODE><STRING>"Hello, world!"</STRING>;
5 + 5;
2;</CODE>
    <P>Однако, как вы понимаете, смысла в таком коде немного, поэтому в тех случаях, когда возвращаемое значение выражения не используется, компилятор генерирует специальное предупреждение:</P>
    <CODE>Warning ELA1002: Value returned by this expression is not used.</CODE>
    <P>Для того, чтобы избавиться от этого предупреждения, можно использовать специальное ключевое слово ignore:</P>
    <CODE><KEYWORD>ignore</KEYWORD><STRING> "Hello, world!"</STRING>;
<KEYWORD>ignore</KEYWORD> 5 + 5;
<KEYWORD>ignore </KEYWORD>2;</CODE>
    <P>Само собой некоторые императивные конструкции вроде for, break, while и т.д. не могут возвращать ничего полезного, поэтому считается, что они возвращают значение типа unit (он же void в C#) и в таком случае предупреждение не генерируется. Предупреждение также не генерируется, если выражение является последним во всем файле с кодом – так как значение данного выражения будет значением, возвращаемым интерпретатором Ela вызывавшему его коду. Например, если для исполнения файлов Ela вы используете приложение Ela Console, то значение последнего выражение (если оно отлично от unit) будет выведено в консоль.</P>
    <P>И наконец последний момент, о котором я упомяну в данном разделе, это типизация языка. Ela, в отличие от C#, является динамически типизированным языком, т.е. информация о типе становится доступна только во время исполнения кода. Таким же поведением обладает и JavaScript, однако, в отличие от JavaScript, Ela является строго типизированным языком, т.е. в ней нет неявных приведений к булевому типу, нельзя складывать строки и числа и т.д.</P>
    <P>В остальном синтаксис и семантика основных конструкций Ela не вызовет у вас никаких вопросов. Например, группировка выражений осуществляется с помощью круглых скобок. Также в Ela есть операторы инкремента и декремента с такой же семантикой, как и в С; есть отдельный оператор для сравнения (==) и отдельный оператор для присваивания (=), причем последний, так же как и в С, возвращает результат операции. Так как Ela является строго типизированным языком, то в ней отпадает необходимости в операторах «строгого» сравнения (=== и !==) из JavaScript. Остальной набор операторов языка будет хорошо знаком вам по тому же C# - в Ela есть все основные арифметические операторы, битовые операторы, операторы сдвига, а также ряд дополнительных, о которых будет рассказано в следующей секции.</P>
  </PART>
  <PART>
    <HEADER>Базовые конструкции языка</HEADER>
    <SECTION>
      <HEADER>Операторы</HEADER>
      <P>Ela поддерживает следующие бинарные операторы.</P>
      <TABLE>
        <TR>
          <TH>
            <P>
              <B>Оператор</B>
            </P>
          </TH>
          <TH>
            <P>
              <B>Описание</B>
            </P>
          </TH>
          <TH>
            <P>
              <B>Пример</B>
            </P>
          </TH>
        </TR>
        <TR>
          <TD>
            <P>&lt;=&gt;</P>
          </TD>
          <TD>
            <P>Обмен переменных значениями</P>
          </TD>
          <TD>
            <P>x &lt;=&gt; y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>||</P>
          </TD>
          <TD>
            <P>Условное «Или»</P>
          </TD>
          <TD>
            <P>x || y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&amp;&amp;</P>
          </TD>
          <TD>
            <P>Условное «И»</P>
          </TD>
          <TD>
            <P>x &amp;&amp; y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>is</P>
          </TD>
          <TD>
            <P>Оператор для паттерн-матчинга</P>
          </TD>
          <TD>
            <P>x is int</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&gt;&gt;&gt;</P>
          </TD>
          <TD>
            <P>Композиция функций слева направо</P>
          </TD>
          <TD>
            <P>x &gt;&gt;&gt; y &gt;&gt;&gt; z</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&lt;&lt;&lt;</P>
          </TD>
          <TD>
            <P>Композиция функций справа налево</P>
          </TD>
          <TD>
            <P>x &lt;&lt;&lt; y &lt;&lt;&lt; z</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>::</P>
          </TD>
          <TD>
            <P>Конструктор списков</P>
          </TD>
          <TD>
            <P>x::y::[]</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>|&gt;</P>
          </TD>
          <TD>
            <P>Оператор «Forward pipe»</P>
          </TD>
          <TD>
            <P>x(arg) |&gt; y |&gt; z</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&lt;|</P>
          </TD>
          <TD>
            <P>Оператор «Backward pipe»</P>
          </TD>
          <TD>
            <P>z &lt;| y &lt;| x(arg)</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>|</P>
          </TD>
          <TD>
            <P>Битовое «Или»</P>
          </TD>
          <TD>
            <P>x | y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>^</P>
          </TD>
          <TD>
            <P>Исключающее «Или»</P>
          </TD>
          <TD>
            <P>x ^ y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&amp;</P>
          </TD>
          <TD>
            <P>Битовое «И»</P>
          </TD>
          <TD>
            <P>x &amp; y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>==</P>
          </TD>
          <TD>
            <P>Оператор «Равенство»</P>
          </TD>
          <TD>
            <P>x == y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>!=</P>
          </TD>
          <TD>
            <P>Оператор «Неравенство»</P>
          </TD>
          <TD>
            <P>x != y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&gt;</P>
          </TD>
          <TD>
            <P>Оператор «Больше»</P>
          </TD>
          <TD>
            <P>x &gt; y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&lt;</P>
          </TD>
          <TD>
            <P>Оператор «Меньше»</P>
          </TD>
          <TD>
            <P>x &lt; y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&gt;=</P>
          </TD>
          <TD>
            <P>Оператор «Больше или равно»</P>
          </TD>
          <TD>
            <P>x &gt;= y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&lt;=</P>
          </TD>
          <TD>
            <P>Оператор «Меньше или равно»</P>
          </TD>
          <TD>
            <P>x &lt;= y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&gt;&gt;</P>
          </TD>
          <TD>
            <P>Оператор правого сдвига</P>
          </TD>
          <TD>
            <P>x &gt;&gt; 8</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&lt;&lt;</P>
          </TD>
          <TD>
            <P>Оператор левого сдвига</P>
          </TD>
          <TD>
            <P>x &lt;&lt; 8</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>+</P>
          </TD>
          <TD>
            <P>Сложение</P>
          </TD>
          <TD>
            <P>x + y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>-</P>
          </TD>
          <TD>
            <P>Вычитание</P>
          </TD>
          <TD>
            <P>x – y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>*</P>
          </TD>
          <TD>
            <P>Умножение</P>
          </TD>
          <TD>
            <P>x * y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>/</P>
          </TD>
          <TD>
            <P>Деление</P>
          </TD>
          <TD>
            <P>x / y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>%</P>
          </TD>
          <TD>
            <P>Получение остатка при делении</P>
          </TD>
          <TD>
            <P>x % y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>**</P>
          </TD>
          <TD>
            <P>Возведение в степень</P>
          </TD>
          <TD>
            <P>x ** y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>:&gt;</P>
          </TD>
          <TD>
            <P>Приведение типов</P>
          </TD>
          <TD>
            <P>x :&gt; int</P>
          </TD>
        </TR>
      </TABLE>
      <P>Большинство из приведенных выше операторов наверняка вам уже знакомы, про те операторы, которых нет ни в C#, ни в JavaScript, я расскажу чуть подробнее.  </P>
      <P>Оператор is похож на одноименный оператор из С#, однако он может использоваться не только для проверки типов, но и для паттерн-матчинга, чему посвящена отдельная секция этой статьи.</P>
      <P>Операторы композиции функций и pipe-операторы соответствуют таковым в языке F# и используются при работе с функциональными типами. С помощью операторов композиции вы можете создавать новые функции во время исполнения программы, а pipe-операторы позволяют записывать цепочку вызова функций в более декларативном ключе. Все эти операторы правоассоциативны. Об этих операторах будет более подробно рассказано в секции, посвященной функциям.</P>
      <P>Оператор возведения в степень в качестве правого операнда принимает степень, в которую вы хотите возвести число. Например, выражение вида «x * x» будет полностью аналогично «x ** 2».</P>
      <P>Поведение оператора для приведения типов должно быть интуитивно понятно, он работает практически так же, как и так назваемый «С-каст» в языке C# и тоже может генерировать исключения в тех случаях, когда приведение невозможно.</P>
      <P>Оператор обмена переменных значениями присваивает левому операнду значение правого и наоборот. Особенностью данного оператора является то, что он вычисляет выражения слева и справа только единожды, поэтому вы можете спокойно использовать этот оператор даже в тех случаях, когда ваши выражения имеют побочные эффекты.</P>
      <P>Ela поддерживает следующие унарные операторы:</P>
      <TABLE>
        <TR>
          <TH>
            <P>
              <B>Оператор</B>
            </P>
          </TH>
          <TH>
            <P>
              <B>Описание</B>
            </P>
          </TH>
          <TH>
            <P>
              <B>Пример</B>
            </P>
          </TH>
        </TR>
        <TR>
          <TD>
            <P>+</P>
          </TD>
          <TD>
            <P>Унарный плюс</P>
          </TD>
          <TD>
            <P>x + y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>-</P>
          </TD>
          <TD>
            <P>Унарный минус</P>
          </TD>
          <TD>
            <P>x - y</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>!</P>
          </TD>
          <TD>
            <P>Логическое отрицание</P>
          </TD>
          <TD>
            <P>!x</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>~</P>
          </TD>
          <TD>
            <P>Поразрядное дополнение операнда</P>
          </TD>
          <TD>
            <P>~x</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>&amp;</P>
          </TD>
          <TD>
            <P>Оператор «Взять значение»</P>
          </TD>
          <TD>
            <P>&amp;x</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>++</P>
          </TD>
          <TD>
            <P>Инкремент (постфиксная и префиксная формы)</P>
          </TD>
          <TD>
            <P>x++; ++x;</P>
          </TD>
        </TR>
        <TR>
          <TD>
            <P>--</P>
          </TD>
          <TD>
            <P>Декремент (постфиксная и префиксная формы)</P>
          </TD>
          <TD>
            <P>x--; --x;</P>
          </TD>
        </TR>
      </TABLE>
      <P>Единственный оператор в этом списке, который требует дополнительного уточнения – это оператор «взять значение». Данный оператор используется для вычисления значения отложенных и асинхронных выражений, о которых речь будет идти в отдельной секции.</P>
      <P>Однако это еще не все – Ela также поддерживает создание пользовательских операторов. Вы можете объявлять как бинарные, так и унарные операторы. </P>
      <P>Вот пример бинарного оператора:</P>
      <CODE><KEYWORD>let</KEYWORD> @(+++)(x, y) x :&gt; string + y :&gt; string;
</CODE>
      <P>Данный оператор позволяет конкатенировать любые типы данных как строки, избавляя вас от лишних приведений типов. Вот так его можно использовать:</P>
      <CODE><KEYWORD>var</KEYWORD> x = 2;
<KEYWORD>var</KEYWORD> y = 3;
x +++ y</CODE>
      <P>Вывод программы:</P>
      <CODE>23
</CODE>
      <P>Пример унарного оператора:</P>
      <CODE><KEYWORD>let</KEYWORD> ~(!!)(x) <KEYWORD>if</KEYWORD> (x &gt; 0) x <KEYWORD>else</KEYWORD> -x;
<KEYWORD>var</KEYWORD> x = -2;
!!x</CODE>
      <P>Вывод программы</P>
      <CODE>2
</CODE>
      <P>Как вы уже заметили, данный оператор всегда возвращает абсолютное значение операнда.</P>
      <P>Пользовательские операторы не должны совпадать с уже существующими, т.е. перегрузка имеющихся операторов не поддерживается. Также при объявлении пользовательских операторов вы можете использовать в качестве названий только следующие символы: !%&amp;*+-./&lt;=&gt;?@^|~.</P>
      <P>Название оператора всегда берется в круглые скобки. Eсли перед названием идет символ «@», то оператор считается бинарным и должен принимать два аргумента, если – символ «~», то оператор считается унарным и может иметь только один аргумент. Также операторы можно объявлять только с помощью ключевого слова let.</P>
    </SECTION>
    <SECTION>
      <HEADER>Условный оператор</HEADER>
      <P>Условный оператор (if) имеет в Ela точно такой же синтаксис, как в C# и JavaScript, однако он является выражением, как вы уже заметили по приведенным ранее примерам. Более того, else обязателен – благодаря этому мы всегда можем быть уверены, что оператор if, независимо от условия, всегда возвращает какое-либо выражение – или в конце блока if, или в конце блока else.</P>
      <P>Например, следующий код является неверным и приведет к ошибке компиляции:</P>
      <CODE><KEYWORD>var</KEYWORD> x = 2;

<KEYWORD>if</KEYWORD> (x &gt; 0)
  <KEYWORD>cout</KEYWORD> x;</CODE>
      <P>Запустив данный код на выполнение, вы увидите такое сообщение об ошибке:</P>
      <CODE>Error ELA107: A conditional expression (if/else) is missing a required 'else' clause.</CODE>
      <P>В тех случаях, когда вам все же требуется if без else, можно использовать специальный оператор when. Например, вышеприведенный пример кода мы можем переписать так:</P>
      <CODE><KEYWORD>var</KEYWORD> x = 2;

<KEYWORD>when</KEYWORD> (x &gt; 0)
  <KEYWORD>cout</KEYWORD> x;</CODE>
      <P>В отличие от if у оператора when никогда не бывает блока else. По этой причине оператор when всегда возвращает значение типа unit – независимо от того, выполнилось ли его условие или нет.</P>
      <P>Также для удобства был введен специальный оператор unless. Данный оператор ведет себя точно так же, как и оператор when, но с одним-единственным отличием – код внутри unless выполняется только в том случае, если условие равно false. Например, код вида:</P>
      <CODE><KEYWORD>when</KEYWORD> (x != 0)
  <KEYWORD>cout</KEYWORD> x;</CODE>
      <P>Полностью эквивалентен:</P>
      <CODE><KEYWORD>unless</KEYWORD> (x == 0)
  <KEYWORD>cout</KEYWORD> x;</CODE>
    </SECTION>
    <SECTION>
      <HEADER>Циклы</HEADER>
      <P>Ela поддерживает циклы for и while, а также операторы break, return и continue. Цикл for несколько отличается по синтаксису от того, что используется в С-подобных языках и имеет три варианта. У цикла while – варианта всего два. Для перехода к следующей итерации любого из описываемых здесь циклов можно использовать оператор continue, для выхода из цикла – оператор break.</P>
      <SUBSECTION>
        <HEADER>Цикл for-to</HEADER>
        <P>Данный цикл используется для последовательного перебора значений по возврастающей, а также поддерживает гварды (булевые условия, по которым те или иные значения должны попадать в итоговую выборку). В простейшем случае этот цикл выглядит так:</P>
        <CODE><KEYWORD>for</KEYWORD> (x <KEYWORD>to</KEYWORD> 10) 
  <KEYWORD>cout</KEYWORD> x;</CODE>
        <P>Результатом выполнения этой программы будет распечатка целых чисел, начиная от 0 и кончая 10.</P>
        <P>Возможна и такая запись:</P>
        <CODE><KEYWORD>for</KEYWORD> (x = 1 <KEYWORD>when</KEYWORD> (x % 2 == 0) <KEYWORD>to</KEYWORD> 10) 
  <KEYWORD>cout</KEYWORD> x;</CODE>
        <P>Данный цикл выведет уже список четных целых чисел в диапазоне от 1 до 10.</P>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Цикл for-downto</HEADER>
        <P>Этот цикл аналогичен for-to и имеет единственное отличие - он перебирает значения по убывающей, а не по возврастающей. Цикл for-downto также поддерживает гварды:</P>
        <CODE><KEYWORD>for</KEYWORD> (x = 10 <KEYWORD>when</KEYWORD> (x % 2 == 0) <KEYWORD>downto</KEYWORD> 1) 
  <KEYWORD>cout</KEYWORD> x;</CODE>
        <P>Результатом этого кода будет список всех четных чисел от 1 до 10, выведенный в обратом порядке.</P>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Цикл for-in </HEADER>
        <P>Данный цикл ведет себя аналогично циклу foreach в C#, однако поддерживает гварды и паттерн матчинг.</P>
        <P>Например, предположим, что у нас есть список, элементами которого являются записи (о типе данных «запись» будет более подробно написано ниже). Разобрать этот список в цикле можно используя такой код:</P>
        <CODE><KEYWORD>let</KEYWORD> list = [ (x:1,y:2), (x:3,y:4), (x:5,y:6), (x:7,x:8), (x:9,x:10) ];

<KEYWORD>for</KEYWORD> ((y = y) <KEYWORD>as</KEYWORD> rec <KEYWORD>when</KEYWORD> (y % 2 == 0) <KEYWORD>in</KEYWORD> list)
  <KEYWORD>cout</KEYWORD> rec;</CODE>
        <P>Данный пример связывает значение поля «y» с одноименной локальной переменной, связывает весь экземпляр элемента списка с локальной переменной «rec» и выбирает из списка только те записи, значение поля «y» которых является четным.</P>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Цикл while</HEADER>
        <P>Это самый простой цикл в Ela, он полностью аналогичен циклам while из других С-подобных языков:</P>
        <CODE><KEYWORD>while</KEYWORD> (x &lt; 10)
  x++;</CODE>
        <P>Следует иметь в виду, что компилятор Ela специально оптимизирует циклы вида while(true), устраняя лишнюю проверку. Поэтому, если вам нужен бесконечный цикл, то его лучше всего организовать его именно таким путем.</P>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Цикл do-while</HEADER>
        <P>Этот цикл аналогичен циклу while, однако отличается от него тем, что код внутри цикла всегда будет выполнен хотя бы один раз, независимо от условия:</P>
        <CODE><KEYWORD>do</KEYWORD>
  <KEYWORD>cout</KEYWORD> <STRING>"do while"</STRING>
<KEYWORD>while</KEYWORD> (<KEYWORD>false</KEYWORD>);</CODE>
        <P>Если вы запустите данный пример, то он выведет на консоль «do while».</P>
      </SUBSECTION>
    </SECTION>
    <SECTION>
      <HEADER>Объявление переменных</HEADER>
      <P>Так как, что уже упоминалось ранее, Ela является динамически типизированным языком, и информация о типе в Ela связывается не с переменной, а со значением этой переменной, то имеет смысл говорить, что при выполнении кода вида:</P>
      <CODE><KEYWORD>var</KEYWORD> x = 2;
</CODE>
      <P>происходит связывание значения 2 и имени x.</P>
      <WARNING>
        <P>Имейте в виду, что указание значения при объявлении имени является обязательным. Т.е. вы всегда должны явно проинициализировать переменную значением по умолчанию, даже если переменная – изменяемая.</P>
      </WARNING>
      <P>Ela поддерживает изменяемые и неизменяемые имена. Изменяемые имена – это такие, значение которых может быть изменено по ходу выполнения программы. Они объявляются с помощью ключевого слова var, по аналогии с JavaScript, как вы видели в примере выше. Однако, в отличие от JavaScript, предварительное объявление имени, как и его инициализация, являются обязательным, и если вы попробуете использовать необъявленное ранее имя, то получите ошибку времени компиляции.</P>
      <P>Выполнение следующего кода:</P>
      <CODE><KEYWORD>var</KEYWORD> x = 2;
x + y</CODE>
      <P>выведет следующее сообщение:</P>
      <CODE>Error ELA208: Undefined variable 'y'.</CODE>
      <P>Ela также поддерживает и неизменяемые имена, которые объявляются с помощью ключевого слова let. Имена, объявляенные с помощью let, можно рассматривать как константы – вы не сможете изменить их значений по ходу выполнения программы, – однако если значением такого имени является изменяемая структура данных (например, массив), то у вас по-прежнему останется возможность изменять эту структуру «по месту». Например:</P>
      <CODE><KEYWORD>let</KEYWORD> arr = [| 0, 1, 2 |];
arr[0] = 1; <COMMENT>//OK</COMMENT>
arr = [| 3, 4, 5 |]; <COMMENT>//Error ELA213: Unable to change a value of an immutable variable 'arr'.</COMMENT></CODE>
      <P>Есть и возможность объявления «закрытых» имен. Для этого после var или let нужно добавить модификатор private. Такие переменные не будут видны за пределами модуля (о модулях см. в нижеследующих секциях).</P>
      <CODE><KEYWORD>let</KEYWORD> <KEYWORD>private</KEYWORD> E = 2.7182818284590451D; <COMMENT>//наша константа не будет видна за пределами модуля</COMMENT>
</CODE>
      <P>Важной особенностью объявления имен в Ela является поддержка паттерн-матчинга. Например, получая из функции кортеж вы можете «разобрать» этот кортеж на отдельные имена таким вот образом:</P>
      <CODE><KEYWORD>let</KEYWORD> (x, y) = myFunc();
</CODE>
      <P>Более подробно о паттерн-матчинге речь также пойдет ниже.</P>
    </SECTION>
    <SECTION>
      <HEADER>Обработка исключений</HEADER>
      <P>Ela поддерживает структурную обработку исключений на манер языков C# и JavaScript, однако в большинстве случаев вместо генерации исключений рекомендуется использовать полиморфные варианты.</P>
      <P>Генерация исключения осуществляется с помощью оператора throw. В качестве исключения может выступать любой тип данных – например, вы можете сгенерировать исключение, состоящее из строки или целого числа, как и в JavaScript.</P>
      <P>Для обработки исключений используется конструкция try/catch:</P>
      <CODE><KEYWORD>var</KEYWORD> result = (); <COMMENT>//Объявляем переменную и инициализируем ее типом unit</COMMENT>

<KEYWORD>try</KEYWORD>
  result = myFunc();
<KEYWORD>catch</KEYWORD> (e)
  <KEYWORD>cout</KEYWORD> e.message;</CODE>
      <P>Не забываем, что конструкция try/catch так же является выражением, поэтому вышеприведенный пример можно записать и так:</P>
      <CODE><KEYWORD>var</KEYWORD> result = 
  <KEYWORD>try</KEYWORD>
    myFunc();
  <KEYWORD>catch</KEYWORD> (e)
    <KEYWORD>cout</KEYWORD> e.message;</CODE>
      <P>Как вы видите по примеру кода, фигурные скобки в блоках try и catch являются необязательными. Но само собой вы можете их использовать, если такой синтаксис кажется вам более наглядным. Блок catch также поддерживает сокращенную запись для паттерн-матчинга:</P>
      <CODE><KEYWORD>try</KEYWORD>
  result = myFunc();
<KEYWORD>catch</KEYWORD> (e)
  <KEYWORD>on</KEYWORD> `ListError -&gt; processListError()
  <KEYWORD>on</KEYWORD> `TupleError -&gt; processTupleError()
  <KEYWORD>on</KEYWORD> _ -&gt; processUnknownError();</CODE>
      <P>Правила для паттерн-матчинга в блоке catch точно такие же, как и при использовании конструкции match, о которой речь пойдет ниже. Если не происходит успешное сопоставление ни с одним из приведенных образцов, то пойманное исключение генерируется повторно.</P>
    </SECTION>
  </PART>
  <PART>
    <HEADER>Типы данных</HEADER>
    <SECTION>
      <HEADER>Целые и вещественные числа</HEADER>
      <P>Ela поддерживает 32 и 64-битные целые числа со знаком, а также 32 и 64-битные числа с плавающей запятой (floating point numbers). Внутренние названия для этих типов, которое можно использовать, к примеру, при проверке типа с помощью оператора is, таковы: int (32-битное целое), long (64-битное целое), single (число с плавающей запятой) и double(число с плавающей запятой двойной точности):</P>
      <CODE><KEYWORD>var</KEYWORD> i = 12; <COMMENT>//int</COMMENT>
<KEYWORD>var</KEYWORD> l = 12L; <COMMENT>//long</COMMENT>
<KEYWORD>var</KEYWORD> s = 12.2; <COMMENT>//single</COMMENT>
<KEYWORD>var</KEYWORD> d = 12.2D; <COMMENT>//double</COMMENT></CODE>
      <P>При использовании этих типов данных имейте в виду, что все 32-битные числа размещаются на стеке, а все 64-битные – уже создаются в куче.</P>
    </SECTION>
    <SECTION>
      <HEADER>Строки и символы</HEADER>
      <P>Символы (char) используются для хранения одного юникодного символа и имеют внутреннее представление как 32-битное целое. Программистам C# должен быть хорошо знаком этот тип данных. Символы, так же как и 32-битные числа, создаются на стеке.</P>
      <P>Строки (string) в Ela реализованы поверх стандартного типа .NET Framework System.String и всегда имеют юникодное представление.</P>
      <CODE><KEYWORD>var</KEYWORD> c = <STRING>'a'</STRING>; <COMMENT>//char</COMMENT>
<KEYWORD>var</KEYWORD> s = <STRING>"Hello, world!"</STRING>; <COMMENT>//string</COMMENT></CODE>
      <P>Строки и символы также поддерживают эскейп-последовательности: \r (перевод каретки), \n (новая строка), \t (символ табуляции), \" (вставка кавычки), \' (вставка одинарной кавычки), \uxxxx (вставка юникодного символа) и другие.</P>
      <P>Строки в Ela могут рассматриваться как массив, поэтому к ним применимы некоторые операции, которые можно совершать с массивами. Например, в циклах for-in они неявно приводятся к типу seq (об этом см. ниже), еще вы можете обращаться к отдельным символам внутри строки через индексер. Однако, как и в .NET, строки являются неизменяемым типом данных – поэтому для изменения строки, вам необходимо создать ее новый экземпляр. Также у строк есть встроенное свойство length, которое возвращает длину строки.</P>
    </SECTION>
    <SECTION>
      <HEADER>Булевые</HEADER>
      <P>Булевые это целые числа, имеющие свой собственный литерал, которые могут принимать только два значения – true или false. Булевые – последний из примитивов Ela, который создается на стеке. </P>
      <CODE><KEYWORD>var</KEYWORD> x = <KEYWORD>true</KEYWORD>;
<KEYWORD>var</KEYWORD> y = <KEYWORD>false</KEYWORD>;</CODE>
      <P>Отличительной особенностью булевого типа в Ela является то, что в языке не поддерживаются неявные приведения других типов данных к булевому. Например, вы не можете использовать внутри условного оператора целые числа типа int.</P>
    </SECTION>
    <SECTION>
      <HEADER>Кортежи</HEADER>
      <P>Кортежи (tuple) представляют собой доступный только для чтения гетерогенный массив из двух и более элементов. Вот так вы можете объявить в Ela кортеж:</P>
      <CODE><KEYWORD>let</KEYWORD> x = (0, 1, 2);
</CODE>
      <P>С кортежами можно работать как с массивами - например, обращаться к их элементам по индексу, однако нельзя изменять элементы кортежей. У кортежей есть встроенное поле length, позволяющее узнать длину кортежа.</P>
    </SECTION>
    <SECTION>
      <HEADER>Динамические индексированные массивы</HEADER>
      <P>Индексированные массивы (array) – это те же кортежи, но только позволяющие создавать последовательность из любого количества элементов и неявляющиеся неизменяемой структурой данных. Индексированные массивы могут автоматически изменять свою длину:</P>
      <CODE><KEYWORD>let</KEYWORD> x = [| 0, 1 |];
x[2] = 2; <COMMENT>//добавление нового элемента</COMMENT></CODE>
      <P>Как видно из примера, для добавления нового элемента в массив нужно просто указать индекс для этого элемента, и размер массива будет автоматически увеличен. Подобное поведение вы можете наблюдать и у массивов в JavaScript. Однако, в отличие от JavaScript, обращение к несуществующему элементу массива приведет к ошибке.</P>
      <P>Массивы также имеют встроенное поле length, позволяющее получить длину массива.</P>
    </SECTION>
    <SECTION>
      <HEADER>Связные списки</HEADER>
      <P>Однонаправленные связные списки (list) – это неизменяемая структура данных для хранения последовательностей элементов, которая хорошо подходит для рекурсивного анализа через паттерн матчинг.</P>
      <P>Списки можно объявлять так:</P>
      <CODE><KEYWORD>let</KEYWORD> x = [0, 1, 2];
</CODE>
      <P>Списки также могут конструироваться с помощью оператора-конструтора списков «::», который является правоассоциативным. Например, вышеприведенный код полностью аналогичен нижеследующему:</P>
      <CODE><KEYWORD>let</KEYWORD> x = 0::1::2::[];
</CODE>
      <P>Оператор «::» можно использовать и для добавления элемента в начало списка, при этом добавляемый элемент должен быть в левой части выражения, а сам список – в правой. Так как списки являются неизменяемой структурой данных, то добавление нового элемента фактически приводит к созданию нового списка. </P>
      <P>Вы также можете складываться списки используя оператор «+», однако имейте в виду, что это довольно затратная по времени выполнения операция.</P>
      <P>Стандартный объект список имеет также встроенные поля length, head и tail, возвращающие, соответственно, длину, голову и хвост списка.</P>
    </SECTION>
    <SECTION>
      <HEADER>Записи</HEADER>
      <P>Записи (record) представляют собой последовательности значений, к элементам которых можно обращаться как по индексу, так и по имени:</P>
      <CODE><KEYWORD>let</KEYWORD> x = ( car: <STRING>"Nissan"</STRING>, model: <STRING>"Z"</STRING>, year: 2008 );
<KEYWORD>let</KEYWORD> year = x.year;</CODE>
      <P>Записи можно рассматривать как частные случаи массивов, у которых для каждого из элементов задан специальный псевдоним. </P>
      <P>Программистам JavaScript записи наверняка напомнят тип данных «объект», имеющий в JavaScript схожий литерал. Программисты C# могут вспомнить об анонимных типах. Главным отличием записей от объектов в JavaScript является невозможность неявного добавления нового поля – если вы попробуете обратиться к несуществующему полю (неважно, на запись или на чтение), то получите ошибку:</P>
      <CODE><KEYWORD>let</KEYWORD> x = ( car: <STRING>"Nissan"</STRING>, model: <STRING>"Z"</STRING>, year: 2008 );
<KEYWORD>let</KEYWORD> year = x.year;
<KEYWORD>let</KEYWORD> period = x.warrantyPeriod; //<COMMENT>Error ELA417: There is no such field as 'warrantyPeriod' in the target object.</COMMENT>
x.warrantyPeriod = 2; <COMMENT>//Error ELA417: There is no such field as 'warrantyPeriod' in the target object.</COMMENT></CODE>
      <P>У записей есть встроенное поле length, позволяющее узнать их длину. Анализировать записи в паттерн-матчинге можно точно так же, как массивы и кортежи.</P>
    </SECTION>
    <SECTION>
      <HEADER>Последовательности</HEADER>
      <P>Последовательности (seq) представляют собой доступные только для чтения однонаправленные последовательности элементов. Ближайшим к ним аналогом может быть курсор или же тип IEnumerator из .NET Framework. В Ela нет специального литерала для последовательностей, однако списки, кортежи, записи, строки и массивы могут к ним приводиться, что позволяет обрабатывать их в одном ключе:</P>
      <CODE><KEYWORD>for</KEYWORD> (x <KEYWORD>in</KEYWORD> [0, 1, 2])
  <KEYWORD>cout</KEYWORD> x;

<KEYWORD>for</KEYWORD> (x <KEYWORD>in</KEYWORD> [| 0, 1, 2 |])
  <KEYWORD>cout</KEYWORD> x;

<KEYWORD>for</KEYWORD> (x <KEYWORD>in</KEYWORD> <STRING>"abcdef"</STRING>)
  <KEYWORD>cout</KEYWORD> x;</CODE>
      <P>В этих примерах происходит неявное приведение массива, строки и списка к типу seq. Вы также можете явно привести массив, строку, список или кортеж к данному типу, используя оператор приведения «:&gt;». Например:</P>
      <CODE><KEYWORD>let</KEYWORD> t = (0, 1);
<KEYWORD>let</KEYWORD> seq = t :&gt; seq;</CODE>
      <P>Имейте в виду, что последовательности сохраняют свое состояние. Если вы в цикле получите первые два элемента последовательности и прервете цикл, то потом, если вы продолжите пользоваться тем же экземпляром последовательности, перебор элементов начнется сразу с третьего элемента. Когда последовательность доходит до конца, она автоматически переводится на начало. Также с помощью последовательностей в Ela могут быть представлены ленивые структуры данных (об этом см. ниже).</P>
    </SECTION>
    <SECTION>
      <HEADER>Функции</HEADER>
      <P>Функции являются самым важным типом данных в Ela. Прежде всего, функции в Ela являются первоклассными объектами, т.е. Ela поддерживает first-class functions, а это значит, что вы можете совершать с функциями те же самые операции, что и с любыми другими значениями. Основной синтаксис для объявления фукнций очень похож на синтаксис для лямбд в C# 3.0:</P>
      <CODE>x -&gt; x % 2</CODE>
      <P>Приведенная выше функция принимает один параметр x и возвращает остаток при делении этого параметра на 2. Это пример так называемой анонимной функции – анонимной просто в силу того, что, как вы видите, ни с каким именем эта функция не связывается. Как объявить «неанонимную» функцию? Очевидно, что надо просто произвести связывание функции с именем. Например:</P>
      <CODE><KEYWORD>let</KEYWORD> func = x -&gt; x % 2
</CODE>
      <WARNING>
        <P>Всегда старайтесь связывать функции с неизменяемыми именами, используя ключевое слово let. В противном случае будет недоступна часть оптимизаций, как например, оптимизация хвостовой рекурсии.</P>
      </WARNING>
      <P>Однако подобная запись уже не отличается изяществом. Поэтому для удобства был введен специальный синтаксис, который может быть использован в тех случаях, когда вам нужны неанонимные функции. Так, вышеприведенный пример можно переписать таким образом:</P>
      <CODE><PREPROCESSOR>let</PREPROCESSOR> func(x) x % 2;
</CODE>
      <P>Два этих примера полностью равносильны.</P>
      <P>Параметры функций являются в Ela неизменяемыми, поэтому такой код приведет к ошибке:</P>
      <CODE><KEYWORD>let</KEYWORD> f(x) x++; <COMMENT>//Error ELA213: Unable to change a value of an immutable variable 'x'.</COMMENT>
</CODE>
      <P>К тому же, как вы могли заметить, в функциях для возвращения значения не требуется ключевое слово return. Принцип прост – самое последнее выражение в функции возвращает значение. Если телом функции является блок, объявленный через фигурные скобки, то возвращать значение будет самое последнее выражение в этом блоке, и пр. Однако Ela поддерживает и оператор return, возвращающий значение в сочетании с принудительным выходом из функции. Единственное отличие return от того же C# или JavaScript в том, что после ключевого return обязательно должно идти выражение. Да, и конечно же, все функции в Ela всегда возвращают какое-либо значение, однако иногда это может быть значение типа unit.</P>
      <P>Любая функция в Ela замыкается на родительский контекст, т.е. внутри функции вы можете использовать имена, объявленные во внешнем блоке:</P>
      <CODE><KEYWORD>let</KEYWORD> msg = <STRING>"value is "</STRING>;
<KEYWORD>let</KEYWORD> func(x) msg + x :&gt; string;</CODE>
      <P>В данном примере функция «func» захватывает переменную «msg», приводит параметр «x» к строке, используя оператор приведения «:&gt;», производит конкатенацию строк и возвращает результат.</P>
      <P>Функции можно также объявлять с помощью механизма частичного применения. Предположим, что у нас есть функция «sum», складывающая два значения:</P>
      <CODE><KEYWORD>let</KEYWORD> sum(x, y) x + y;
</CODE>
      <P>Мы можем создать новую функцию на основе функции «sum», которая будет работать для одного значения:</P>
      <CODE><KEYWORD>let</KEYWORD> sum2 = sum(_, 2);
</CODE>
      <P>Функция «sum2» принимает уже один-единственный параметр и складывает все числа со значением 2.</P>
      <P>С помощью частичного применения в качестве функций можно также использовать и операторы языка:</P>
      <CODE><KEYWORD>let</KEYWORD> reduce(seq, fun) {
  <KEYWORD>var</KEYWORD> el = ();
  <KEYWORD>for</KEYWORD> (e <KEYWORD>in</KEYWORD> seq) {
    <KEYWORD>if</KEYWORD> (el <KEYWORD>is</KEYWORD> unit)
      el = e;
    <KEYWORD>else </KEYWORD>
      el = fun(el, e);    
  }  
  el
}

reduce([0, 1, 2, 3, 4], _ + _);</CODE>
      <P>Данный пример реализует классическую функцию высшего порядка «reduce», которая благодаря использованию типа данных seq, может работать как со списками, так и с массивами. Функция «reduce» принимает в качестве параметре другую функцию для двух аргументов («fun»), которая вызывается для всех элементов последовательности – сначала для первого и второго, затем для своего предыдущего результата и для третьего элемента и пр. В качестве функции в примере используется обычный оператор сложения, который превращен в функцию для двух аргументов, используя специальный оператор «_».</P>
      <P>При работе с функциями можно использовать операторы forward pipe («|&gt;») и backward pipe («&lt;|»), которые могут быть знакомы некоторым по языку F#. К примеру, представим, что у нас есть такой код:</P>
      <CODE><KEYWORD>let</KEYWORD> calc(x, y) x + y; <COMMENT>//сначала вычисляем</COMMENT>
<KEYWORD>let</KEYWORD> check(x) <KEYWORD>if</KEYWORD> (x &gt; 0) x <KEYWORD>else</KEYWORD> 0; //<COMMENT>вторым шагом делаем проверку</COMMENT>
<KEYWORD>let</KEYWORD> print(x) <KEYWORD>cout</KEYWORD> <STRING>"The result is "</STRING> + x :&gt; string; <COMMENT>//и наконец выводим результат</COMMENT>

<KEYWORD>let</KEYWORD> res = calc(2, 2);
<KEYWORD>let</KEYWORD> res2 = check(res);
print(res2);</CODE>
      <P>Как видите, для вызова этих функций мне пришлось объявить две промежуточные переменные, и код получился весьма длинным. Можно сократить запись таким образом:</P>
      <CODE>print(check(calc(2, 2)));</CODE>
      <P>Однако в таком случае пострадает читабельность кода. Forward pipe оператор позволит нам сохранить читабельность и лаконичность, причем читабельность будет даже выше, чем в первом случае:</P>
      <CODE>calc(2, 2) |&gt; check |&gt; print;</CODE>
      <P>С помощью backward pipe этот же код можно записать так:</P>
      <CODE>print &lt;| check &lt;| calc(2, 2);</CODE>
      <P>Однако в тех случаях, когда вам требуется часто вызывать одну и ту же цепочку функций, даже использование pipe-операторов приведет к дублированию кода. В таких случаях вы можете использовать операторы для композиции функций – forward composition («&gt;&gt;&gt;») и backward composition («&lt;&lt;&lt;»).</P>
      <P>Например, так можно записать наш пример с использованием forward composition:</P>
      <CODE><KEYWORD>let</KEYWORD> f = calc &gt;&gt;&gt; check &gt;&gt;&gt; print;
f(2, 2);</CODE>
      <P>Аналогично с использованием backward composition:</P>
      <CODE><KEYWORD>let</KEYWORD> f = print &lt;&lt;&lt; check &lt;&lt;&lt; calc;
f(2, 2);</CODE>
      <P>Имейте в виду, что в данном случае вы по сути создаете новую функцию, связанную с именем «f», которую можно многократно использовать.</P>
      <P>Еще один немаловажный момент, о котором стоит упомянуть касательно функций, это рекурсия. В Ela любая функция может быть рекурсивной, однако настоятельно рекомендуется не создавать анонимные рекурсивные функции или объявлять рекурсивные функции, используя ключевое слово var.</P>
      <P>Например, цикл вида:</P>
      <CODE><PREPROCESSOR>var</PREPROCESSOR> x = 0;

<PREPROCESSOR>while</PREPROCESSOR> (x &lt; 10) {
  <PREPROCESSOR>cout</PREPROCESSOR> x;
  x++;
}</CODE>
      <P>Может быть переписан через рекурсивную функцию (и при этом отпадет необходимость в изменяемой переменной):</P>
      <CODE><KEYWORD>let</KEYWORD> rec(x) {
  <KEYWORD>cout</KEYWORD> x;
  <KEYWORD>when</KEYWORD> (x &lt; 10) 
    rec (x + 1);
}</CODE>
      <P>Как видите, функция «rec» захватила собственное имя «rec», объявленное в родительском контексте и использует его для того, чтобы вызвать саму себя.</P>
      <P>В данном примере вы можете наблюдать и другой интересный момент, а именно хвостовую рекурсию. Хвостовая рекурсия – это вызов функцией самой себя, который является последней инструкцией в теле функции. Ela умеет оптимизировать хвостовую рекурсию. Благодаря этому, в вышеприведенном примере рекурсивный вызов будет убран и заменен на обычный условный переход. Фактически по логике исполнения пример с функцией полностью аналогичен примеру с циклом. </P>
      <P>Однако не забывайте, что, как уже упоминалось ранее, хвостовая рекурсия будет оптимизироваться только для функций, объявленных через ключевое слово let.</P>
    </SECTION>
    <SECTION>
      <HEADER>Полиморфные варианты</HEADER>
      <P>Эти типы данных схожим с теми, которые поддерживаются в языке OCaml. Если вы знакомы с концепцией алгребраических типов, то также найдете здесь немало общего. В отличие от алгребраических типов, полиморфные варианты не требуют предварительного объявления, можно сказать, что в вашей программе есть один-единственный алгебраический тип, конструкторы которого автоматически объявляются по первому месту использования:</P>
      <CODE><KEYWORD>let</KEYWORD> x = `Some(2);
</CODE>
      <P>Полиморфный вариант можно рассматривать как кортеж (или запись), создаваемый с помощью специального конструктора, имя которого начинается с апострофа. Вы можете также создать «пустой» полиморфный вариант, не хранящий в себе никаких значений:</P>
      <CODE><KEYWORD>let</KEYWORD> y = `None;
</CODE>
      <P>В таком случае круглые скобки можно опускать. </P>
      <P>Полиморфные варианты довольно удобно использовать в сочетании с другой возможностью языка – паттерн-матчингом.</P>
      <P>Имейте в виду, что, хотя создание полиморфного варианта похоже на вызов функции, конструктор варианта – это совсем не функция и не обладает особенностями функции (например, не является первоклассным объектом). Конструктор варианта стоит рассматривать скорее как специальный литерал.</P>
      <P>Ela автоматически генерирует конструкторы для вариантов по первому месту их использования. Например:</P>
      <CODE><KEYWORD>let</KEYWORD> x = `Some(1); <COMMENT>//создается новый конструктор `Some</COMMENT>
<KEYWORD>let</KEYWORD> y = `Some(2); <COMMENT>//используется ранее созданный конструктор `Some</COMMENT>
<KEYWORD>let</KEYWORD> z = `Some(1, 2); <COMMENT>//создается новый конструктор `Some для кортежа из двух элементов</COMMENT></CODE>
      <P>Однако автоматически генерируемые конструкторы несколько ограничены в своих возможностях. К примеру, вы всегда должны явно указать все элементы варианта, не можете инкапсулировать какую-либо логику его инициализации и можете создавать в качестве полиморфных вариантов только неизменяемые кортежи.</P>
      <P>По этой причине в Ela была введена дополнительная возможность – пользовательские конструкторы для вариантов. Синтаксис объявления пользовательских конструкторов похож на синтаксис объявления функций, однако их название должно начинаться с апострофа:</P>
      <CODE><KEYWORD>let</KEYWORD> `Some(x, y) (x, y);
</CODE>
      <P>Также конструкторы можно объявлять только используя ключевое слово let, использование ключевого слова var приведет к ошибке компиляции. Наконец, в отличие от функций, телом конструктора может быть исключительно литерал кортежа или записи. Вышепривиденный пример показывает как можно описать простейший конструктор `Some для аргументов «x» и «y», создающий кортеж из двух элементов.</P>
      <P>Опять-таки – пользовательские конструкторы не являются функциями, вы не можете вызывать их как функции, более того, все конструкторы находятся в отдельном пространстве имен, и у вас могут быть функции, совпадающие с ними по имени. Наконец, допустимо объявление нескольких конструкторов с одним именем и разным количеством аргументов (что не является допустимым в случае с обычными функциями). Повторное объявление конструктора с уже используемым именем и количеством аргументов также не приведет к ошибке, а вызовет затенение предыдущего конструктора – независимо от того, был ли этот констуктор описан явно или же сгенерирован автоматически.</P>
      <P>Например:</P>
      <CODE><KEYWORD>let</KEYWORD> x = `Some(1); <COMMENT>//создается новый конструктор</COMMENT>
<KEYWORD>let</KEYWORD> y = `Some(2); <COMMENT>//используется существующий авто-сгенерированный конструктор</COMMENT>
<KEYWORD>let</KEYWORD> Some(x) x + 1; <COMMENT>//пример обычной функции</COMMENT>
<KEYWORD>let</KEYWORD> `Some(x) (x, x * 2); <COMMENT>//создается пользовательский конструктор, затеняющий предыдущий</COMMENT>
<KEYWORD>let</KEYWORD> z = `Some(3); <COMMENT>//используется пользовательский конструктор</COMMENT>

<KEYWORD>cout</KEYWORD> x;
<KEYWORD>cout</KEYWORD> z;</CODE>
      <P>Данный код выведет на консоль:</P>
      <CODE>(&gt;Some 1)
(&gt;Some 3,6)</CODE>
      <P>Также с помощью пользовательских конструкторов вы можете создавать полиморфные варианты на основе записей. Например:</P>
      <CODE><KEYWORD>let</KEYWORD> `Some(x) ( val: x, toString: () -&gt; x :&gt; string );
<KEYWORD>let</KEYWORD> x = `Some(2);
<KEYWORD>cout</KEYWORD> x.toString();</CODE>
    </SECTION>
    <SECTION>
      <HEADER>Ленивые значения</HEADER>
      <P>Ленивые значения (lazy) используются при отложенных и асинхронных вычислениях. Для того, чтобы получить значения типа lazy вы должны воспользоваться операторами lazy или async. Например:</P>
      <CODE><KEYWORD>let</KEYWORD> x = <KEYWORD>lazy</KEYWORD> 2 + 2;
<KEYWORD>let</KEYWORD> y = <KEYWORD>async</KEYWORD> 2 + 2;</CODE>
      <P>В первом случае выражение, следующее после lazy не вычисляется до тех пор, пока оно вам не потребуется. Во втором - вычисление запускается сразу же, однако в отдельном потоке, а имя «y» связывается со специальным объектом типа lazy, значение в который будет записано после завершения потока (это удобно, если какое-то действие занимает много времени, например, вы ждете ответа по сети, и вам при этом не хочется блокировать работу всего приложения).</P>
      <P>Тип lazy сам по себе нельзя использовать в каких-либо операциях, например следующий код приведет к ошибке:</P>
      <CODE><KEYWORD>let</KEYWORD> x = <KEYWORD>lazy</KEYWORD> 2 + 2;
x + 2 <COMMENT>//Error ELA409: Unable to perform operation '+' on types 'lazy' and 'int'</COMMENT></CODE>
      <P>Для получения значения в Ela используется специальный оператор получить значение – «&amp;». Например, чтобы сделать предыдущий пример рабочим, надо переписать его так:</P>
      <CODE><KEYWORD>let</KEYWORD> x = <KEYWORD>lazy</KEYWORD> 2 + 2;
&amp;x + 2</CODE>
      <P>В этом случае происходит вычисление выражения, объявленного с использованием оператора lazy.</P>
      <P>Аналогично и с асинхронными значениями – но в их случае операция получения значения приведет к блокировке вызывающего потока до тех пор, пока не завершится асинхронное вычисление.</P>
      <P>Раз полученное значение повторно не вычисляется – поэтому вы можете использовать оператор «&amp;» несколько раз для одних и тех же значений.</P>
    </SECTION>
    <SECTION>
      <HEADER>Модули</HEADER>
      <P>Модуль (module) – это любой исполнимый файл на Ela, при этом названием модуля является по умолчанию название файла. Для того, чтобы открыть существующий модуль, нужно использовать конструкцию open. Предположим, что мы создали файл «Calc.ela» с таким вот кодом:</P>
      <CODE><KEYWORD>let</KEYWORD> add(x, y) x + y;
<KEYWORD>let</KEYWORD> sub(x, y) x – y;</CODE>
      <P>Открыть данный модуль можно используя конструкцию open:</P>
      <CODE><KEYWORD>open</KEYWORD> Calc;
<KEYWORD>cout</KEYWORD> Calc.add(2, 2);</CODE>
      <NOTE>
        <P>В отличие от обычных функций пользовательские операторы, объявленные во внешнем модуле, могут быть использованы сразу, без необходимости указывать имя модуля перед названием оператора. Если вы подключаете два модуля, в которых объявлены одинаковые операторы, то последний подключенный модуль произведен затенение ранее объявленного оператора.</P>
      </NOTE>
      <P>Если вам не хочется всегда явно указывать название модулей или же вы собираетесь часто обращаться к именам объявленным в другом модуле, имеет смысл явно импортировать те или иные имена из модуля. Делается это с помощью конструкции with:</P>
      <CODE><KEYWORD>open</KEYWORD> Calc <KEYWORD>with</KEYWORD> add;
<KEYWORD>cout</KEYWORD> add(2, 2);</CODE>
      <P>Вы также можете задать локальный на уровне вашего модуля псевдоним для имени:</P>
      <CODE><KEYWORD>open</KEYWORD> Calc <KEYWORD>with</KEYWORD> sum = add, minus = sub;
<KEYWORD>cout</KEYWORD> sum(2, 2) + minus(2, 2);</CODE>
      <P>Псевдоним можно задавать и для модулей, если вы хотите избежать конфликтов имен или же оригинальное название модуля слишком длинное:</P>
      <CODE><KEYWORD>open</KEYWORD> MyLongModuleName <KEYWORD>as</KEYWORD> Calc;
</CODE>
      <P>Наконец, так как Ela позволяет реализовывать модули не только на самой себе, но и на .NET, вы можете указать из какой сборки нужно загружать модуль. Делается это так:</P>
      <CODE><KEYWORD>open</KEYWORD> Collection[elalib];
</CODE>
      <P>В данном примере «elalib» – это название сборки, реализованной на языке C#, в которой объявлен атрибут ElaForeignModuleAttribute, содержащий информацию об имени модуля («Collection») и реализующем его типе.</P>
      <P>Вы, наверное, удивляетесь, почему описание модулей делается в секции, посвященной типам данных. Но дело в том, что наиболее интересная особенность модулей заключается в том, что модули являются первоклассными объектами – т.е. вы, к примеру, можете передать модуль в функцию как любое другое значение. Например, у нас есть модуль «List», который содержит одну-единственную функцию:</P>
      <CODE><KEYWORD>let</KEYWORD> head(list) 
  <KEYWORD>on</KEYWORD> x::_ -&gt; `Some(x) <KEYWORD>on</KEYWORD> [] -&gt; `None;</CODE>
      <P>Данная функция возвращает вариант `Some с головой списка, если переданный в нее список не является пустым, и вариант `None, если список пуст. Вот как вы можете использовать данную функцию из другого модуля:</P>
      <CODE><COMMENT>//открываем и исполняем модуль List (в файле List.ela)</COMMENT>
<KEYWORD>open</KEYWORD> List;

<COMMENT>//объявляем функцию func, которая в качестве аргумента принимает некий объект</COMMENT>
<COMMENT>//и вызывает у него функцию head</COMMENT>
<KEYWORD>let</KEYWORD> func(mod, list) mod.head(list);

<COMMENT>//передаем в функцию наш модуль в качестве объекта</COMMENT>
func(List, [1, 2, 3]);</CODE>
      <P>Результатом работы этого кода будет `Some(1).</P>
    </SECTION>
    <SECTION>
      <HEADER>Тип Unit</HEADER>
      <P>Тип unit более знаком некоторым программистам как void. Тип unit - это фактически пустой кортеж, экземпляр которого является единственным для всего вашего приложения:</P>
      <CODE><KEYWORD>let</KEYWORD> x = ();
</CODE>
      <P>Вы можете использовать unit так же, как и любой другой тип данных – его можно возвращать из функцию, присваивать переменной и пр. Имейте в виду, что в Ela, в отличие от C#, отсутствует null, поэтому на плечи unit ложится также и его роль.</P>
    </SECTION>
  </PART>
  <PART>
    <HEADER>Паттерн-матчинг</HEADER>
    <SECTION>
      <HEADER>Общая информация</HEADER>
      <P>Паттерн-матчинг – это одна из главных возможностей Ela. Реализация паттерн-матчинга в Ela достаточно близка к тому, что вы можете увидеть в таких языках как OCaml, F#, Scala, Nemerle, однако Ela – это динамический язык, и данный факт вносит ряд своих особенностей.</P>
      <P>Для тех, кто не знаком с концепцией паттерн-матчинга, можно сначала почитать о его реализациях в F# или Nemerle. В Ela вы найдете немало общего с этими языками. Вкратце, паттерн-матчинг – это языковая возможность для сравнительного разбора выражений. Любой код с использованием паттерн-матчинга можно «преобразовать» в цепочку из условных операторов – паттерн-матчинг позволяет делать то же самое, но с большим уровнем декларативности. Например, такой вот код:</P>
      <CODE><KEYWORD>let</KEYWORD> result = <KEYWORD>match</KEYWORD> (arr)
  <KEYWORD>on</KEYWORD> [| x, y, z |] -&gt; x + y + z
  <KEYWORD>on</KEYWORD> _ -&gt; 0</CODE>
      <P>равносилен такому:</P>
      <CODE><KEYWORD>let</KEYWORD> result = 0;

<KEYWORD>when</KEYWORD> (arr.length == 3) 
    result = arr[0] + arr[1] + arr[2];</CODE>
      <P>Как вы уже заметили, конструкция для паттерн-матчинга объявляется с помощью ключевого слова match, в скобках следует выражение, которое нужно подвергнуть разбору, а за ним – вхождения match-а или образцы. Фигурные скобки вокруг тела match-a не требуются. В целом данная синтаксис данной конструкция напоминает switch из С-подобных языков, однако match является куда более мощным механизмом. </P>
      <P>В следующей секции перечислены образцы, которые поддерживает Ela.</P>
    </SECTION>
    <SECTION>
      <HEADER>Образцы</HEADER>
      <SUBSECTION>
        <HEADER>Образец «Или»</HEADER>
        <P>Данный образец состоит из двух вложенных образцов. Сопоставление считается успешным в том случае, если первый или второй образец проходят сопоставление:</P>
        <CODE><KEYWORD>on</KEYWORD> 2 || 3 -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «И»</HEADER>
        <P>Данный образец состоит из двух вложенных образцов. Сопоставление считается успешным в том случае, если первый и второй образец проходят сопоставление:</P>
        <CODE><KEYWORD>on</KEYWORD> 2 &amp;&amp; 3 -&gt; ...
</CODE>
        <P>Имейте в виду, что как и в случае аналогичных бинарных операторов, приоритет образца «И» выше, чем приоритет образца «Или».</P>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «as»</HEADER>
        <P>Сопоставление с данным образцом всегда проходит успешно. Образец «as» связывает все выражение с заданным именем. В указанном примере список разбирается на элементы голова и хвост, которые связываются с именами x и xs, а весь экземпляр списка связывается с именем list.</P>
        <CODE><KEYWORD>on</KEYWORD> x::xs <KEYWORD>as</KEYWORD> list -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Литерал»</HEADER>
        <P>Данный образец сравнивает выражение с литералами примитивных типов – 32 и 64 битных целых, 32 и 64 битных вещественных чисел, строк, символов и булевых.</P>
        <CODE><KEYWORD>on</KEYWORD> 22 -&gt; ...
<KEYWORD>on</KEYWORD> <STRING>"string"</STRING> -&gt; ...
<KEYWORD>on</KEYWORD> <KEYWORD>true</KEYWORD> -&gt; ...</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «unit»</HEADER>
        <P>Данный образец сравнивает выражение с экземпляром типа unit. Образец считается успешным, если сопоставляемое выражение является unit-ом. Данный образец равносилен проверка типа выражения: x is unit</P>
        <CODE><KEYWORD>on</KEYWORD> () -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «is»</HEADER>
        <P>Данный образец проверяет тип выражения. Если слева указывается имя, то происходит связывание этого имени со значением разбираемого выражения. В Ela поддерживаются следующие типы: int, long, single, double, bool, char, string, list, array, tuple, record, unit, seq, lazy и function. Сопоставление происходит успешно, если тип разбираемого выражения соответствует указанному.</P>
        <CODE><KEYWORD>on</KEYWORD> <KEYWORD>is</KEYWORD> <KEYWORD>int</KEYWORD> -&gt; ...
<KEYWORD>on</KEYWORD> x <KEYWORD>is</KEYWORD> <KEYWORD>long</KEYWORD> -&gt; ...</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Переменная»</HEADER>
        <P>Данный образец производит связывание выражения с указанным именем. Этот образец всегда выполняется успешно, т.е. если он у вас является образцом верхнего уровня и находится в начале или середине match-a, то все последующие вхождения match-а будут проигнорированы.</P>
        <CODE><KEYWORD>on</KEYWORD> x -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Любое значение»</HEADER>
        <P>Данный образец ведет себя так же, как и образец «Переменная», с тем отличием, что связывания с переменной не происходит, и значение разбираемого выражения попросту игнорируется. Если этот образец является образцом верхнего уровня, то он обязательно должен идти в конце match-a – в противном случае, все остальные вхождения match-a будут проигнорированы.</P>
        <CODE><KEYWORD>on</KEYWORD> _ -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Кортеж»</HEADER>
        <P>Данный образец используется для разбора кортежей, записей и массивов. Сопоставление происходит успешно, если разбираемое выражение является записью, кортежем или массивом, длина которого точно соответствует указанному в образце количеству элементов.</P>
        <CODE><KEYWORD>on</KEYWORD> x, y, z -&gt; ...
<KEYWORD>on</KEYWORD> (x, 2, 3) -&gt; ...</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Массив»</HEADER>
        <P>Данный образец ведет себя аналогично образцу «Кортеж», но производит дополнительную проверку типа и может быть использован только для разбора массивов. Длина массива должна точно соответствовать указанному в образце количеству элементов.</P>
        <CODE><KEYWORD>on</KEYWORD> [| x, y, z |] -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Список»</HEADER>
        <P>Этот образец аналогичен образцу «Массив», но используется только для разбора связных список. Длина связного списка должна точно соответствовать указанному в образце количеству элементов. Образец вида «[ ]» сопоставляется с пустым списком.</P>
        <CODE><KEYWORD>on</KEYWORD> [x, y, z] -&gt; ...
<KEYWORD>on</KEYWORD> [] -&gt; ...</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Голова-хвост»</HEADER>
        <P>Данный образец используется для разбора списка в том случае, если нам не известно общее количество элементов в списке. Образец выполняется успешно, если разбираемое выражение – список, который содержит как минимум один элемент. При этом первые элементы образца будут связаны с отдельными элементами списка, а последний – с остатком списка. В качестве остатка может также выступать и пустой список.</P>
        <CODE><KEYWORD>on</KEYWORD> x::xs -&gt; ...
<KEYWORD>on</KEYWORD> x::2::(x2,y2)::y::xs -&gt; ...</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Вариант»</HEADER>
        <P>Этот образец используется для сопоставления с полиморфными вариантами, т.е. с кортежами или записями, который были созданы с помощью специального конструктора полиморфных вариантов. Если вы опускаете круглые скобки после названия конструктора, то образец будет выполнен успешно если название указанного в нем конструктора совпадает с названием конструктора разбираемого выражения, независимо от количества элементов в кортеже варианта. Если вы указываете круглые скобки, то для успешного совпадения должны быть перечислены все элементы варианта. Образец вида `Tagname() производит сопоставление с «пустым» вариантом.</P>
        <CODE><KEYWORD>on</KEYWORD> `Some(x) -&gt; ...
<KEYWORD>on</KEYWORD> `Some -&gt; ...</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Любой вариант»</HEADER>
        <P>Данный образец аналогичен образцу «Кортеж», но производит дополнительную проверку того, что разбираемое выражение является кортежем или записью и несет в себе информацию о конструкторе и может быть использован только для разрабора вариантов, при этом название конструктора игнорируется. Длина варианта должна точно соответствовать указанному в образце количеству элементов.</P>
        <CODE><KEYWORD>on</KEYWORD> `(x) -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Поле»</HEADER>
        <P>Данный образец используется для разбора любых типов данных по полям и для связывания полей с переменными или же для сравнения полей с заданными значениями. Если в выражении отсутствует указанное поле, то проверка считается неудачной, однако исключение не генерируется. </P>
        <CODE><KEYWORD>on</KEYWORD> (Name = x, Age = 30) -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Структура»</HEADER>
        <P>Данный образец аналогичен образцу «Поле», но не производит связывания или сравнения полей, а просто проверяет, что в разбираемом объекте присутствуют указанные поля.</P>
        <CODE><KEYWORD>on</KEYWORD> (:Name,:Age) -&gt; ...
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Взять значение»</HEADER>
        <P>Данный образец позволяет сравнить значение разбираемого выражения не с литералом, а со значением переменной, которая может быть объявлена в родительском блоке. При этом значением может выступать как «обычный» тип, так и тип lazy – в последнем случае прозойдет его вычисление:</P>
        <CODE><KEYWORD>on</KEYWORD> &amp;x -&gt; …
</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Образец «Сравнение»</HEADER>
        <P>Данный образец позволяет использовать один из бинарных операторов сравнения («==», «!=», «&gt;», «&gt;=», «&lt;» или «&lt;=»). Вы можете производить сравнение с литералами или образцами «Взять значение», причем если в правой части образца указать имя, то будет произведено связывание разбираемого значение с этим именем. При желании имя справа можно опускать.</P>
        <CODE><KEYWORD>on</KEYWORD> [&gt; 0, &lt; 2, &gt;= 10] -&gt; …
<KEYWORD>on</KEYWORD> x != &amp;y -&gt; …</CODE>
      </SUBSECTION>
    </SECTION>
    <SECTION>
      <HEADER>Конструкции для паттерн-матчинга</HEADER>
      <SUBSECTION>
        <HEADER>Match</HEADER>
        <P>Основная конструкция для паттерн-матчинга – выражение match. Образцы в ней могут быть вложенными. Причем каждое вхождение match-а создает свой лексический блок, поэтому имена переменных в разных вхождениях могут совпадать. Если при выполнении match-а не произошло успешное совопоставление ни с одним образцом, то будет сгенерировано исключение.</P>
        <P>Match так же поддерживает гварды:</P>
        <CODE><KEYWORD>on</KEYWORD> x::xs <KEYWORD>when</KEYWORD> (x &gt; 2) -&gt; ...
</CODE>
        <P>В данном случае связывание списка с именами «x» и «xs» произойдет только в том случае, если первый элемент списка больше 2.</P>
        <P>Если все тело функции состоит из одного match-а, то самое объявление match можно опустить:</P>
        <CODE><KEYWORD>let</KEYWORD> tail(list)
<KEYWORD>on</KEYWORD> _::xs -&gt; `Some(xs)
    <KEYWORD>on</KEYWORD> [] -&gt; `None;</CODE>
        <P>Также сокращенную форму для паттерн-матчинга поддерживает и конструкция для обработки исключений try/catch, что уже было показано в соответствующем разделе.</P>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Is</HEADER>
        <P>Синтаксис оператора is похож на синтаксис аналогичного оператора C#, однако в C# он используется только для проверки типа. В Ela он может использоваться как для проверки типа (ведь для этого есть специальный образец), так и для других образцов. Если сопоставление происходит успешно, то оператор возвращает true, если нет – то false.</P>
        <P>Например:</P>
        <CODE>x <KEYWORD>is</KEYWORD> int;  
x <KEYWORD>is</KEYWORD> [0, 1, 2, 3];  
x <KEYWORD>is</KEYWORD> `Some(y);</CODE>
        <P>Корректным является и такой код:</P>
        <CODE>99 + 1 <KEYWORD>is</KEYWORD> 100;
</CODE>
        <P>И, в отличие от некоторых языков, его результатом будет true.</P>
        <P>Оператор is позволяет использовать следующие паттерны – собственно образец «is», или проверку типа, при этом достаточно просто указать название типа, как в примере выше; образец «Литерал», образец «Вариант», образец «Любой вариант», образец «Список» и образец «Массив». Вы также можете использовать и другие образцы, однако их нужно помещать в круглые скобки. Например:</P>
        <CODE>x <KEYWORD>is</KEYWORD> (h::t)
x <KEYWORD>is</KEYWORD> (0, 1, 2)
x <KEYWORD>is</KEYWORD> ([0,1,2] || [3, 4, 5])</CODE>
        <P>Имейте в виду, что, опять же в отличие от С#, оператор is задает свой лексический блок, поэтому такой код приведет к ошибке:</P>
        <CODE>x <KEYWORD>is</KEYWORD> (h::ht);
<KEYWORD>cout</KEYWORD> ht; <COMMENT>//Error ELA208: Undefined variable ‘ht’</COMMENT></CODE>
        <P>Однако такой код будет полностью корректным:</P>
        <CODE><KEYWORD>when</KEYWORD> (x <KEYWORD>is</KEYWORD> (h::ht))
<KEYWORD>  cout</KEYWORD> ht;</CODE>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>Let и Var</HEADER>
        <P>Аналогично паттерн-матчинг можно использовать и при связывании значения с именем, используя конструкции let или var:</P>
        <CODE><KEYWORD>let</KEYWORD> func() (0, 1);
<KEYWORD>let</KEYWORD> (0, y) = func();
<KEYWORD>let</KEYWORD> x::xs = [0, 1, 2];</CODE>
        <P>Данная конструкция позволяет использовать образцы «Переменная», «Список» и «Массив», а также и другие образцы, которые уже нужно помещать в круглые скобки:</P>
        <CODE><KEYWORD>let</KEYWORD> (firstName = x, lastName = y) = (firstName: <STRING>"John"</STRING>, lastName: <STRING>"Smith"</STRING>);
</CODE>
        <P>При использовании паттерн-мачтинга в выражениях связывания значений с именем стоит быть осторожным – если сопоставление не происходит успешно, то будет сгенерировано исключение.</P>
      </SUBSECTION>
      <SUBSECTION>
        <HEADER>For</HEADER>
        <P>Как уже упоминалось, паттерн-матчинг можно использовать в циклах for-in (при этом циклы for-to и for-downto поддерживают только гварды). Например:</P>
        <CODE><KEYWORD>let</KEYWORD> list = [ [0,1], [0,2], [0,3] ];

<KEYWORD>for</KEYWORD> ([0,x] <KEYWORD>in</KEYWORD> list) 
<KEYWORD>  cout</KEYWORD> x;</CODE>
        <P>Паттерн-матчинг в циклах for-in позволяет использовать следующие образцы: «Переменная», «Литерал», «Вариант», «Любой вариант», «Список», «Массив», а также и другие образцы уже нужно помещать в круглые скобки:</P>
        <CODE><KEYWORD>for</KEYWORD> ((0::xs) <KEYWORD>in</KEYWORD> list)
<KEYWORD>  cout</KEYWORD> xs;</CODE>
        <P>Вы также можете комбинировать паттерн-матчинг с гвардами:</P>
        <CODE><KEYWORD>for</KEYWORD> ((0::x::xs) <KEYWORD>when</KEYWORD> (x &gt; 0) <KEYWORD>in</KEYWORD> list)
<KEYWORD>  cout</KEYWORD> xs;</CODE>
        <P>Если сопоставления с образцом не происходит, то код внутри блока for-in не выполняется. Допустим, если в вышеприведенном примере ни один их элементов списка не начинаются с 0, то код «cout xs» никогда не будет выполнен.</P>
      </SUBSECTION>
    </SECTION>
  </PART>
  <PART>
    <HEADER>И еще несколько полезных вещей</HEADER>
    <SECTION>
      <HEADER>Comprehension</HEADER>
      <P>Непереводимый на русский язык термин сomprehension используется в ряде языков для обозначения конструкций, используемых для формирования списков или массивов. В языках вроде Haskell и Nemerle синтаксис для comprehension соответствует математической set builder нотации. Ela же пошла другим путем – в ней отсутствует специальный синтаксис для comprehension, однако вместо него можно использовать обычные циклы. </P>
      <P>Вернемся к разделу, где описываются циклы. К примеру, такой цикл может быть использован для вывода элементов в консоль:</P>
      <CODE><KEYWORD>for</KEYWORD> (x <KEYWORD>to</KEYWORD> 10) 
  <KEYWORD>cout</KEYWORD> x;</CODE>
      <P>Как его превратить в list comprehension? Достаточно написать по краям квадратные скобки:</P>
      <CODE>[ <KEYWORD>for</KEYWORD> (x <KEYWORD>to</KEYWORD> 10) x ]
</CODE>
      <P>Аналогично array comprehension:</P>
      <CODE>[| <KEYWORD>for</KEYWORD> (x <KEYWORD>to</KEYWORD> 10) x |]
</CODE>
      <P>При этом, как вы помните, циклы поддерживают паттерн-матчинг и гварды, а также могут быть вложенными, поэтому мы имеем все возможности comprehension, не вводя в язык новых синтаксических конструкций:</P>
      <CODE>[ 
  <KEYWORD>for</KEYWORD> (x <KEYWORD>when</KEYWORD> x % 2 == 0 <KEYWORD>to</KEYWORD> 10) 
    <KEYWORD>for</KEYWORD> (y = 10 <KEYWORD>when</KEYWORD> y % 2 != 0 <KEYWORD>downto</KEYWORD> 0) 
         (x, y)
]</CODE>
      <P>Подобный подход схож с тем, который используется в языке F#.</P>
    </SECTION>
    <SECTION>
      <HEADER>Генераторы</HEADER>
      <P>Генераторы – это специальные функции, которые, в отличие от обычных функций, могут возвращать значение несколько раз. Большинству .NET программистов концепция генераторов больше знакома по итераторам, которые появились в C# 2.0. Ela использует сходный синтаксис:</P>
      <CODE><KEYWORD>let</KEYWORD> gen() <KEYWORD>for</KEYWORD> (x <KEYWORD>to</KEYWORD> 10) <KEYWORD>yield</KEYWORD> x;
<KEYWORD>let</KEYWORD> seq = gen();</CODE>
      <P>Функция «gen» – это генератор. Результатом выполнения данной функции является объект типа seq (который описывался выше). </P>
      <P>Ela автоматически распознает, что функция является генератором, если хоть раз в теле функции встречается ключевое слово yield. Имейте в виду, что никакого другого способа вернуть из генератора значение, кроме как использовать оператор yield, нет. К примеру, использование обычного return приведет к ошибке компиляции.</P>
      <P>Как и в C#, генератор вычисляется лениво, по требованию, таким образом с помощью генераторов можно представить такие вещи как бесконечную последовательность.</P>
    </SECTION>
  </PART>
  <PART>
    <HEADER>Вместо заключения</HEADER>
    <P>Ela очень молодой и активно развивающийся язык, в него постоянно вносятся изменения и новые возможности, поэтому не воспринимайте данный документ как сокращенную спецификацию языка – скорее, это отчет о проделанной работе.</P>
    <P>На настоящий момент Ela распространяется под лицензией LGPL v. 2.1, а это означает, что, так как весь язык реализован в виде одной динамической библиотеки, вы можете использовать ее в составе проприетарных проектов, однако если вы хотите внести в исходный код какие-либо исправления, то стоит поделиться этими исправлениями со мной.</P>
    <P>Вместе с Ela распространяется также и утилита командной строки Ela Console (elac.exe), которая подпадает под то же лицензионное соглашение, что и сам язык. Вы можете использовать elac для запуска файлов с кодом Ela (обычно имеющих расширение *.ela) на выполнение, а также как интерактивную среду (для этого достаточно запустить elac без параметров). Консоль умеет делать много полезных вещей, поддерживает отладку кода по идеологии REPL и пр., позволяет настраивать линкер и компилятор – чтобы узнать обо всех возможностях elac запустите ее с ключиком «–help». Также, что немаловажно, если вы создатите в той же директории, где установлена elac, стандартный конфигурационный файл .NET, то все настройки из раздела appSettings будут интерпретироваться elac так же, как и параметры командной строки. Наконец, elac, как и сам язык Ela, может исполняться под управлением .NET 3.5/4.0 или Mono 2.0.</P>
    <P>Если у вас есть какие-либо вопросы или предложения по языку Ela, то можете написать в форум на RSDN или же задать их мне лично (почтовый адрес есть в карточке пользователя на RSDN).</P>
    <P />
  </PART>
</ARTICLE>