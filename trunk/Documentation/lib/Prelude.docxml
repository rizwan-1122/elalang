<?xml-stylesheet type="text/xsl" href="Template.xsl"?>
<article title="Lib.Prelude" type="module">

<section level="1" title="Introduction" />
Prelude module is an initialization script that contains definitions of basic functions and operators. 
It is always executed before any Ela program unless you explicitly tell Ela not to do so.

<section level="1" title="Math functions" />

<section level="2" title="+"/>
<code>
x + y
</code>
Adds two numeric values. This function works only with integer and floating point numbers.

<section level="2" title="-"/>
<code>
x - y
</code>
Subtracts one value from another. This function works only with integer and floating point numbers.

<section level="2" title="*"/>
<code>
x * y
</code>
Multiplies two numeric values. This function works only with integer and floating point numbers.

<section level="2" title="/"/>
<code>
x / y
</code>
Divides two numeric values. This function works only with integer and floating point numbers.

<section level="2" title="%"/>
<code>
x % y
</code>
Calculates the division remainder. This function works only with integer and floating point numbers.

<section level="2" title="**"/>
<code>
x ** y
</code>
Returns a specified number raised to a specified power. This function works only with integer and floating point numbers.

<section level="2" title="--"/>
<code>
--x
</code>
Negates a given value. This function works only with integer and floating point numbers.

<section level="1" title="Bitwise functions" />

<section level="2" title="&amp;&amp;&amp;"/>
<code>
x &amp;&amp;&amp; y
</code>
Computes the logical bitwise AND of its operands.
  
<section level="2" title="|||"/>
<code>
x ||| y
</code>
Computes the logical bitwise OR of its operands.  

<section level="2" title="^^^"/>
<code>
x ^^^ y
</code>
Computes the logical bitwise exclusive OR of its operands.
  
<section level="2" title="~~~"/>
<code>
~~~x
</code>
Performs a bitwise complement operation on its operand, which has the effect of reversing each bit.
  
<section level="2" title="&gt;&gt;&gt;"/>
<code>
x &gt;&gt;&gt; y
</code>
Shifts its first operand right by the number of bits specified by its second operand.
  
<section level="2" title="&lt;&lt;&lt;"/>
<code>
x &lt;&lt;&lt; y
</code>
Shifts its first operand left by the number of bits specified by its second operand.

<section level="1" title="Comparison functions" />

<section level="2" title="=="/>
<code>
x == y
</code>
Tests two operands for equality.

<section level="2" title="&lt;&gt;"/>
<code>
x &lt;&gt; y
</code>
Tests two operands for inequality.

<section level="2" title="&gt;"/>
<code>
x &gt; y
</code>
Tests if left operand is greater than the second operand.

<section level="2" title="&gt;="/>
<code>
x &gt;= y
</code>
Tests if left operand is greater or equal to the second operand.

<section level="2" title="&lt;"/>
<code>
x &lt; y
</code>
Tests if left operand is lesser than the second operand.

<section level="2" title="=&lt;"/>
<code>
x =&gt; y
</code>
Tests if left operand is lesser or equal to the second operand.

<section level="1" title="Logical functions" />

<section level="2" title="not"/>
<code>
not x
</code>
Performs a logical negation of its operand.

<section level="1" title="Type Conversion functions" />

<section level="2" title="toInt"/>
<code>
toInt x
</code>
Converts its operand to 32-bit integer number.

<section level="2" title="toLong"/>
<code>
toLong x
</code>
Converts its operand to 64-bit integer number.

<section level="2" title="toSingle"/>
<code>
toSingle x
</code>
Converts its operand to 32-bit floating point number.

<section level="2" title="toDouble"/>
<code>
toDouble x
</code>
Converts its operand to 64-bit floating point number.

<section level="2" title="toDouble"/>
<code>
toDouble x
</code>
Converts its operand to 64-bit floating point number.

<section level="2" title="toBool"/>
<code>
toBool x
</code>
Converts its operand to boolean.

<section level="2" title="toChar"/>
<code>
toChar x
</code>
Converts its operand to a unicode character.

<section level="2" title="toString"/>
<code>
toString x
</code>
Converts its operand to a string.

<section level="2" title="toList"/>
<code>
toList x
</code>
Converts its operand to a linked list.

<section level="2" title="toTuple"/>
<code>
toTuple x
</code>
Converts its operand to a tuple.

<section level="2" title="toRecord"/>
<code>
toRecord x
</code>
Converts its operand to a record.

<section level="2" title="toVariant"/>
<code>
toVariant x
</code>
Converts its operand to a polymorphic variant.

<section level="1" title="Tuples, lists and records" />

<section level="2" title="=&gt;"/>
<code>
x =&gt; y
</code>
Constructs a tuple of two elements - the left operand becomes a first element and the second operand becomes a second element. An expression above is equivalent to <key>(x, y)</key>.

<section level="2" title="swap"/>
<code>
swap x
</code>
Swaps first and second elements in a tuple. This function will only work with a tuple of two elements:
<code>swap (x,y) == (y,x)</code>

<section level="2" title="swap3"/>
<code>
swap3 x
</code>
Swaps first and second elements in a tuple. This function will only work with a tuple of element elements:
<code>swap3 (x,y,z) == (y,x,z)</code>

<section level="2" title="fst"/>
<code>
fst x
</code>
Returns a first element in a tuple. This function will only work with a tuple of two elements:
<code>fst (x,y) == x</code>

<section level="2" title="snd"/>
<code>
snd x
</code>
Returns a second element in a tuple. This function will only work with a tuple of two elements:
<code>snd (x,y) == y</code>

<section level="2" title="fst3"/>
<code>
fst3 x
</code>
Returns a first element in a tuple. This function will only work with a tuple of three elements:
<code>fst3 (x,y,z) == x</code>

<section level="2" title="snd3"/>
<code>
snd3 x
</code>
Returns a second element in a tuple. This function will only work with a tuple of three elements:
<code>snd3 (x,y,z) == y</code>

<section level="2" title=":"/>
<code>
xs:n
</code>
Returns an element at the specified index. This is a polymorphic function and it will work for tuples, lists, records, etc.
<code>"Hello":0 == 'H' $
{x=1}:"x" == 1</code>

<section level="2" title="isNil"/>
<code>
isNil xs
</code>
Tests if a given value is a nil list.

<section level="2" title="head"/>
<code>
head xs
</code>
Returns a head of a given list:
<code>head [1,2,3] == 1</code>

<section level="2" title="tail"/>
<code>
tail xs
</code>
Returns a tail of a given list:
<code>tail [1,2,3] == [2,3]</code>

<section level="2" title="length"/>
<code>
length xs
</code>
Returns a length of a given value. This is a polymorphic function and it will work for tuples, lists, records, etc:
<code>length [1,2,3] == 3 $
length "str" == 3 $
length (1,2,3) == 3</code>

<section level="2" title="::"/>
<code>
x :: y
</code>
List construction operator. This operator is right associative. In order to construct a list a rightmost part of an expression should
always be a <key>nil</key> list.
<code>1 :: 2 :: []</code>

<section level="2" title="++"/>
<code>
x ++ y
</code>
Concatenates two operands:
<code>[1,2] ++ [3,4] == [1,2,3,4] $
"abc" ++ "ABC" == "abcABC" $
1 ++ 2 == "12"</code>
The result of concatenation operation depends on the value of operands. The default behavior is to apply
<key>show</key> function to each of the operands and to concatenate the resulting strings:
<code>
12 ++ 34 == show 12 ++ show 34
</code>
However this function works differently for some data types. For lists, tuples and records it will produce a list and a tuple respectively that
will include elements from both operands.
This function renders an ability of seamless record cloning such as:
<code>
let rec = { x = 1, y = 2}  
let rec2 = rec ++ { z = 3 }
rec2 == { x = 1, y = 2, z = 3}
</code>

<section level="2" title="succ"/>
<code>
succ x
</code>
Returns a successor for a given value. This is a polymorphic functions that works with primitive types and with tuples:
<code>succ (1,2) == (2,3)</code>

<section level="2" title="pred"/>
<code>
pred x
</code>
Returns a predecessor for a given value. This is a polymorphic functions that works with primitive types and with tuples:
<code>pred (2,3) == (1,2)</code>
  
<section level="1" title="Functions for functions" />

<section level="2" title="&gt;&gt;"/>
<code>
f1 &gt;&gt; f2
</code>
Forward composition operator (normal order).

<section level="2" title="&lt;&lt;"/>
<code>
f1 &lt;&lt; f2
</code>
Backward composition operator (applicative order). This operator is right associative.

<section level="2" title="flip"/>
<code>
flip f
</code>
Flips arguments for a given function. The <key>flip</key> function definition can be written like so:
<code>
flip f x y = f y x
</code>
  
<section level="2" title="curry"/>
<code>
curry fun
</code>
Converts an uncurried function to a curried function. It works with functions for two arguments:
<code>curry fst 2 3 == 2</code>

<section level="2" title="uncurry"/>
<code>
uncurry fun
</code>
Converts an curried function to a uncurried function. It works with functions for two arguments:
<code>uncurry (%) (5,4) == 1</code>

<section level="2" title="curry3"/>
<code>
curry3 fun
</code>
Converts an uncurried function to a curried function. It works with functions for three arguments:
<code>curry3 fst3 1 2 3 == 1</code>

<section level="2" title="uncurry3"/>
<code>
uncurry3 fun
</code>
Converts an curried function to a uncurried function. It works with functions for three arguments:
<code>uncurry3 (\x y z -> x + y + z) (5,4,3) == 12</code>

<section level="2" title="!"/>
<code>
fun!
</code>
Applies a function to a unit. This is a redundant high priority application function, it has exactly the same effect as the following application:
<code>fun ()</code>

<section level="2" title="|&gt;"/>
<code>
x |&gt; f
</code>
A redundant low priority application operator also known as <i>forward pipe</i>. It has exactly the same effect as the following application:
<code>f x</code>

<section level="2" title="&lt;|"/>
<code>
f &lt;| x
</code>
A redundant low priority application operator also known as <i>backward pipe</i>. This operator is right associative. It has exactly the same effect as the following application:
<code>f x</code>

<section level="1" title="Formatting" />

<section level="2" title="showf"/>
<code>
showf f x
</code>
Formats a given value to a string using a specified format string:
<code>showf ".##" 12.12345</code>

<section level="2" title="show"/>
<code>
show x
</code>
Formats a given value to a string using a default format.

<section level="1" title="Variants" />

<section level="2" title="tag"/>
<code>
tag v
</code>
Returns a tag of a given variant as a string:
<code>tag (Some 12) == "Some"</code>

<section level="2" title="untag"/>
<code>
untag v
</code>
Unwraps a given variant and returns its value:
<code>untag (Some 12) == 12</code>

<section level="1" title="Reflection and thunks" />

<section level="2" title="type"/>
<code>
type x
</code>
Returns a record that contains type information about a given value.

<section level="2" title="force"/>
<code>
force x
</code>
Forces evaluation of a given thunk:
<code>force (&amp; 2+2)</code>

<section level="1" title="Combinators and other functions" />

<section level="2" title="id"/>
<code>
id x
</code>
Identity function (I combinator from SKI calculus):
<code>id 42 == 42</code>

<section level="2" title="const"/>
<code>
const f y
</code>
Constant function (K combinator from SKI calculus).

<section level="2" title="sub"/>
<code>
sub x y z
</code>
Substitution function (S combinator from SKI calculus).

<section level="2" title="fix"/>
<code>
fix f
</code>
Fix point combinator:
<code>let factabs fact 0 = 1
    factabs fact x = x * fact (x - 1)
let res = (fix factabs) 5</code>

<section level="2" title="on"/>
<code>
on cmb f x y
</code>
A combinator that applies a function given as its first argument to result of application of a second argument to a third and of a second argument to a forth argument:
<code>let (*) `on` f = \x y -> f x * f y</code>

<section level="2" title="until"/>
<code>
until p f x
</code>
Function application like so <key>until p f</key> yields the result of applying <key>f</key> until <key>p</key> holds:
<code>until (&lt;0) (-1) 10</code>

<section level="2" title="compare"/>
<code>
compare x y
</code>
Compares two given values and returns <key>EQ</key> variant if they are equal, <key>LT</key> variant if first argument is lesser than the second argument and <key>GT</key>
variant if first argument is greater than the second argument.

<section level="1" title="Referencing module" />
You don't have to reference Prelude module. It is opened automatically for every Ela program.
</article>