<?xml-stylesheet type="text/xsl" href="Template.xsl"?>
<article title="Ela and Haskell comparison">

  <section level="1" title="Introduction" />
  This article provides a brief overview of differences between Ela and Haskell. It can be used as a a "quick start" guide for those who are familiar with Haskell.
  
  <section level="1" title="Feature comparison" />
  <table>
    <tr>
      <th></th>
      <th>Ela</th>
      <th>Haskell</th>
    </tr>
    <tr>
      <td>Major programming paradigm</td> 
      <td>Functional</td>
      <td>Functional</td>
    </tr>
    <tr>
      <td>Syntax</td>
      <td>ML style, layout based</td>
      <td>ML style, layout based</td>
    </tr>
    <tr>
      <td>Purity</td>
      <td><i>Impure *</i></td>
      <td>Pure</td>
    </tr>
    <tr>
      <td>Type system</td>
      <td><i>No type system, only dynamic typing</i></td>
      <td>Statically typed with type inference</td>
    </tr>
    <tr>
      <td>Type strength</td>
      <td>Strong</td>
      <td>Strong</td>
    </tr>
    <tr>
      <td>Type safety</td>
      <td>Safe</td>
      <td>Safe</td>
    </tr>
    <tr>
      <td>Evaluation strategy</td>
      <td><i>Strict by default, lazy by demand</i></td>
      <td><i>Lazy by default, string by demand</i></td>
    </tr>
    <tr>
      <td>Pattern matching</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Function definition by PM</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Algebraic types</td>
      <td><i>Through polymorphic variants</i></td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>First class modules</td>
      <td><i>Yes</i></td>
      <td>No</td>
    </tr>
    <tr>
      <td>OOP support</td>
      <td><i>Through duck typing and modules</i></td>
      <td>Through existential types</td>
    </tr>
    <tr>
      <td>Monads</td>
      <td><i>No</i></td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Exceptions</td>
      <td><i>Through structured exception handling</i></td>
      <td>Through monads</td>
    </tr>
    <tr>
      <td>Curried functions</td>
      <td>Yes, all functions are curried</td>
      <td>Yes, all functions are curried</td>
    </tr>
    <tr>
      <td>Operators as functions</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
  </table>
  <p>
  <i>* Actually Ela is a pure language. The language itself provides no support for mutation of state - no variables, mutable data structures, etc. However Ela doesn't 
  restrict and/or control side effects in the code therefore mutation of state can be easily implemented on a library level. For example, module <key>Cell</key> adds
  a support for reference cells and module <key>Con</key> provides a support for classical C-style console input/output.
  </i></p>

  <section level="1" title="Syntax overview" />

  <section level="2" title="Global bindings" />
Ela always requires let keyword for both global and local bindings (local bindings can be optionally done through where construct).
<br/>
Haskell:
<code>x = 0
fib a b 0 = a
fib a b n = fib b (a + b) (n - 1)</code>
Ela:
<code>let x = 0
let fib a b 0 = a
    fib a b n = fib b (a + b) (n - 1)</code>
<section level="2" title="Local bindings"/>
  Both Ela and Haskell use let and where constructs for local bindings:
<br/>
Haskell:
<code>fib = fib2 0 1
      where fib2 a b 0 = a
            fib2 a b n = fib2 b (a + b) (n - 1)</code>
  
Ela:
<code>let fib = fib2 0 1
          where fib2 a b 0 = a
                fib2 a b n = fib2 b (a + b) (n - 1)</code>
Haskell:

<code>fib = let fib2 a b 0 = a
          fib2 a b n = fib2 b (a + b) (n - 1)
      in fib2 0 1</code>
Ela:
<code>let fib = let fib2 a b 0 = a
             fib2 a b n = fib2 b (a + b) (n - 1)
          in fib2 0 1</code>
  
<section level="2" title="Prefix, infix and postfix" />
Haskell supports function declaration in infix and prefix forms. Ela supports declarations of functions in infix, prefix and postfix forms.
<br/>
Haskell:
<code>x `sum` y = x + y
sum x y = x + y</code>
Ela:
<code>let x `sum` y = x + y
let sum x y = x + y
let x `negate` = --x</code>

<section level="2" title="Unary negation"/>
Haskell uses a common notation for unary negation, e.g. -x, while Ela has a different operator for unary negation.
<br/>
Haskell:
<code>y = -2 --unary negation</code>
Ela:
<code>
let y = --2
let f = -2 //Right section for a binary minus
f 10 //8</code>

<section level="2" title="List construction and list pattern matching"/>
By default Ela uses <key>::</key> operator for list construction. Haskell uses <key>:</key> operator.
<br/>
Haskell:
<code>xs = 1:2:3:[]
(y:ys) = xs</code>
Ela:
<code>let xs = 1::2::3::[]
let (y::ys) = xs</code>

<section level="2" title="Algebraic data types"/>
Haskell supports them. Ela provides a support for polymorphic variants which can be used in a similar fashion. Polymorphic variants don't have to be declared.
<br/>
Haskell:

<code>data Couple a = Foo a | Bar a
unbox (Foo a) = a
unbox (Bar a) = a</code>
Ela:
<code>let unbox (Foo a) = a
    unbox (Bar a) = a</code>

<section level="2" title="Partial operator application"/>
Both languages support it.
<br/>
Haskell:
<code>div2 = (/2)
x = div2 10 --5.0</code>
Ela:
<code>let div2 = (/2)
let x = div2 10 //5</code>

<section level="2" title="Pattern matching"/>
Haskell uses case expression, when Ela have match expression. Layout rules for both constructs are similar.
<br/>
Haskell:

<code>xs = 1:2:3:[]
res = case xs of 
           (x:xs) -> x
           []     -> 0</code>
Ela:

<code>let xs = 1::2::3::[]
let res = match xs with 
                x::xs = x
                []    = 0</code> 
<section level="2" title="Guards"/>
Both Haskell and Ela support guards in a similar way.
<br/>
Haskell:

<code>x = case (1,2) of
         (x,y) | x &lt; y      -&gt; x
               | x &lt; y      -&gt; y
               | otherwise  -&gt; x + y</code>
Ela:

<code>let x = match (1,2) with
              (x,y) | x &gt; y = x
                    | x &lt; y = y
                    | else  = x + y</code>
<section level="2" title="Ranges"/>
Both Ela and Haskell support ranges with similar syntax.
<br/>
Haskell:

<code>r1 = [1..] --infinite range
r2 = [10,9..] --infinite range
r3 = [1..10] --finite range
r4 = [10,9..1] --finite range</code>

Ela:

<code>let r1 = [1..] //infinite range
let r2 = [10,9..] //infinite range
let r3 = [1..10] //finite range
let r4 = [10,9..1] //finite range</code>

<section level="2" title="Comprehensions"/>
Both Ela and Haskell support comprehensions but Ela syntax is slightly different. Also comprehensions in Ela are strict by default.
<br/>
Haskell:

<code>xs = [x+y | x &lt;- [1..10], y &lt;- [10,9..1], x `mod` y == 0]</code>
Ela:

<code>let xs = [x+y \\ x &lt;- [1..10], y &lt;- [10,9..1] | x % y == 0] //strict
let xs' = [&amp; x+y \\ x &lt;- [1..10], y &lt;- [10,9..1] | x % y == 0] //lazy></code>

<section level="1" title="Non-strict evaluation"/>
In Haskell evaluation is non-strict by default. In Ela one should explicitely mark a certain expression as lazy.
<br/>
Haskell:

<code>map2 f (x:xs) = f x : map2 f xs
map2 _ []     = []
cycle2 xs = xs ++ cycle xs</code>

Ela:

<code>let map2 f (x::xs) = f x :: (&amp; map2 f xs)
    map2 _ []      = []
let cycle2 xs = xs ++ (&amp; cycle xs)</code>

<section level="1" title="Function application and composition"/>
Haskell uses <key>.</key> operator for function composition (right associative, with applicative order) and <key>$</key> operator for 
function application (right associative, with applicative order). By default Ela has four operators instead (similar to F#). These are forward 
pipe <key>|&gt;</key>, backward pipe <key>&lt;|</key>, forward composition <key>&gt;&gt;</key> and backward composition <key>&lt;&lt;</key>. Backward pipe is 
fully equivalent to <key>$</key> and backward composition is equivalent to <key>.</key>. They are both right associative and use applicative order. 
(Remember, that <key>.</key> is a different operator in Ela and is used specifically for "member access"; and <key>$</key> is a different operator as well that 
is used for sequencing).

Haskell:

<code>funk = (negate . abs)
funk x = negate $ abs $ x</code>
Ela:

<code>let funk = negate &lt;&lt; abs
let funk x = negate &lt;| abs &lt;| x</code>

<section level="1" title="Tuples"/>
Tuples in Haskell support nesting while in Ela tuples are always flat.
<br/>
Haskell:

<code>t = (1,2,(3,4,(5,6))) --t is (1,2,(3,4,(5,6)))</code>
Ela:

<code>let t = (1,2,(3,4,(5,6))) //t is (1,2,3,4,5,6)</code>
In Ela <key>,</key> is not an operator but syntax. One can use <key>=&gt;</key> operator from Prelude module to construct tuples.
<br/>
Haskell:

<code>{-# LANGUAGE TupleSections #-}
--[[(1,3),(2,3),(3,3)],[(1,2),(2,2),(3,2)],[(1,1),(2,1),(3,1)]]
t = map (\x -> map (,x) [1..3]) [3,2..1]</code>

Ela:

<code>open Core
//[[(1,3),(2,3),(3,3)],[(1,2),(2,2),(3,2)],[(1,1),(2,1),(3,1)]]
let t = map (\x -> map (=>x) [1..3]) [3,2..1]</code>
</article>