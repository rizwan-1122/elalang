//Here we use console output for testing purposes
//Module Console contains implementations of basic console functions such as
//writen (write line), write (write), readn (read line)
open Console

//Ela has all the basic arithmetic operators
let _ = writen (2+2)
let _ = writen (2*4-3)
let _ = writen (12/3)

//Functions in Ela are curried and are called without braces
//Here we calculate the length of a list (from 1 to 10) by
//calling standard length function
let len = length [1..10]

//Unlike many imperative languages Ela doesn't guarantee an order in which
//function arguments are evaluated. If you require a strict order (e.g. you
//want to write imperative code) you can use a sequencing operator '$' which
//is somewhat similar to ';' operator in C-style languages.
let _ = writen "First" $ writen "Second" $ writen "Third"

//Ela supports both strict and non-strict evaluation, however by default is
//strict. In order to use non-strict evaluation you should mark a partical
//section of code using '(& )' parenthesis.

//Why bad? This is impure function, that does console IO.
let badFunction x = writen ("Hello from thunk:" ++ x) $ x 

let x = (& badFunction (2+2)) //Nothing is calculated here
let _ = writen (x*3) //If you comment this line you will see nothing in console

//Functions can also be called using pipe operators. Sometimes it makes code more
//visual. By the way you won't see "Hello from thunk" the second time. The result
//of calculation is memoized.
let _ = writen <| "Backward pipe: " ++ (x*3)
let _ = "Forward pipe: " ++ (x*3) |> writen

//Ela also has forward and backward function composition operators
//This is also a good example of partial operator application using left/right sections.
let fun1 = ("Backward composition: "++) << (*3)
let fun2 = (*3) >> ("Forward composition: "++)
let _ = writen (fun1 x)
let _ = writen (fun2 x)

//By the way all Ela operators are written in Ela, you can always define your own
//operators if you don't like any of these.
let f <~> x = f x //We want to call functions using weird <~> operator
let _ = writen <~> "It works!"