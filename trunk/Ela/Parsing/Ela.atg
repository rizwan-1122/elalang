COMPILER Ela

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	newLine = cr + lf.
	tab = '\t'.    
	letter = 'A' .. 'Z' + 'a' .. 'z' + '_'.
	digit = "0123456789".
	notDigit = ANY - digit.
	hexDigit = digit + "ABCDEFabcdef".
	stringChar = ANY - '"' - '\\' - newLine.
	char = ANY - "'" - '\\' - newLine.
	op = "!%&*+-.:/<=>?@^|~".

TOKENS
	ident = letter { letter | digit }.	
	
	intTok = ( digit { digit } | digit { digit } CONTEXT ("." notDigit) | 
			( "0x" | "0X" ) hexDigit { hexDigit } ) [ "L" | "l" ].
	
	realTok = "." digit { digit } [ ( "e" | "E") [ "+" | "-" ] digit { digit } ] [ "D" | "d" ] 
			| digit { digit } 
			( 
				"." digit { digit } 
				[ ( "e" | "E" ) ["+" | "-" ] digit { digit } ] [ "D" | "d" ] 
				| ( "e" | "E") ["+" | "-" ] digit { digit } [ "D" | "d" ]  | "D" | "d" 
			).			
			
	stringTok = "\"" { stringChar
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					}  
				"\"".
				
	charTok = 	"'" ( char
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					)  
				"'".
	operatorTok = op { op }.
	
	variantTok = "`" letter { letter | digit }.
	
				
	SEMI = ";".
	LBRA = "{".
	RBRA = "}".
	MATCH_ARR = "->".
	
	ARG = "$".
	IN = "in".
	FTO = "to".
	DOWNTO = "downto".
	ON = "on".
	BASE = "base".
	MATCH = "match".
	WHEN = "when".
	AS = "as".
	IS = "is".
	VAR = "var".
	LET = "let".
	PRIVATE = "private".
	OPEN = "open".	
	AT = "at".
	WITH = "with".
	COUT = "cout".
	TYPEOF = "typeof".
	WHILE = "while".
	UNTIL = "until".
	DO = "do".
	FOR = "for".
	CIF = "if".
	ELSE = "else".
	THROW = "throw".
	YIELD = "yield".
	RETURN = "return".
	BREAK = "break".
	CONTINUE = "continue".
	TRY = "try".
	CATCH = "catch".
	TRUE = "true".
	FALSE = "false".
	ASYNC = "async".
	LAZY = "lazy".
	IGNOR = "ignore".
	
COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/"
IGNORE cr + lf + tab

PRODUCTIONS
	Literal<out ElaExpression exp> = 
		(. exp = null; .)
		(	
			(
				Primitive<out exp>
				{ Indexer<exp, out exp> | Invoke<exp, out exp> }
				[ MemberAccess<exp, out exp> ]
			)
			|
			(
				ListCreateExpr<out exp>
				{ Indexer<exp, out exp> | Invoke<exp, out exp> }
				[ MemberAccess<exp, out exp> ]
			)
			|
			(
				ArrayCreateExpr<out exp>
				{ Indexer<exp, out exp> | Invoke<exp, out exp> }
				[ MemberAccess<exp, out exp> ]
			)
			|
			(
				BASE 
				(. exp = new ElaBaseReference(t); .)
				[ MemberAccess<exp, out exp> ]
			)
			|
			(
				ident
				(. exp = new ElaVariableReference(t) { VariableName = t.val }; .)
				{ Indexer<exp, out exp> | Invoke<exp, out exp> }
				[ MemberAccess<exp, out exp> ]
			)
			|
			(
				ARG ident
				(. exp = new ElaArgument(t) { ArgumentName = t.val }; .)
				{ Indexer<exp, out exp> | Invoke<exp, out exp> }
				[ MemberAccess<exp, out exp> ]
			)
			|
			(
				variantTok 
				(. 
					var ev = new ElaVariantLiteral(t) { Name = t.val.TrimStart('`') }; 
					exp = ev;
				.)
				(
					(
						Invoke<exp, out exp>
						(. ev.Length = ((ElaFunctionCall)exp).Parameters.Count; .)
					)
					|
					(
						(. exp = new ElaFunctionCall(t) { Target = exp }; .)
					)
				)
				[ Indexer<exp, out exp> { Indexer<exp, out exp> | Invoke<exp, out exp> } ]
				[ MemberAccess<exp, out exp> ]
			)
			|
			(
				"_" (. exp = new ElaPlaceholder(t); .)
				{ Indexer<exp, out exp> | Invoke<exp, out exp> }
				[ MemberAccess<exp, out exp> ]
			)
		).
					
	Invoke<ElaExpression target, out ElaExpression exp> =
		(
			"(" 
				(. 
					var mi = new ElaFunctionCall(t) { Target = target };				
					exp = mi;
				.)	
				[ InvokeParameterList<mi> ]				
			")"
		).
		
	MemberAccess<ElaExpression target, out ElaExpression exp> = 
		"."
		(. exp = default(ElaExpression); .)
		(
			ident
			(. exp = new ElaFieldReference(t) { FieldName = t.val, TargetObject = target }; .)
			{ Indexer<exp, out exp> | Invoke<exp, out exp> }
			[ MemberAccess<exp, out exp> ]			
		).		
					
	InvokeParameterList<. ElaFunctionCall call .> = 
		(. var exp = default(ElaExpression); .)
		Expr<out exp>
		(. call.Parameters.Add(exp); .)
		[ "," 
			(. call.ConvertParametersToTuple = true; .)
			[ 
				(. call.ConvertParametersToTuple = false; .)
				InvokeParameterList<call> 
			] 
		].	
				
	Indexer<ElaExpression target, out ElaExpression exp> =
		( 
			"["
				(.
					var indExp = new ElaIndexer(t) { TargetObject = target };
					exp = indExp;
				.)
				(. var cexp = default(ElaExpression); .)
				Expr<out cexp>
				(. indExp.Index = cexp;	.)
			"]"
		).
		
		
	/* Match */
	
	MatchExpr<out ElaExpression exp> = 
		MATCH
		(. 
			var match = new ElaMatch(t);
			exp = match; 
			var cexp = default(ElaExpression);
		.)
		"(" Expr<out cexp> [ "," TupleExpr<ref cexp> ] ")"
		(. match.Expression = cexp; .)
		MatchEntry<match> { MatchEntry<match> }.
					
	MatchEntry<ElaMatch match> = 
		(. var cexp = default(ElaExpression); .)
		(		
			ON 
			(. var pat = default(ElaPattern); .)			
			RootPattern<out pat>
			(. 
				var entry = new ElaMatchEntry(t);
				entry.Pattern = pat;
				match.Entries.Add(entry);
			.)	
			[ 
				Guard<out cexp>
				(. pat.Guard = cexp; .)
			]		
		)
		MATCH_ARR Expr<out cexp>
		(. entry.Expression = cexp; .).
		
	Guard<out ElaExpression exp> = 
		WHEN 
		"(" 
			Expr<out exp> 
		")".	
		
	RootPattern<out ElaPattern pat> =
		OrPattern<out pat> 
		[ ConsPattern<pat, out pat> ]		
		[ SeqPattern<pat, out pat> ].
		
	OrPattern<out ElaPattern pat> = 		
		AndPattern<out pat>
		{
			"||" 
			(. var orPat = new ElaOrPattern(t) { Left = pat }; .)
			AndPattern<out pat>
			(. 
				orPat.Right = pat;
				pat = orPat;
			.)
		}.	
		
	AndPattern<out ElaPattern pat> = 		
		SinglePattern<out pat>
		{
			"&&"
			(. var andPat = new ElaAndPattern(t) { Left = pat }; .)
			SinglePattern<out pat>
			(. 
				andPat.Right = pat;
				pat = andPat;
			.)
		}.
					
	SinglePattern<out ElaPattern pat> = 				
		(. pat = null; .)
		(
			"_" (. pat = new ElaDefaultPattern(t); .)
			|
			LiteralPattern<out pat> 
			|
			BoolPattern<null, out pat>
			|			
			FieldTestPattern<out pat>
			|
			CtorPattern<out pat>
			|
			AnyCtorPattern<out pat>
			|
			IsPattern<null, out pat>
			|
			(
				ident (. var name = t.val; .)
				(
					IsPattern<name, out pat>
					|
					BoolPattern<name, out pat>
					|
					FieldPattern<name, out pat>
					|
					(.  pat = new ElaVariablePattern(t) { Name = name };  .) 
				)
			)
			|
			ValueofPattern<out pat>
			|
			ListPattern<out pat>
			|
			ArrayPattern<out pat>
			|
			"(" 
			(
				VoidPattern<out pat> 
				| RootPattern<out pat> ")"
			)
		)
		[
			AS 
			(. 
				var asPat = new ElaAsPattern(t) { Pattern = pat }; 
				pat = asPat;				
			.)
			ident (. asPat.Name = t.val; .)
		].

	ArrayPattern<out ElaPattern pat> = 		
		(.
			var seq = new ElaArrayPattern(t); 
			var cpat = default(ElaPattern);
			pat = seq;
		.)
		"[|"
			(
				SinglePattern<out cpat> 
				(.  seq.Patterns.Add(cpat);  .)
				{ 
					"," SinglePattern<out cpat> 
					(. seq.Patterns.Add(cpat); .)
				}
			)
		"|]".
		
	VoidPattern<out ElaPattern pat> = 
		(. pat = new ElaVoidPattern(t); .)
		")". 
		
	BindingPattern<out string name, out ElaPattern pat> =
		(. pat = null; name = null; .)
		(
			(
				ident (. name = t.val; .)				
				[
					(. name = null; .) 
					BoolPattern<null, out pat>
				]			
			)	
			|
			ListPattern<out pat>
			|
			ArrayPattern<out pat>
			|
			"(" RootPattern<out pat> ")" 
		).		
		
	ForeachPattern<out ElaPattern pat> =
		(. pat = null; string name = null; .)
		(
			(
				ident (. name = t.val; .)				
				(
					BoolPattern<name, out pat>
					|
					(
						(. pat = new ElaVariablePattern(t) { Name = name }; .)	
					)
				)		
						
			)
			|
			CtorPattern<out pat>
			|
			AnyCtorPattern<out pat>
			|
			LiteralPattern<out pat>
			|
			ListPattern<out pat>
			|
			ArrayPattern<out pat>
			|
			"(" RootPattern<out pat> ")"
		).
		
	IsOperatorPattern<out ElaPattern pat> = 
		(. pat = null; .)
		(
			(
				ident (. pat = new ElaIsPattern(t) { TypeAffinity = GetType(t.val) }; .) 
			)
			|
			CtorPattern<out pat>
			|
			AnyCtorPattern<out pat>
			|
			LiteralPattern<out pat>
			|
			ListPattern<out pat>
			|
			ArrayPattern<out pat>
			|
			"(" 
			(
				VoidPattern<out pat> 
				| RootPattern<out pat> ")"
			)
		).
			
	SeqPattern<ElaPattern prev, out ElaPattern pat> = 
		(.
			var seq = new ElaSeqPattern(t); 
			seq.Patterns.Add(prev);
			var cpat = default(ElaPattern);
			pat = seq;
		.)
		(
			"," 
			[
				OrPattern<out cpat> [ ConsPattern<cpat, out cpat> ]	
				(. seq.Patterns.Add(cpat); .)
				{ 
					"," OrPattern<out cpat> [ ConsPattern<cpat, out cpat> ]	
					(. seq.Patterns.Add(cpat); .)
				}
			]
		).
		
	ConsPattern<ElaPattern prev, out ElaPattern exp> =
		(. 
			var cexp = default(ElaPattern); 
			var ht = new ElaHeadTailPattern(t); 
			ht.Patterns.Add(prev);
			exp = ht;				
		.)
		(
			"::" SinglePattern<out cexp>
			(. ht.Patterns.Add(cexp); .)
			{
				"::" SinglePattern<out cexp>
				(. ht.Patterns.Add(cexp); .)
			}
		).
				
	IsPattern<string name, out ElaPattern pat> =
		(. pat = null; .)
		(
			IS
			(. var typ = new ElaIsPattern(t) { VariableName = name }; pat = typ; .)
			ident (. typ.TypeAffinity = GetType(t.val); .)
		).		
				
	BoolPattern<string name, out ElaPattern pat> =
		(. 
			pat = null; 
			var op = ElaBinaryOperator.None; 
			var right = default(ElaPattern);
		.)
		(
			(
				">" (. op = ElaBinaryOperator.Greater; .)
				| "<" (. op = ElaBinaryOperator.Lesser; .)
				| ">=" (. op = ElaBinaryOperator.GreaterEqual; .)
				| "<=" (. op = ElaBinaryOperator.LesserEqual; .)
				| "==" (. op = ElaBinaryOperator.Equals; .)
				| "!=" (. op = ElaBinaryOperator.NotEquals; .)			
			)
			( ValueofPattern<out right> | LiteralPattern<out right> )
			(. 
				var grd = new ElaBoolPattern(t) { Left = name, Right = right, Operator = op }; 
				pat = grd; 
			.)
		).	
		
	ValueofPattern<out ElaPattern pat> = 
		(. pat = null; .)
		(
			"&" 
			(. var val = new ElaValueofPattern(t); pat = val; .)
			ident (. val.VariableName = t.val; .)
		).		
					
	FieldPattern<string name, out ElaPattern pat> = 
		(. var fld = new ElaFieldPattern(t) { Name = name }; .)		
		"=" SinglePattern<out pat>
		(. fld.Value = pat; pat = fld; .).		
		
	FieldTestPattern<out ElaPattern pat> =
		(. var fld = new ElaFieldPattern(t); .)
		":" ident 
		(. fld.Name = t.val; pat = fld; .).
			
	LiteralPattern<out ElaPattern pat> =
		(
			(. 
				var val = new ElaLiteralPattern(t); 
				pat = val;
			.) 
			(
				stringTok (. val.Value = ParseString(t.val); .)
				| charTok (. val.Value = ParseChar(t.val); .)
				| intTok (. val.Value = ParseInt(t.val); .)
				| realTok (. val.Value = ParseReal(t.val); .)
				| "true" (. val.Value = new ElaLiteralValue(true); .)
				| "false" (. val.Value = new ElaLiteralValue(false); .)
			)
		).		
			
	ListPattern<out ElaPattern pat> = 
		(. pat = null; .)
		(
			"[" 
				(. 
					var listPat = default(ElaListPattern); 
					var listTok = t;					
					var cp = default(ElaPattern);
				.)
				[ 				
					RootPattern<out cp>
				]
				(.
					var seq = cp as ElaSeqPattern;
					listPat = new ElaListPattern(listTok, seq);
					pat = listPat;
						
					if (seq == null && cp != null)
						listPat.Patterns.Add(cp);
				.)
			"]"
		).
		
	CtorPattern<out ElaPattern pat> = 
		(. 
			var cons = default(ElaConstructorPattern);
			var consTok = t;
			var cp = default(ElaPattern);
			var seq = default(ElaSeqPattern);
			var name = String.Empty;
			pat = null;
		.)
		(
			variantTok (. name = t.val.TrimStart('`'); .)			
			[ 
				"(" 
				[ 
					RootPattern<out cp> 
					(. seq = cp as ElaSeqPattern; .)
				] 
				")" 			
			]
		)
		(. 
			cons = new ElaConstructorPattern(consTok, seq) { Name = name };
			pat = cons;
				
			if (seq == null && cp != null)
				cons.Patterns.Add(cp);
		.).		
		
	AnyCtorPattern<out ElaPattern pat> = 
		(. 
			var cons = default(ElaConstructorPattern);
			var consTok = t;
			var cp = default(ElaPattern);
			var seq = default(ElaSeqPattern);
			pat = null;
		.)
		(
			"`"
			[ 
				"(" 
				[ 
					RootPattern<out cp> 
					(. seq = cp as ElaSeqPattern; .)
				] 
				")" 			
			]
		)
		(. 
			cons = new ElaConstructorPattern(consTok, seq);
			pat = cons;
				
			if (seq == null && cp != null)
				cons.Patterns.Add(cp);
		.).		
			
	/* End Match */
		
		
	Block<out ElaExpression exp> =
		LBRA 
			(.
				var block = new ElaBlock(t); 
				exp = block;
			.)
			{ 
				RootExpr<block.Expressions> 
			}
		RBRA.		
				
	ListParamList<. List<ElaExpression> list .> = 
		(. var exp = default(ElaExpression); .)
		BinaryExpr<out exp> (. list.Add(exp); .)		
		[ "," ListParamList<list> ].
		
	ListCreateExpr<out ElaExpression exp> = 
		"[" 
			(. 
				var listExp = new ElaListLiteral(t);
				exp = listExp;
			.)
			[ 
				ListParamList<listExp.Values> 
				|
				(
					(. var cexp = default(ElaExpression); .)
					IterExpr<out cexp>
					(. listExp.Comprehension = cexp; .)
				)
			] 
		"]".
		
	ArrayCreateExpr<out ElaExpression exp> = 
		"[|"
			(. 
				var arrExp = new ElaArrayLiteral(t);
				exp = arrExp;
			.)
			[ 
				ListParamList<arrExp.Values> 
				|
				(
					(. var cexp = default(ElaExpression); .)
					IterExpr<out cexp>
					(. arrExp.Comprehension = cexp; .)
				)
			] 
		"|]".
		
	Assignment<ElaExpression left, out ElaExpression exp> = 
		(. var right = default(ElaExpression); exp = null; .)		
		(
			(
				(
					"=" Expr<out right>		
					|
					"+=" Expr<out right> 
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.Add, Left = left, Right = right }; .)		
					|
					"-=" Expr<out right> 		
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.Subtract, Left = left, Right = right }; .)		
					|
					"*=" Expr<out right> 		
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.Multiply, Left = left, Right = right }; .)		
					|
					"/=" Expr<out right> 		
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.Divide, Left = left, Right = right };.)		
					|
					"%=" Expr<out right> 
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.Modulus, Left = left, Right = right }; .)		
					|
					"|=" Expr<out right> 
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.BitwiseOr, Left = left, Right = right }; .)		
					|
					"&=" Expr<out right> 
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.BitwiseAnd, Left = left, Right = right }; .)		
					|
					"^=" Expr<out right> 
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.BitwiseXor, Left = left, Right = right }; .)	
					|
					">>=" Expr<out right> 
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.ShiftRight, Left = left, Right = right}; .)	
					|
					"<<=" Expr<out right> 
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.ShiftLeft, Left = left, Right = right}; .)	
					|
					"::=" Expr<out right> 
					(. right = new ElaBinary(t) { Operator = ElaBinaryOperator.ConsList, Left = right, Right = left}; .)		
				)		
				(. exp	= new ElaAssign(t) { Left = left, Right = right }; .)
			)	
			|
			"<=>" Expr<out right>
			(. exp = new ElaBinary(t) { Operator = ElaBinaryOperator.Swap, Left = left, Right = right }; .)
		).
				
	VariableDeclaration<out ElaExpression exp> = 
		(. exp = null; .)
		( 
			VAR VariableDeclarationBody<ElaVariableFlags.None, out exp>
			| 
			LET VariableDeclarationBody<ElaVariableFlags.Immutable, out exp>
		).
		
	VariableDeclarationBody<ElaVariableFlags flags, out ElaExpression exp> =
		(. 
			var varExp = new ElaVariableDeclaration(t) { VariableFlags = flags }; 
			exp = varExp;
			var cexp = default(ElaExpression); 
		.)
		[ PRIVATE (. varExp.VariableFlags |= ElaVariableFlags.Private; .) ]
		(
			(
				(. var pat = default(ElaPattern); string name = null; .)
				BindingPattern<out name, out pat>
				(. 
					if (name != null)
						varExp.VariableName = name;
					else
						varExp.Pattern = pat; 
				.)	
				[
					Guard<out cexp>
					(. if (pat != null) pat.Guard = cexp; .)
				]			
				[
					(
						(. if (name == null) AddError(ElaParserError.InvalidFunctionDeclaration); .)				
						FunDecl<out cexp>
					)
					| 
					(
						"=" Expr<out cexp>
					)
				]
				(.
					if (cexp != null) 
					{
						if (cexp.Type == ElaNodeType.FunctionLiteral &&  (flags & ElaVariableFlags.Immutable) == ElaVariableFlags.Immutable && name != null)
						{
							((ElaFunctionLiteral)cexp).Name = name;
							varExp.VariableFlags |= ElaVariableFlags.Function; 
						}
						else if (cexp.Type < ElaNodeType.FunctionLiteral)
							 varExp.VariableFlags |= ElaVariableFlags.ObjectLiteral;
					}
				.)
			)
			|
			(
				variantTok
				(.
					varExp.VariableName = t.val.Substring(1);
					varExp.VariableFlags |= ElaVariableFlags.Constructor;
				.)
				FunDecl<out cexp>
				(. 
					var fl = (ElaFunctionLiteral)cexp;
					fl.FunctionType = ElaFunctionType.Constructor; 
					fl.Name = varExp.VariableName;
				.)
			)
			|
			(
				"@" "(" operatorTok (. varExp.VariableName = t.val; .) ")"				
				FunDecl<out cexp>
				(. ((ElaFunctionLiteral)cexp).FunctionType = ElaFunctionType.BinaryOperator; .)
			)
			|
			(
				"~" "(" operatorTok (. varExp.VariableName = t.val; .) ")"
				FunDecl<out cexp>
				(. ((ElaFunctionLiteral)cexp).FunctionType = ElaFunctionType.UnaryOperator; .)
			)
		)
		(. varExp.InitExpression = cexp; .).
			
	FunDecl<out ElaExpression exp> =
		(
			"(" 
				(. var tp = new ElaTupleLiteral(t, false); exp = tp; .)
				[	
					ident (. tp.Parameters.Add(new ElaVariableReference(t) { VariableName = t.val }); .)
					{ "," ident (. tp.Parameters.Add(new ElaVariableReference(t) { VariableName = t.val }); .) } 
				] 
			")"
			FunExpr<ref exp>
		).
		
	WhenExpr<out ElaExpression exp> =
		(. var unless = false; .)
		( WHEN | "unless" (. unless = true; .) )
		(. 
			var cond = new ElaCondition(t) { Unless = unless }; 
			var cexp = default(ElaExpression);	
			exp = cond;
		.)
		"(" Expr<out cexp> (. cond.Condition = cexp; .) ")"
		Expr<out cexp> (. cond.True = cexp; .).
		
	IncludeStat<out ElaExpression exp> = 
		(. exp = null; .)
		(
			OPEN (. var inc = new ElaModuleInclude(t); .)
			ident
			(.
				inc.Alias = inc.Name = t.val;
				exp = inc;
			.)	
			[
				"["
				(
					ident (. inc.DllName = t.val; .)
					| 
					stringTok (. inc.DllName = ReadString(t.val); .)
				)
				"]"
			]		
			[ AT stringTok (. inc.Folder = ReadString(t.val); .) ]
			[ AS ident (. inc.Alias = t.val; .) ]
			[ WITH IncludeImports<inc> ]
		).
		
	IncludeImports<ElaModuleInclude inc> =
		(
			ident 
			(. 
				var imp = new ElaImportedName(t) { LocalName = t.val, ExternalName = t.val }; 
				inc.Imports.Add(imp); 
			.) 
			[ "=" ident (. imp.ExternalName = t.val; .) ]
		)
		[ "," IncludeImports<inc> ].
					
	CoutExpr<out ElaExpression exp> =
		(. exp = null; .)
		(
			(. var cexp = default(ElaExpression); .)
			COUT Expr<out cexp>
			(. exp = new ElaCout(t) { Expression = cexp }; .)
		).		
		
	TypeofExpr<out ElaExpression exp> = 
		(. exp = null; .)
		(
			(. var cexp = default(ElaExpression); .)
			TYPEOF "(" Expr<out cexp> ")"
			(. exp = new ElaTypeof(t) { Expression = cexp }; .)
		).
		
	WhileExpr<out ElaExpression exp> = 
		(. var wt = ElaWhileType.While; .)
		(
			(
				WHILE | UNTIL (. wt = ElaWhileType.Until; .)
			)
			(.
				var wex = new ElaWhile(t);
				exp = wex;
				var cexp = default(ElaExpression);
				wex.WhileType = wt;
			.)
			"("
				Expr<out cexp> (. wex.Condition = cexp; .)
			")"
			Expr<out cexp> 
			(. wex.Body = cexp; .)
		).
				
	DoWhileExpr<out ElaExpression exp> = 
		DO
		(.
			var wex = new ElaWhile(t);
			exp = wex;
			var cexp = default(ElaExpression);
			wex.WhileType = ElaWhileType.DoWhile;
		.)
		Expr<out cexp> (. wex.Body = cexp; .) [ SEMI ]
		( WHILE | UNTIL (. wex.WhileType = ElaWhileType.DoUntil; .) )
		"("
			Expr<out cexp> (. wex.Condition = cexp; .)
		")".
		
	ForExpr<out ElaExpression exp> = 
		FOR
		(. 
			var ot = t;
			var it = new ElaFor(t);
			exp = it;
			var cexp = default(ElaExpression);
			var pat = default(ElaPattern);
		.)
		"("
			[ VAR | LET (. it.VariableFlags = ElaVariableFlags.Immutable; .) ] 
			ForeachPattern<out pat> 			
			[ "=" OrExpr<out cexp> (. it.InitExpression = cexp; .) ]
			[ 
				WHEN Expr<out cexp>
				(. pat.Guard = cexp; .)
			]	
			(. it.Pattern = pat; .)
			(
				IN (. it.ForType = ElaForType.Foreach; .)
				| FTO (. it.ForType = ElaForType.ForTo; .)
				| DOWNTO (. it.ForType = ElaForType.ForDownto; .)
			)
			Expr<out cexp> (. it.Target = cexp; .)			
		")"
		(
			(	
				Expr<out cexp>
				(. it.Body = cexp; .)
			)
		).
	
	IfExpr<out ElaExpression exp> = 
		CIF 
		(. 
			var cond = new ElaCondition(t); 
			var cexp = default(ElaExpression);	
			exp = cond;
		.)
		"(" Expr<out cexp> (. cond.Condition = cexp; .) ")"		
		Expr<out cexp> (. cond.True = cexp; .) [ SEMI ]
		ELSE Expr<out cexp> (. cond.False = cexp; .).
    
	ThrowExpr<out ElaExpression exp> = 
		THROW
		(. 
			exp = null;
			var cexp = default(ElaExpression); 
		.)		
		Expr<out cexp>
		(. exp = new ElaThrow(t) { Expression = cexp }; .).
			
	YieldExpr<out ElaExpression exp> = 
		YIELD
		(. var cexp = default(ElaExpression);.)
		Expr<out cexp>
		(. 
			exp = new ElaYield(t) { Expression = cexp }; 
			
			if (funs.Count > 0)
				funs.Peek().Flags |= ElaExpressionFlags.HasYield;
		.).		
		
	ReturnExpr<out ElaExpression exp> = 
		RETURN 
		(. var cexp = default(ElaExpression);.)
		Expr<out cexp>
		(. exp = new ElaReturn(t) { Expression = cexp }; .).		
		
	BreakExpr<out ElaExpression exp> = 
		BREAK (. exp = new ElaBreak(t); .).
			
	ContinueExpr<out ElaExpression exp> = 
		CONTINUE (. exp = new ElaContinue(t); .).
		
	TryCatchExpr<out ElaExpression exp> =
		(. 
			exp = null; 
			var cexp = default(ElaExpression);			
		.)
		(
			TRY (. var ty = new ElaTryCatch(t); exp = ty; .)
			Expr<out cexp> (. ty.Try = cexp; .) [ SEMI ]
			CATCH
			"(" 
				ident (. ty.Variable = new ElaVariableReference(t) { VariableName = t.val }; .) 
			")"
			(
				TryCatchMatchExpr<ty>
				| 
				(
					Expr<out cexp>
					(. ty.Catch = cexp; .)
				)
			)
		).
		
	TryCatchMatchExpr<ElaTryCatch exp> = 
		(
			(.
				var match = new ElaMatch(t);
				match.Expression = exp.Variable;
				exp.Catch = match;
			.)
		)
		MatchEntry<match> { MatchEntry<match> }.
	
			
	/* Expr */
		
		
	UnaryOp<out ElaUnaryOperator op> =
		(. op = ElaUnaryOperator.None; .)
		(
			"-" (. op = ElaUnaryOperator.Negate; .) |
			"+" (. op = ElaUnaryOperator.Positive; .) |
			"!" (. op = ElaUnaryOperator.BooleanNot; .) |
			"~" (. op = ElaUnaryOperator.BitwiseNot; .) |
			"&" (. op = ElaUnaryOperator.ValueOf; .) |
			operatorTok (. op = ElaUnaryOperator.Custom; .) 
		).	
	SpecUnaryOp<out ElaUnaryOperator op> =
		(. op = ElaUnaryOperator.None; .)
		(
			"--" (. op = ElaUnaryOperator.Decrement; .) |
			"++" (. op = ElaUnaryOperator.Increment; .)
		).		
	PostUnaryOp<out ElaUnaryOperator op> =
		(. op = ElaUnaryOperator.None; .)
		(
			"--" (. op = ElaUnaryOperator.PostDecrement; .) |
			"++" (. op = ElaUnaryOperator.PostIncrement; .)
		).
	Primitive<out ElaExpression exp> = 
		(. exp = null; .)
		(
			intTok 
			(. exp = new ElaPrimitive(t) { Value = ParseInt(t.val) };	.)
			| 
			realTok 
			(. exp = new ElaPrimitive(t) { Value = ParseReal(t.val) }; .)
			|
			stringTok 
			(. exp = new ElaPrimitive(t) { Value = ParseString(t.val) }; .)
			|
			charTok 
			(. exp = new ElaPrimitive(t) { Value = ParseChar(t.val) }; .)
			|
			TRUE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(true) }; .) 
			|
			FALSE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(false) }; .)
		).
			
	OrExpr<out ElaExpression exp> =
		AndExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"||" AndExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaBinaryOperator.BooleanOr, Right = cexp }; 
			.)			
		}.
		
	AndExpr<out ElaExpression exp> =
		IsExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"&&" IsExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaBinaryOperator.BooleanAnd, Right = cexp }; 
			.)
		}.	
		
	IsExpr<out ElaExpression exp> =
		CompExpr<out exp>
		(. 
			var pat = default(ElaPattern); 
		.)
		{
			IS IsOperatorPattern<out pat>
			(. exp = new ElaIs(t) { Expression = exp, Pattern = pat }; .)
		}.		
			
	CompExpr<out ElaExpression exp> = 
		ConsExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
			.)
			(
				(
					"<<<" (. op = ElaBinaryOperator.CompForward; .)		
					CompExpr<out cexp>
					(. exp = new ElaBinary(t) { Left = GetFun(exp), Operator = op, Right = GetFun(cexp) }; .)
				)
				|
				(
					">>>" (. op = ElaBinaryOperator.CompBackward; .)
					CompExpr<out cexp>
					(. exp = new ElaBinary(t) { Right = GetFun(exp), Operator = op, Left = GetFun(cexp) }; .)
				)
			)
		}.
		
			
	ConsExpr<out ElaExpression exp> =
		PipeExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
			.)
			"::" (. op = ElaBinaryOperator.ConsList; .)
			ConsExpr<out cexp>
			(. exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; .)
		}.		
		
	PipeExpr<out ElaExpression exp> =
		BitOrExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
			.)
			(
				(
					"|>" (. op = ElaBinaryOperator.PipeForward; .)
					BitOrExpr<out cexp>
					(. exp = new ElaBinary(t) { Left = GetFun(exp), Operator = op, Right = GetFun(cexp) }; .)
				)
				|
				(
					"<|" (. op = ElaBinaryOperator.PipeBackward; .)
					PipeExpr<out cexp>
					(. exp = new ElaBinary(t) { Right = GetFun(exp), Operator = op, Left = GetFun(cexp) }; .)
				)
			)
		}.
	
	BitOrExpr<out ElaExpression exp> =
		BitXorExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"|" BitXorExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaBinaryOperator.BitwiseOr, Right = cexp }; 
			.)
		}.
		
	BitXorExpr<out ElaExpression exp> =
		BitAndExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"^" BitAndExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaBinaryOperator.BitwiseXor, Right = cexp }; 
			.)
		}.
		
	BitAndExpr<out ElaExpression exp> =
		EqExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"&" EqExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaBinaryOperator.BitwiseAnd, Right = cexp }; 
			.)
		}.
		
	EqExpr<out ElaExpression exp> =
		RelExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
			.)
			(
				"==" (. op = ElaBinaryOperator.Equals; .) |
				"!=" (. op = ElaBinaryOperator.NotEquals; .)
			)
			RelExpr<out cexp>
			(. exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; .)
		}.
		
	RelExpr<out ElaExpression exp> =
		ShiftExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
			.)
			(
				">" (. op = ElaBinaryOperator.Greater; .) |
				"<" (. op = ElaBinaryOperator.Lesser; .) |
				">=" (. op = ElaBinaryOperator.GreaterEqual; .) |
				"<=" (. op = ElaBinaryOperator.LesserEqual; .)
			)
			ShiftExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
		
	ShiftExpr<out ElaExpression exp> =
		AddExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
			.)
			(
				">>" (. op = ElaBinaryOperator.ShiftRight; .) |
				"<<" (. op = ElaBinaryOperator.ShiftLeft; .)
			)
			AddExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
		
	AddExpr<out ElaExpression exp> =
		MulExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
			.)
			(
				"+" (. op = ElaBinaryOperator.Add; .) |
				"-" (. op = ElaBinaryOperator.Subtract; .)
			)
			MulExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
		
	MulExpr<out ElaExpression exp> =
		CastExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
			.)
			(
				"*" (. op = ElaBinaryOperator.Multiply; .) |
				"/" (. op = ElaBinaryOperator.Divide; .) |
				"%" (. op = ElaBinaryOperator.Modulus; .) |
				"**" (. op = ElaBinaryOperator.Power; .)
			)
			CastExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
				
	CastExpr<out ElaExpression exp> = 
		CustomOpExpr<out exp>
		{
			(. var typ = ObjectType.None; .)
			":>" ident (. typ = GetType(t.val); .)
			(. 
				exp = new ElaCast(t) { 
					CastAffinity = typ, Expression = exp }; 
			.)			
		}.		
		
	CustomOpExpr<out ElaExpression exp> = 
		UnaryExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaBinaryOperator);
				var name = String.Empty;
			.)
			operatorTok (. op = ElaBinaryOperator.Custom; name = t.val; .)
			UnaryExpr<out cexp>
			(. exp = new ElaBinary(t) { CustomOperator = name, Left = GetFun(exp), Operator = op, Right = GetFun(cexp) }; .)
		}.
								
	UnaryExpr<out ElaExpression exp> =
		(. exp = null; .)
		(
			(
				Literal<out exp> 
				[ 
					(. var op = default(ElaUnaryOperator); .)
					PostUnaryOp<out op>
					(. exp = new ElaUnary(t) { Operator = op, Expression = exp }; .)
				]
			)
			|
			(
				(. var op = default(ElaUnaryOperator); .)
				UnaryOp<out op>
				(
					(. 
						var name = t.val; 
						var nexp = default(ElaExpression); 
					.)
					(
						Literal<out nexp>
						|
						"(" Expr<out nexp> ")"
					)
					(.
						exp = new ElaUnary(t)
						{ 
							Operator = op,
							Expression = nexp,
							CustomOperator = op == ElaUnaryOperator.Custom ? name : null
						};
					.)
				)		
			)
			|
			(
				(. var op = default(ElaUnaryOperator); .)
				SpecUnaryOp<out op>
				(. var nexp = default(ElaExpression); .)
				Literal<out nexp>
				(. exp = new ElaUnary(t) { Operator = op, Expression = nexp }; .)
			)
			|
			( 
				"(" 	
				(			
					(
						")"
						(. exp = new ElaTupleLiteral(t, true); .)
					)
					|
					(
						Expr<out exp> 
						(
							(				
								")"
								{ Indexer<exp, out exp> | Invoke<exp, out exp> }
								[ MemberAccess<exp, out exp> ]	
							)
							|
							(
								":" ObjectExpr<exp, out exp>
								{ Indexer<exp, out exp> | Invoke<exp, out exp> }
								[ MemberAccess<exp, out exp> ]	
							)							
							|
							(
								"," TupleExpr<ref exp> ")"
								{ Indexer<exp, out exp> | Invoke<exp, out exp> }
								[ MemberAccess<exp, out exp> ]	
							)
						)
					)
				)
			)		
		).	
		
	TupleExpr<ref ElaExpression exp> =
		(.    
			var pexp = new ElaTupleLiteral(t, false);
			pexp.Parameters.Add(exp);
			exp = pexp;				
			var cexp = default(ElaExpression);				
		.)
		(	
			[
				Expr<out cexp> 
				(. pexp.Parameters.Add(cexp); .)
			]
			{ "," Expr<out cexp> (. pexp.Parameters.Add(cexp); .) }
		).			
		
	ObjectExpr<ElaExpression fl, out ElaExpression exp> =
		(. 
			var obj = new ElaRecordLiteral(t); 
			exp = obj;
			var cexp = default(ElaExpression);
			var newFl = new ElaFieldDeclaration(t);
			
			if (fl.Type != ElaNodeType.VariableReference)
				AddError(ElaParserError.InvalidRecordFieldDeclaration);
			else
			{
				newFl.FieldName = ((ElaVariableReference)fl).VariableName;
				obj.Fields.Add(newFl);
			}
		.)
		(
			Expr<out cexp> (. newFl.FieldValue = cexp; .)
			[ "," FieldExpr<obj.Fields> ]
		)
		")".
				
	FieldExpr<. List<ElaFieldDeclaration> list .> =
		(. var cexp = default(ElaExpression); .)
		(
			ident 
			(. 
				var fl = new ElaFieldDeclaration(t) { FieldName = t.val }; 
				list.Add(fl);
			.)
			":" Expr<out cexp>
			(. fl.FieldValue = cexp; .)
		)
		[ "," FieldExpr<list> ].
				
	FunExpr<ref ElaExpression exp> =
		(. 
			var mi = new ElaFunctionLiteral(t);
			mi.Parameters = exp;
			funs.Push(mi);
		.)
		(
			FunMatchExpr<mi>
			|
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. mi.Expression = fexp; .)
			)
			|
			SEMI			
		)
		(. 
			exp = mi; 
			funs.Pop();
		.).	
		
	FunMatchExpr<ElaFunctionLiteral mi> = 
		(.
			var match = new ElaMatch(t);
			match.Expression = mi.Parameters;
			mi.Expression = match;
			
			if (mi.Parameters.Type == ElaNodeType.TupleLiteral &&
				((ElaTupleLiteral)mi.Parameters).Parameters.Count == 0)
				AddError(ElaParserError.ShortMatchWithoutParams);
		.)
		MatchEntry<match> { MatchEntry<match> }.
					
	BinaryExpr<out ElaExpression exp> = 
		(
			OrExpr<out exp>
			[			
				"->" FunExpr<ref exp>
				|
				Assignment<exp, out exp>			
			]
		).	
			
	AsyncExpr<out ElaExpression exp> =
		(
			ASYNC
			(. var async = new ElaAsyncLiteral(t); .)
			Expr<out exp>
			(.
				async.Expression = exp;
				exp = async;
			.)
		).
		
	LazyExpr<out ElaExpression exp> =
		(
			LAZY 
			(. var lazy = new ElaLazyLiteral(t); .)
			Expr<out exp>
			(.
				lazy.Expression = exp;
				exp = lazy;
			.)
		).
		
	IgnoreExpr<out ElaExpression exp> =
		(
			IGNOR
			(. var ign = new ElaIgnore(t); .)
			Expr<out exp>
			(.
				ign.Expression = exp;
				exp = ign;
			.)
		).
		
	Expr<out ElaExpression exp> = 
		(. exp = null; .)
		( 			
			Block<out exp> |
			IgnoreExpr<out exp> |
			BinaryExpr<out exp> |
			WhenExpr<out exp> |
			IfExpr<out exp> |
			MatchExpr<out exp> |
			IterExpr<out exp> |	
			VariableDeclaration<out exp> | 
			ThrowExpr<out exp> |
			CoutExpr<out exp> |
			TypeofExpr<out exp> |
			ReturnExpr<out exp> |
			YieldExpr<out exp> |
		
			BreakExpr<out exp> |
			ContinueExpr<out exp> |	
			TryCatchExpr<out exp> |	
			AsyncExpr<out exp> |
			LazyExpr<out exp> 			
		)
		(. exp = GetFun(exp); .).
		
	IterExpr<out ElaExpression exp> =
		(. exp = null; .)
		(
			WhileExpr<out exp> |	
			DoWhileExpr<out exp> |		
			ForExpr<out exp>
		).
				
	RootExpr<. List<ElaExpression> list .> =
		(. var exp = default(ElaExpression); .)
		(
			Expr<out exp> (. if (la.kind != _RBRA && t.kind != _RBRA && t.kind != _SEMI) .) (SEMI|EOF)
			| SEMI
			| IncludeStat<out exp> SEMI
		)
		(. if (exp != null) list.Add(exp); .).	
				
	Ela = 
		(. InitializeCodeUnit(); .)
		( RootExpr<CodeUnit.Expressions> ) 
		{ 
			RootExpr<CodeUnit.Expressions>
		}.
		
END Ela.