COMPILER Ela

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	newLine = cr + lf.
	tab = '\t'.    
	letter = 'A' .. 'Z' + 'a' .. 'z' + '_'.
	digit = "0123456789".
	notDigit = ANY - digit.
	hexDigit = digit + "ABCDEFabcdef".
	verbatimChar = ANY.
	stringChar = ANY - '"' - '\\' - newLine.
	char = ANY - "'" - '\\' - newLine.
	op = "!%&*+-.:/<=>?@^|~".
	op2 = "!%&*+-.:/<=?@^|~".
	op3 = "!%&*+-.:/=>?@^|~".
	op4 = "!%&*+.:/<=>?@^|~".

TOKENS
	ident = letter { letter | digit | "'" }
			| "'" letter [ (letter|digit|"'") {letter|digit|"'"} (letter|digit) ].	
	
	variantTok = "`"(
				letter { letter | digit | "'" }
				| "'" letter [ (letter|digit|"'") {letter|digit|"'"} (letter|digit) ]
			).
			
	argIdent = "$"(
				letter { letter | digit | "'" }
				| "'" letter [ (letter|digit|"'") {letter|digit|"'"} (letter|digit) ]
				).
	
	funcTok = "`"(
					letter { letter | digit | "'" }
					| "'" letter [ (letter|digit|"'") {letter|digit|"'"} (letter|digit) ]
				)
			"`".

	intTok = ( digit { digit } | digit { digit } CONTEXT ("." notDigit) | 
			( "0x" | "0X" ) hexDigit { hexDigit } ) [ "L" | "l" ].
			
	realTok = "." digit { digit } [ ( "e" | "E") [ "+" | "-" ] digit { digit } ] [ "D" | "d" | "F" | "f" ] 
			| digit { digit } 
			( 
				"." digit { digit } 
				[ ( "e" | "E" ) ["+" | "-" ] digit { digit } ] [ "D" | "d" | "F" | "f" ] 
				| ( "e" | "E") ["+" | "-" ] digit { digit } [ "D" | "d" | "F" | "f" ]  | "D" | "d" | "F" | "f"
			).		
			
	stringTok = "\"" { stringChar
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					}  
				"\""
				| "<[" {verbatimChar} "]>".
				
	charTok = 	"'" ( char
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					)  
				"'".
	operatorTok1 = (
		("="|"|"|"&") { op }
		| ">" [ op2 { op } ]
		| "<" [ op3 { op } ]
		).
	operatorTok2 = "^" { op }.
	operatorTok3 = ":" { op }.
	operatorTok4 = (
		"+" { op }
		| "-" [ op4 { op } ]
		).
	operatorTok5 = ("*"|"/"|"%") { op }.		
	operatorTok6 = "<<" { op }.
	operatorTok7 = ">>" { op }.
	operatorTok8 = ("~"|"--"|"!") { op }.
	
	LBRA = "{".
	RBRA = "}".
	LILB = "[".
	LIRB = "]".
	
	PIPE = "|".
	ARROW = "->".
	LAMBDA = "\\".
	COMPH = "@@".
	COMPO = "\\\\".
	
	DOT = ".".
	IN = "in".
	BASE = "base".
	MATCH = "match".
	ASAMP = "@".
	IS = "is".	
	LET = "let".
	PRIVATE = "private".
	OPEN = "open".	
	WITH = "with".
	IFS = "if".
	ELSE = "else".
	THEN = "then".
	RAISE = "raise".
	TRY = "try".
	TRUE = "true".
	FALSE = "false".
	FAIL = "fail".
	WHERE = "where".
	
	ET = "et".
	
	EBLOCK = ";".
	
	
COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/"
IGNORE cr + lf

PRODUCTIONS
	EndBlock = EBLOCK (. if (!t.virt) scanner.PopIndent(); .).
	
	Literal<out ElaExpression exp> = 
		(. exp = null; .)
		(	
			Primitive<out exp>
			| RecordLiteral<out exp>
			| ListLiteral<out exp>
			| TupleLiteral<out exp>
			| SimpleExpr<out exp>					
		).
		
	SimpleExpr<out ElaExpression exp> = 
		(. exp = null; .)
		(	
			ArgumentReference<out exp>
			| BaseReference<out exp>
			| VariableReference<out exp>			
			| LazyExpr<out exp>	
		).
		
	VariantLiteral<out ElaExpression exp> = 
		(. 
			exp = null; 
			var vl = default(ElaVariantLiteral);
		.)
		(
			variantTok 
			(. vl = new ElaVariantLiteral(t) { Tag = t.val.Substring(1) }; .)
			[ Literal<out exp> (. vl.Expression = exp; .) ]
			(. exp = vl; .)
		).
		
	Primitive<out ElaExpression exp> = 
		(. exp = null; .)
		(
			intTok  (. exp = new ElaPrimitive(t) { Value = ParseInt(t.val) };	.)
			| realTok (. exp = new ElaPrimitive(t) { Value = ParseReal(t.val) }; .)
			| stringTok (. exp = new ElaPrimitive(t) { Value = ParseString(t.val) }; .)
			| charTok (. exp = new ElaPrimitive(t) { Value = ParseChar(t.val) }; .)
			| TRUE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(true) }; .) 
			| FALSE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(false) }; .)
		).
		
	VariableReference<out ElaExpression exp> =
		(. exp = null; .)
		(
			ident (. exp = new ElaVariableReference(t) { VariableName = t.val }; .)
			| "_" (. exp = new ElaPlaceholder(t); .)
		).
		
	TupleLiteral<out ElaExpression exp> =
		(. 
			var ot = default(Token);
			exp = null; 
		.)
		(
			"(" 
				(. ot = t; .)
				[ GroupExpr<out exp> ] 
			")"
		)
		(.
			if (exp == null)
				exp = new ElaUnitLiteral(ot);
		.).			
		
	GroupExpr<out ElaExpression exp> = 
		(. 
			exp = null; 
			var cexp = default(ElaExpression);
			var ot = t;
		.)
		(
			Expr<out exp>
			[
				(
					(. 
						var tuple = new ElaTupleLiteral(ot); 
						tuple.Parameters.Add(exp);
						exp = tuple; 
					.)		
					","
					(	
						[
							Expr<out cexp> 
							(. tuple.Parameters.Add(cexp); .)
						]
						{ "," Expr<out cexp> (. tuple.Parameters.Add(cexp); .) }
					)
				)
			]
		).
	
	ArgumentReference<out ElaExpression exp> =					
		argIdent (. exp = new ElaArgument(t) { ArgumentName = t.val.Substring(1) }; .).
		
	BaseReference<out ElaExpression exp> =
		(.
			var baseRef = default(ElaBaseReference);
			exp = null;
		.)
		(
			BASE 
			(. baseRef = new ElaBaseReference(t); .)
			"." 
			(. var ot = t; .)
			ident
			(. exp = new ElaFieldReference(ot) { FieldName = t.val, TargetObject = baseRef }; .)
		).
			
		
	/* Match */
	
	MatchExpr<out ElaExpression exp> = 
		(. scanner.InjectBlock(); .)
		SYNC MATCH
		(. 
			var match = new ElaMatch(t);
			exp = match; 
			var cexp = default(ElaExpression);
		.)
		Expr<out cexp> (. match.Expression = cexp; .)
		WITH
		(
			MatchEntry<match>
			{ 
				MatchEntry<match>
				| ChildMatchEntry<match>
			}
		)		
		EndBlock.
					
	MatchEntry<ElaMatch match> = 
		(. var cexp = default(ElaExpression); .)
		(. scanner.InjectBlock(); .)
		(		
			(. 
				var pat = default(ElaPattern); 
				var ot = t; 
			.)			
			RootPattern<out pat>
			(. 
				var entry = new ElaMatchEntry(ot);
				entry.Pattern = pat;				
				match.Entries.Add(entry);
			.)
			[ 
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
		)
		(	
			"=" Expr<out cexp>
			(. entry.Expression = cexp; .)	
		)
		[ 
			WhereBinding<out cexp> 
			(. entry.Where = cexp; .) 
		]
		(. if (RequireEndBlock()) .) EndBlock.
		
	ChildMatchEntry<ElaMatch match> = 
		(. var cexp = default(ElaExpression); .)
		(		
			(. 
				var entry = new ElaMatchEntry(t);
				match.Entries.Add(entry);
			.)
			Guard<out cexp>
			(. entry.Guard = cexp; .)
			
			"=" Expr<out cexp>
			(. entry.Expression = cexp; .)	
			
			[ 
				WhereBinding<out cexp> 
				(. entry.Where = cexp; .) 
			]
		)
		(. if (RequireEndBlock()) .) EndBlock.
		
	Guard<out ElaExpression exp> = 
		(. exp = null; .)
		"|" 		
		(
			(
				BinaryExpr<out exp>
				{
					(. var old = exp; .)
					"," 
					(. var ot = t; .)
					BinaryExpr<out exp>
					(.
						exp = new ElaBinary(t) { Operator = ElaOperator.BooleanAnd, Left = old, Right = exp };
					.)
				}
			)
			| "else" (. exp = new ElaOtherwiseGuard(t); .)
		).	
		
	RootPattern<out ElaPattern pat> =
		OrPattern<out pat> 
		[ ConsPattern<pat, out pat> ].
		
	ParenPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			OrPattern<out pat> 
		)
		[ ConsPattern<pat, out pat> ]		
		[ TuplePattern<pat, out pat> ].
		
	VariantPattern<out ElaPattern pat> = 
		(. 
			pat = null; 
			var vp = default(ElaVariantPattern);
			var cpat = default(ElaPattern);
		.)
		(
			(
				variantTok (. vp = new ElaVariantPattern(t) { Tag = t.val.Substring(1) }; .)
				[ AsPattern<out cpat> (. vp.Pattern = cpat; .) ]
				(. pat = vp; .)
			)
			|
			(
				"`" (. vp = new ElaVariantPattern(t); .)
				[ AsPattern<out cpat> (. vp.Pattern = cpat; .) ]
				(. pat = vp; .)
			)
		).
			
	OrPattern<out ElaPattern pat> =	
		(. pat = null; .)
		(VariantPattern<out pat> | AsPattern<out pat>).
		
	FuncPattern<out ElaPattern pat> =
		AsPattern<out pat> [ ConsPattern<pat, out pat> ].
					
	SinglePattern<out ElaPattern pat> =			
		(. pat = null; .)
		(
			DefaultPattern<out pat>
			| UnitPattern<out pat>
			| LiteralPattern<out pat> 
			| ListPattern<out pat>
			| RecordPattern<out pat>
			| IdentPattern<out pat>
			| TypeCheckPattern<out pat>
		).
			
	AsPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			SinglePattern<out pat>
			[
				"@" 
				(. 
					var asPat = new ElaAsPattern(t) { Pattern = pat }; 
					pat = asPat;				
				.)
				ident (. asPat.Name = t.val; .)
			]		
		).
		
	UnitPattern<out ElaPattern pat> = 
		(.
			var ot = t;
			pat = null;
		.)
		(
			"(" [ ParenPattern<out pat> ] ")" 
		)
		(. 
			if (pat == null)
				pat = new ElaUnitPattern(ot); 
		.). 
		
	DefaultPattern<out ElaPattern pat> = 
		"_" (. pat = new ElaDefaultPattern(t); .). 
		
	BindingPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			DefaultPattern<out pat>
			| UnitPattern<out pat>
			| LiteralPattern<out pat> 
			| ListPattern<out pat>
			| RecordPattern<out pat>
			| TypeCheckPattern<out pat>
		)
		[
			"@" 
			(. 
				var asPat = new ElaAsPattern(t) { Pattern = pat }; 
				pat = asPat;				
			.)
			ident (. asPat.Name = t.val; .)
		].		
		
	GeneratorPattern<out ElaPattern pat> =
		(. pat = null; string name = null; .)
		(
			ident (. name = t.val; .) (. pat = new ElaVariablePattern(t) { Name = name }; .)							
			| LiteralPattern<out pat>
			| RecordPattern<out pat>
			| ListPattern<out pat>
			| UnitPattern<out pat>
		).
		
	IsOperatorPattern<out ElaPattern pat> = 
		(. pat = null; .)
		(
			TypeCheckPattern<out pat>
			| LiteralPattern<out pat>
			| RecordPattern<out pat>
			| ListPattern<out pat>
			| UnitPattern<out pat>
		).
		
	TypeCheckPattern<out ElaPattern pat> = 
		(. 
			var eis = new ElaIsPattern(t);
			pat = eis; 			
		.)
		"?" 
		(
			ident 
			(. 
				eis.TypeCode = GetType(t.val); 
				
				if (eis.TypeCode == ElaTypeCode.None)
					eis.TypeName = t.val;
			.)
		).		
						
	IdentPattern<out ElaPattern pat> =
		(. pat = null; .)
		(			
			ident (. var name = t.val; .)
			[
				(
					":" 
					(. var cst = new ElaCastPattern(t) { VariableName = name }; pat = cst; .)
					ident (. cst.TypeAffinity = GetType(t.val); .)
				)
			]			
			(. 
				if (pat == null)
					pat = new ElaVariablePattern(t) { Name = t.val }; 
			.)
		).	
		
	RecordPattern<out ElaPattern pat> = 
		(. 
			pat = null; 
			var cpat = default(ElaFieldPattern);
		.)
		(
			"{"
				(. 
					var rec = new ElaRecordPattern(t); 
					pat = rec; 
				.)				
				[
					FieldPattern<out cpat>
					(. rec.Fields.Add(cpat); .)
					{
						","
						FieldPattern<out cpat>
						(. rec.Fields.Add(cpat); .)
					}
				]
			"}"		
		).
		
	FieldPattern<out ElaFieldPattern fld> =
		(. 
			fld = null;
			var cpat = default(ElaPattern);
		.)
		(
			(
				stringTok
				(. fld = new ElaFieldPattern(t) { Name = ReadString(t.val) }; .)		
				"=" AsPattern<out cpat>
				(. fld.Value = cpat; .)
			)
			|
			(
				ident
				(. fld = new ElaFieldPattern(t) { Name = t.val }; .)		
				[
					"=" AsPattern<out cpat>
				]
				(. 
					if (cpat == null)
						cpat = new ElaVariablePattern(t) { Name = fld.Name };
					
					fld.Value = cpat; 
				.)
			)
		).	
			
	TuplePattern<ElaPattern prev, out ElaPattern pat> = 
		(.
			var seq = new ElaTuplePattern(t); 
			seq.Patterns.Add(prev);
			var cpat = default(ElaPattern);
			pat = seq;
		.)
		(
			"," 
			[
				AsPattern<out cpat> [ ConsPattern<cpat, out cpat> ]	
				(. seq.Patterns.Add(cpat); .)
				{ 
					"," 
					AsPattern<out cpat> [ ConsPattern<cpat, out cpat> ]	
					(. seq.Patterns.Add(cpat); .)
				}
			]
		).
			
	ConsPattern<ElaPattern prev, out ElaPattern exp> =
		(. 
			var cexp = default(ElaPattern); 
			var ht = new ElaHeadTailPattern(t); 
			ht.Patterns.Add(prev);
			exp = ht;				
		.)
		(
			"::" AsPattern<out cexp>
			(. ht.Patterns.Add(cexp); .)
			{
				"::" AsPattern<out cexp>
				(. ht.Patterns.Add(cexp); .)
			}
		).
				
	LiteralPattern<out ElaPattern pat> =
		(
			(. 
				var lit = default(ElaLiteralValue);
				pat = null;
			.) 
			(
				stringTok (. lit = ParseString(t.val); .)
				| charTok (. lit = ParseChar(t.val); .)
				| intTok (. lit = ParseInt(t.val); .)
				| realTok (. lit = ParseReal(t.val); .)
				/*|
				(
					"--"
					(
						intTok (. lit = ParseInt(t.val).MakeNegative(); .)
						| realTok (. lit = ParseReal(t.val).MakeNegative(); .)
					)
				)*/
				| "true" (. lit = new ElaLiteralValue(true); .)
				| "false" (. lit = new ElaLiteralValue(false); .)
			)
			(.
				pat = new ElaLiteralPattern(t) { Value = lit };				
			.)
		).		
			
	ListPattern<out ElaPattern pat> = 
		(.
			var cexp = default(ElaPattern); 
			var ht = default(ElaHeadTailPattern); 
			pat = null;
		.)
		"["
			[
				(.
					ht = new ElaHeadTailPattern(t);			
				.)
				AsPattern<out cexp> 
				(.  ht.Patterns.Add(cexp);  .)
				{ 
					"," AsPattern<out cexp> 
					(. ht.Patterns.Add(cexp); .)
				}
				(.
					ht.Patterns.Add(new ElaNilPattern(t));
					pat = ht;
				.)
			]
			(.
				if (pat == null)
					pat = new ElaNilPattern(t);
			.)
		"]".
			
	/* End Match */
		
		
	RecordLiteral<out ElaExpression exp> =
		(. 
			exp = null; 
			var fld = default(ElaFieldDeclaration);
		.)
		(
			"{"
				(. var rec = new ElaRecordLiteral(t); exp = rec; .) 
				RecordField<out fld> (. rec.Fields.Add(fld); .)				
				{ "," RecordField<out fld> (. rec.Fields.Add(fld); .) }
			"}"
		).
		
	RecordField<out ElaFieldDeclaration fld> = 
		(. 
			fld = null; 
			var cexp = default(ElaExpression);
			var mutable = false;
		.)
		(
			[ "!" (. mutable = true; .) ]
			(
				(
					ident 
					(. fld = new ElaFieldDeclaration(t) { FieldName = t.val, Mutable = mutable }; .) 
					[						
						"=" Expr<out cexp> 
						(. fld.FieldValue = cexp; .)
					]
					(.
						if (fld.FieldValue == null)
							fld.FieldValue = new ElaVariableReference(t) { VariableName = t.val };
					.)
				)
				|
				(
					stringTok
					(. fld = new ElaFieldDeclaration(t) { FieldName = ReadString(t.val), Mutable = mutable }; .) 
					"=" 
					Expr<out cexp> 
					(. fld.FieldValue = cexp; .)
				)
			)
		).
		
	RangeExpr<ElaExpression first, ElaExpression sec, out ElaRange rng> = 
		(. 
			rng = new ElaRange(t) { First = first, Second = sec };
			var cexp = default(ElaExpression);
		.)
		".."
		[
			Expr<out cexp>
			(. rng.Last = cexp; .)
		].
		
				
	ParamList<. out List<ElaExpression> list, out ElaComprehension comp, out ElaRange rng .> =
		(. 
			var exp = default(ElaExpression); 
			list = null;
			comp = null;
			rng = null;
		.)
		Expr<out exp> 
		[
			ComprehensionExpr<exp, out comp>
			| 
			RangeExpr<exp, null, out rng>
			|
			(
				(. var oexp = exp; .)
				"," Expr<out exp> 
				(
					RangeExpr<oexp, exp, out rng>
					|
					(
						(. 
							list = new List<ElaExpression>();
							list.Add(oexp);
							list.Add(exp);
						.)
						{ 
							"," Expr<out exp> 
							(. list.Add(exp); .)
						}
					)
				)
			)
		]
		(.
			if (list == null && comp == null && rng == null && exp != null)
			{
				list = new List<ElaExpression>();
				list.Add(exp);
			}
		.).
		
	ListLiteral<out ElaExpression exp> = 
		"["
			(. 
				var list = default(List<ElaExpression>);
				var comp = default(ElaComprehension);
				var rng = default(ElaRange);
				var ot = t;
				
				exp = null;
			.)
			[ 
				(
					ParamList<out list, out comp, out rng> 
					(. 
						if (list != null)
						{
							var listExp = new ElaListLiteral(ot) { Values = list };
							exp = listExp;	
						}
						else if (comp != null)
						{
							comp.Initial = new ElaListLiteral(ot);
							exp = comp;
						}
						else if (rng != null)
						{
							rng.Initial = new ElaListLiteral(ot);
							exp = rng;
						}
					.)
				)
				|
				(
					(. var cexp = default(ElaExpression); .)
					"&" Expr<out cexp> ComprehensionExpr<cexp, out comp>
					(. 
						comp.Lazy = true;
						comp.Initial = new ElaListLiteral(ot);
						exp = comp;
					.)
				)
			] 
			(.
				if (exp == null)
					exp = new ElaListLiteral(ot);
			.)
		"]".
		
	LetBinding<out ElaExpression exp> = 
		(. 
			exp = null; 
			var inExp = default(ElaExpression);
			var flags = default(ElaVariableFlags);
		.)
		SYNC LET [VariableAttributes<out flags>] 
		BindingBody<flags, out exp>
		WEAK IN Expr<out inExp>
		(. ((ElaBinding)exp).In = inExp; .).
		
	RootLetBinding<out ElaExpression exp> = 
		(. 
			exp = null; 
			var inExp = default(ElaExpression);
			var flags = default(ElaVariableFlags);
		.)
		(
			(. scanner.InjectBlock(); .) 
			SYNC LET 
			[VariableAttributes<out flags>] 
			BindingBody<flags, out exp>
			(
				(
					WEAK IN Expr<out inExp> 
					(. ((ElaBinding)exp).In = inExp; .)	
					EndBlock
				)
				|
				EndBlock
			)	
		).
		
		
	VariableAttributes<out ElaVariableFlags flags> =
		(. flags = ElaVariableFlags.None; .)
		(
			(
				"private" (. flags |= ElaVariableFlags.Private; .)
				[ "inline" (. flags |= ElaVariableFlags.Inline; .) ]
			)
			|
			(
				"inline" (. flags |= ElaVariableFlags.Inline; .)					
				[ "private" (. flags |= ElaVariableFlags.Private; .) ]
			)
		).			
		
	WhereBinding<out ElaExpression exp> = 
		(. scanner.InjectBlock(); .) 
		SYNC WHERE 
		BindingBody<ElaVariableFlags.None, out exp> 
		EndBlock.
		
	BindingGuard<out ElaExpression exp> = 
		(. exp = null; .)
		(
			BinaryExpr<out exp>
			{
				(. var old = exp; .)
				"," 
				(. var ot = t; .)
				BinaryExpr<out exp>
				(.
					exp = new ElaBinary(t) { Operator = ElaOperator.BooleanAnd, Left = old, Right = exp };
				.)
			}
		).
		
	BindingGuardList<ref ElaCondition cond> =
		(.
			var gexp = default(ElaExpression);
			var cexp = default(ElaExpression);
		.)
		(				
			"|" 
			(
				(
					(.
						var newCond = new ElaCondition(t);
						cond.False = newCond;
						cond = newCond;
					.)
					BindingGuard<out gexp> (. cond.Condition = gexp; .) "=" Expr<out cexp> (. cond.True = cexp; .)
					[ BindingGuardList<ref cond> ]
				)
				|
				(
					"else" "=" Expr<out cexp> (. cond.False = cexp; .)
				)
			)
		).
		
	BindingBody<ElaVariableFlags flags, out ElaExpression exp> =
		(. 
			var varExp = new ElaBinding(t) { VariableFlags = flags }; 
			exp = varExp;
			var cexp = default(ElaExpression); 
			var pat = default(ElaPattern);
		.)		
		(
			(
				ident
				(. varExp.VariableName = t.val; .)
				[
					  FunExpr<varExp>
					| BindingBodyGuards<varExp>
					| BindingBodyInit<varExp>
				]
				(. SetObjectMetadata(varExp, cexp); .)
			)
			| BindingPattern<out pat> (. varExp.Pattern = pat; .) [ BindingBodyInit<varExp> ]
			| BindingBodyOperator<varExp>
		)		
		[
			WEAK ET BindingBody<flags, out exp>
			(.
				((ElaBinding)varExp).And = (ElaBinding)exp;
				exp = varExp;
			.)
		].
			
	BindingBodyOperator<ElaBinding varExp> =
		(
			Operators
			(. varExp.VariableName = t.val; .)
			(
			
				(
					FunExpr<varExp>
					(. 
						var fun = (ElaFunctionLiteral)varExp.InitExpression;
						fun.FunctionType = ElaFunctionType.Operator;
					.)
				)
				|
				(
					BindingBodyInit<varExp>
					(. 
						if (varExp.InitExpression.Type == ElaNodeType.FunctionLiteral)
							((ElaFunctionLiteral)varExp.InitExpression).FunctionType = ElaFunctionType.Operator;
					.)
				)
			)
		).
		
	BindingBodyInit<ElaBinding varExp> =
		(. 
			var cexp = default(ElaExpression); 
			var cexp2 = default(ElaExpression);
		.)
		(
			"=" 
			(
				Expr<out cexp>
				|
				(
					"__internal" ident
					(. cexp = new ElaBuiltin(t) { Kind = Builtins.Kind(t.val) }; .)
				)
			)
			(. varExp.InitExpression = cexp; .)
			[
				WhereBinding<out cexp2> 
				(. varExp.Where = (ElaBinding)cexp2; .)
			]
		).
		
	BindingBodyGuards<ElaBinding varExp> = 
		(.
			var gexp = default(ElaExpression);
			var cexp3 = default(ElaExpression);
			var cond = new ElaCondition(t);
			varExp.InitExpression = cond;
		.)
		(
			"|" BindingGuard<out gexp> (. cond.Condition = gexp; .) 
			"=" Expr<out cexp3> (. cond.True = cexp3; .)
			BindingGuardList<ref cond>
		).
		
	Operators = operatorTok1|operatorTok2|operatorTok3|operatorTok4|operatorTok5|operatorTok6|operatorTok7|operatorTok8|"::".
		
	FunName<ElaFunctionLiteral fun> = 
		(
			(ident|Operators)
			(.
				if (t.val != fun.Name)
					AddError(ElaParserError.InvalidFunctionDeclaration, t.val);
			.)
		).
		
	FunExpr<ElaBinding varExp> =
		(
			(. 
				var ot = t;
				var mi = new ElaFunctionLiteral(t);
				mi.Name = varExp.VariableName;
				varExp.InitExpression = mi;
				mi.Body = new ElaMatch(t);
				scanner.InjectBlock(t.col);				
			.)	
			FunBodyExpr<mi>
			(. ProcessFunctionParameters(mi, ot); .)			
		).
		
	FunBodyExpr<ElaFunctionLiteral fun> =
		(.
			var ot = t;
			var match = fun.Body;
			var pat = default(ElaPattern);
			var seq = default(ElaPatternGroup);
			var cexp = default(ElaExpression);			
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)		
		(
			(	
				FuncPattern<out pat> (. entry.Pattern = pat; .)
				{ 
					FuncPattern<out pat> 
					(. 
						if (seq == null)
						{
							seq = new ElaPatternGroup(ot);
							seq.Patterns.Add(entry.Pattern);
							entry.Pattern = seq;							
						}
					
						seq.Patterns.Add(pat); 
					.) 
				} 				
			)
			[
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			(. if (RequireEndBlock()) .) EndBlock
			[ 
				(
					(
						(. scanner.InjectBlock(); .)
						FunName<fun> FunBodyExpr<fun>
					)
					| ChildFunBodyExpr<fun>
				)
			]
		).
		
	ChildFunBodyExpr<ElaFunctionLiteral fun> =
		(.
			var ot = t;
			var match = fun.Body;
			var cexp = default(ElaExpression);
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)
		(
			Guard<out cexp>
			(. entry.Guard = cexp; .)
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			(. if (RequireEndBlock()) .) EndBlock
			[ 
				(
					(
						(. scanner.InjectBlock(); .)
						FunName<fun> FunBodyExpr<fun>
					)
					| ChildFunBodyExpr<fun>
				)
			]
		).
		
	LambdaExpr<out ElaExpression exp> =
		SYNC LAMBDA
		(.
			var ot = t;
			var pat = default(ElaPattern);
			var seq = default(ElaPatternGroup);
			
			var mi = new ElaFunctionLiteral(t);
			exp = mi;
			var match = new ElaMatch(t);
			mi.Body = match;
			
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)
		(
			(		
				FuncPattern<out pat> (. entry.Pattern = pat; .)
				{ 
					FuncPattern<out pat> 
					(. 
						if (seq == null)
						{
							seq = new ElaPatternGroup(ot);
							seq.Patterns.Add(entry.Pattern);
							entry.Pattern = seq;							
						}
					
						seq.Patterns.Add(pat); 
					.) 
				} 				
			)
			[
				(. var cexp = default(ElaExpression); .)
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"->" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
		).
		
	IncludeStat<out ElaExpression exp> = 
		(. exp = null; .)
		(
			(. scanner.InjectBlock(); .)
			SYNC OPEN (. var inc = new ElaModuleInclude(t); .)
			Qualident<inc.Path>
			(.
				var name = inc.Path[inc.Path.Count - 1];				
				inc.Path.RemoveAt(inc.Path.Count - 1);				
				inc.Alias = inc.Name = name;
				exp = inc;
			.)	
			[
				"#"
				(
					ident (. inc.DllName = t.val; .)
					| 
					stringTok (. inc.DllName = ReadString(t.val); .)
				)
			]		
			[ "@" ident (. inc.Alias = t.val; .) ]
			EBLOCK
		).
		
	Qualident<. List<String> path .> = 
		(. var val = String.Empty; .)
		(
			ident (. val = t.val; .)
			| stringTok (. val = ReadString(t.val); .)
		)
		(. path.Add(val); .)
		[ "." Qualident<path> ].
	
	IfExpr<out ElaExpression exp> = 
		IFS
		(. 
			var cond = new ElaCondition(t); 
			var cexp = default(ElaExpression);	
			exp = cond;
		.)
		Expr<out cexp> (. cond.Condition = cexp; .)
		THEN Expr<out cexp> (. cond.True = cexp; .)
		WEAK ELSE Expr<out cexp> (. cond.False = cexp; .).
    
	RaiseExpr<out ElaExpression exp> = 
		RAISE
		(. 
			var r = new ElaRaise(t);
			exp = r;
			var cexp = default(ElaExpression); 
			var code = String.Empty;
		.)		
		ident (. code = t.val; .)
		[ "(" Expr<out cexp> ")" ]
		(. 
			r.ErrorCode = code;
			r.Expression = cexp; 
		.).
		
	FailExpr<out ElaExpression exp> = 
		FAIL
		(. 
			var r = new ElaRaise(t);
			exp = r;
			var cexp = default(ElaExpression); 
		.)		
		Expr<out cexp>
		(. 
			r.Expression = cexp; 
			r.ErrorCode = "Failure"; 
		.).	
		
	TryExpr<out ElaExpression exp> =
		(. scanner.InjectBlock(); .)
		TRY
		(. 
			var ot = t;
			var match = new ElaTry(t);
			exp = match; 
			var cexp = default(ElaExpression);
		.)		
		Expr<out cexp> (. match.Expression = cexp; .)
		WITH
		(
			(. scanner.InjectBlock(); .)
			MatchEntry<match> 
			EndBlock
			{ 
				(. scanner.InjectBlock(); .)
				MatchEntry<match> 
				EndBlock
			}
		)	
		EndBlock.
			
	/* Expr */
		
	AssignExpr<out ElaExpression exp> = 
		BackwardPipeExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			(
				"<-" (. op = ElaOperator.Assign; .)
				| "<->" (. op = ElaOperator.Swap; .)
			)			
			BackwardPipeExpr<out cexp>			
			(. exp = new ElaBinary(t) { Operator = op, Left = exp, Right = cexp }; .)
		}.
		
	BackwardPipeExpr<out ElaExpression exp> =
		ForwardPipeExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var ot = t;
				var mi = default(ElaFunctionCall);  
			.)
			(
				"<|" BackwardPipeExpr<out cexp>
				(. 
					if (mi == null)
					{
						mi = new ElaFunctionCall(ot) { Target = exp };
						exp = mi; 
					}
				
					mi.Parameters.Add(cexp); 
				.)
			)
		}.
		
	ForwardPipeExpr<out ElaExpression exp> = 
		OrExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
			.)
			(
				"|>"
				OrExpr<out cexp>
				(. 
					var mi = new ElaFunctionCall(t) { Target = cexp };
					mi.Parameters.Add(exp);
					exp = mi;
				.)
			)
		}.
				
	OrExpr<out ElaExpression exp> =
		AndExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"||" AndExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaOperator.BooleanOr, Right = cexp }; 
			.)			
		}.
		
	AndExpr<out ElaExpression exp> =
		OpExpr1<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"&&" OpExpr1<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaOperator.BooleanAnd, Right = cexp }; 
			.)
		}.	
			
	OpExpr1<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr2<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok1 (. op = t.val; .)
					[ OpExpr2<out cexp> ]
					(. 
						if (cexp == null)
							exp = GetOperatorFun(op, exp, null);
						else
							exp = GetBinaryFunction(op, exp, cexp);
					.)
				}
			)
			|
			(
				operatorTok1 (. op = t.val; .)
				[ 
					OpExpr2<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = op };
				.)
			)
		).
			
	OpExpr2<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr3<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok2 (. op = t.val; .)
					[ OpExpr3<out cexp> ]
					(. 
						if (cexp == null)
							exp = GetOperatorFun(op, exp, null);
						else
							exp = GetBinaryFunction(op, exp, cexp);
					.)
				}
			)
			|
			(
				operatorTok2 (. op = t.val; .)
				[ 
					OpExpr3<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
			
			
	OpExpr3<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr4<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					(operatorTok3|"::") (. op = t.val; .)
					[ OpExpr3<out cexp> ]
					(. 
						if (cexp == null)
							exp = GetOperatorFun(op, exp, null);
						else
							exp = GetBinaryFunction(op, exp, cexp);
					.)
				}			
			)
			|
			(
				(operatorTok3|"::") (. op = t.val; .)
				[ 
					OpExpr4<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	OpExpr4<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr5<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok4 (. op = t.val; .)
					[ OpExpr5<out cexp> ]
					(. 
						if (cexp == null)
							exp = GetOperatorFun(op, exp, null);
						else
							exp = GetBinaryFunction(op, exp, cexp);
					.)
				}
			)
			|
			(
				operatorTok4 (. op = t.val; .)
				[ 
					OpExpr5<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	OpExpr5<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				CastExpr<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok5 (. op = t.val; .)
					[ CastExpr<out cexp> ]
					(. 
						if (cexp == null)
							exp = GetOperatorFun(op, exp, null);
						else
							exp = GetBinaryFunction(op, exp, cexp);
					.)
				}
			)
			|
			(
				operatorTok5 (. op = t.val; .)
				[ 
					CastExpr<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	CastExpr<out ElaExpression exp> = 
		InfixExpr<out exp>
		{
			(
				(
					":" ident 
					(. exp = new ElaCast(t) { CastAffinity = GetType(t.val), Expression = exp };.)
				)
				|
				(
					(. var pat = default(ElaPattern); .)
					IS IsOperatorPattern<out pat> 
					(. exp = new ElaIs(t) { Expression = exp, Pattern = pat }; .)
				)
				|
				"@@" ComprehensionOpExpr<exp, out exp>
			)
		}.		
		
	ComprehensionOpExpr<ElaExpression init, out ElaExpression exp> =
		(.
			var list = default(List<ElaExpression>);
			var comp = default(ElaComprehension);
			var rng = default(ElaRange);
			exp = null;
		.)
		"["
			(
				ParamList<out list, out comp, out rng>
				(.
					if (rng != null) {
						rng.Initial = init;
						exp = rng;
					}
					else if (comp != null) {
						comp.Initial = init;
						exp = comp;
					}
					else {
						AddError(ElaParserError.ComprehensionOpInvalidOperand);
						exp = new ElaRange();
					}
				.)
			)
		"]".
		
	InfixExpr<out ElaExpression exp> = 
		(. 
			exp = null;
			var ot = t; 
			var name = String.Empty;
		.)				
		(
			(
				OpExpr6<out exp>
				{
					(. 
						var cexp = default(ElaExpression); 
						ot = t;
					.)
					(
						funcTok (. name = t.val.Trim('`'); .)
					)
					[ OpExpr6<out cexp> ]
					(. 
						var fc = new ElaFunctionCall(ot) { 
								Target = new ElaVariableReference(t) { VariableName = name }
							};
						fc.Parameters.Add(exp);			
						
						if (cexp != null)
							fc.Parameters.Add(cexp);
										
						exp = fc;
					.)
				}
			)
			|
			(
				(
					funcTok (. name = t.val.Trim('`'); .)
				)
				[ 
					OpExpr6<out exp> 
					(. exp = GetPrefixFun(name, exp, true);	.)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = name };
				.)				
			)
		).
		
	OpExpr6<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr7<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok6 (. op = t.val; .)
					[ OpExpr6<out cexp> ]
					(. 
						if (cexp == null)
							exp = GetOperatorFun(op, exp, null);
						else
							exp = GetBinaryFunction(op, exp, cexp);
					.)
				}			
			)
			|
			(
				operatorTok6 (. op = t.val; .)
				[ 
					OpExpr7<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	OpExpr7<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr8<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok7 (. op = t.val; .)
					[ OpExpr8<out cexp> ]
					(. 
						if (cexp == null)
							exp = GetOperatorFun(op, exp, null);
						else
							exp = GetBinaryFunction(op, exp, cexp);
					.)
				}			
			)
			|
			(
				operatorTok7 (. op = t.val; .)
				[ 
					OpExpr8<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	OpExpr8<out ElaExpression exp> = 
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)
		(
			(
				Application<out exp>
				{
					operatorTok8 (. op = t.val; .)
					(. exp = GetBinaryFunction(op, exp, null); .)
				}
			)
			|
			(
				operatorTok8 (. op = t.val; .)
				[ 
					Application<out exp> 
					(. exp = GetBinaryFunction(op, exp, null); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	Application<out ElaExpression exp> = 
		(. exp = null; .)
		(
			(
				AccessExpr<out exp>
				(. 
					var ot = t;
					var mi = default(ElaFunctionCall); 
					var cexp = default(ElaExpression);
				.)	
				{
					AccessExpr<out cexp>					
					(. 
						if (mi == null)
						{
							mi = new ElaFunctionCall(ot) { Target = exp };
							exp = mi; 
						}
					
						mi.Parameters.Add(cexp); 
					.)					
				}								
			)
			|
			VariantLiteral<out exp>				
		).
		
	AccessExpr<out ElaExpression exp> =
		Literal<out exp>
		{ 
			"."
			(
				(
					"["
						(.
							var indExp = new ElaIndexer(t) { TargetObject = exp };
							exp = indExp;
						.)
						(. var cexp = default(ElaExpression); .)
						Expr<out cexp>
						(. indExp.Index = cexp;	.)
					"]"
				)
				|
				(
					ident
					(. exp = new ElaFieldReference(t) { FieldName = t.val, TargetObject = exp }; .)
				)
			)			
		}.	
					
	BinaryExpr<out ElaExpression exp> = 
		(. 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				AssignExpr<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					"$"
					AssignExpr<out cexp>
					(. 
						exp = new ElaBinary(t) { Operator = ElaOperator.Sequence, Left = exp, Right = cexp };
					.)
				}
			)
		).	
		
	EmbExpr<out ElaExpression exp> = 
		(. exp = null; .)
		( 
			BinaryExpr<out exp>
			| IfExpr<out exp>
			| LambdaExpr<out exp>			
			| RaiseExpr<out exp>
			| FailExpr<out exp>
			| MatchExpr<out exp>		
			| TryExpr<out exp>			
		).
	
	Expr<out ElaExpression exp> = 
		(. exp = null; .)
		( 
			EmbExpr<out exp>	
			| LetBinding<out exp>
		).
		
	LazyExpr<out ElaExpression exp> =
		(
			"(&" 
				(. var lazy = new ElaLazyLiteral(t); .)
				Expr<out exp>
				(.
					var m = new ElaMatch(t);
					m.Entries.Add(new ElaMatchEntry { Pattern = new ElaUnitPattern(), Expression = exp });
					lazy.Body = m;
					exp = lazy;
				.)
			")"
		).
	
	ComprehensionExpr<ElaExpression sel, out ElaComprehension exp> =
		(. 	
			var it = default(ElaGenerator); 
			var ot = t;		
		.)
		"\\\\" ComprehensionEntry<sel, out it>
		(. exp = new ElaComprehension(ot) { Generator = it }; .).
		
	ComprehensionEntry<ElaExpression body, out ElaGenerator it> =
		(.
			it = new ElaGenerator(t);
			it.Body = body;
			var cexp = default(ElaExpression);
			var pat = default(ElaPattern);
		.)
		(
			GeneratorPattern<out pat> "<-" Expr<out cexp>
			(. 
				it.Pattern = pat;
				it.Target = cexp;
			.)
		)
		[ 
			(
				(. var cit = default(ElaGenerator); .)
				"," ComprehensionEntry<body, out cit>
				(. it.Body = cit; .)
			)
			|
			(
				Guard<out cexp>
				(. it.Guard = cexp; .)
			)
		].
		
	Ela = 
		(
			(.
				var b = new ElaBlock(t);
				Expression = b;
			.)			
			DeclarationBlock<b> { DeclarationBlock<b> }
		).		
		
	DeclarationBlock<ElaBlock b> =
		(. var exp = default(ElaExpression); .)
		(
			RootLetBinding<out exp>
			| IncludeStat<out exp>
			| EmbExpr<out exp> (. if (FALSE) .) EBLOCK			
		)
		(. b.Expressions.Add(exp); .).
		
END Ela.