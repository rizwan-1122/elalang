COMPILER Ela

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	newLine = cr + lf.
	tab = '\t'.    
	letter = 'A' .. 'Z' + 'a' .. 'z' + '_'.
	digit = "0123456789".
	notDigit = ANY - digit.
	hexDigit = digit + "ABCDEFabcdef".
	verbatimChar = ANY - '"'.
	stringChar = ANY - '"' - '\\' - newLine.
	char = ANY - "'" - '\\' - newLine.
	op = "!%&*+-.:/<=>?@^|~".

TOKENS
	ident = letter { letter | digit }
		| "'" letter { letter | digit }
		| letter { letter | digit } "'".	
	
	variantTok = "`"(
				letter { letter | digit }
				| "'" letter { letter | digit }
				| letter { letter | digit } "'"
			).
			
	argIdent = "$"(
					letter { letter | digit }
					| "'" letter { letter | digit }
					| letter { letter | digit } "'"
				).
	
	funcTok = "`"(
					letter { letter | digit }
					| "'" letter { letter | digit }
					| letter { letter | digit } "'"
				)
			"`".

	intTok = ( digit { digit } | digit { digit } CONTEXT ("." notDigit) | 
			( "0x" | "0X" ) hexDigit { hexDigit } ) [ "L" | "l" ].
			
	realTok = "." digit { digit } [ ( "e" | "E") [ "+" | "-" ] digit { digit } ] [ "D" | "d" ] 
			| digit { digit } 
			( 
				"." digit { digit } 
				[ ( "e" | "E" ) ["+" | "-" ] digit { digit } ] [ "D" | "d" ] 
				| ( "e" | "E") ["+" | "-" ] digit { digit } [ "D" | "d" ]  | "D" | "d" 
			).		
			
	stringTok = "\"" { stringChar
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					}  
				"\""
				| "@\"" {verbatimChar | "\"\""} "\"".
				
	charTok = 	"'" ( char
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					)  
				"'".
	operatorTok = op { op }.
	
	SEMI = ";".
	LBRA = "{".
	RBRA = "}".
	LILB = "[".
	LIRB = "]".
	ARLB = "[|".
	ARRB = "|]".
	
	ARROW = "->".
	LAMBDA = "\\".
	EQ = "=".
	SEQ = "$".
	MINUS = "-".
	
	DOT = ".".
	IN = "in".
	UPTO = "to".
	DOWNTO = "downto".
	BASE = "base".
	MATCH = "match".
	AS = "@".
	IS = "?".	
	LET = "let".
	PRIVATE = "private".
	OPEN = "open".	
	AT = "at".
	WITH = "with".
	WHILE = "while".
	DO = "do".
	FOR = "for".
	IFS = "if".
	ELSE = "else".
	THEN = "then".
	RAISE = "raise".
	RETURN = "return".
	BREAK = "break".
	CONTINUE = "continue".
	TRY = "try".
	TRUE = "true".
	FALSE = "false".
	FAIL = "fail".
	WHERE = "where".
	MUTABLE = "mutable".
	
	AND = "and".
	ENDS = "end".
	
COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/"
IGNORE cr + lf + tab

PRODUCTIONS
	Literal<out ElaExpression exp> = 
		(. exp = null; .)
		(	
			Primitive<out exp>
			| RecordLiteral<out exp>
			| ListLiteral<out exp>
			| ArrayLiteral<out exp>
			| TupleLiteral<out exp>
			| SimpleExpr<out exp>					
		).
		
	SimpleExpr<out ElaExpression exp> = 
		(. exp = null; .)
		(	
			ArgumentReference<out exp>
			| BaseReference<out exp>
			| VariableReference<out exp>			
			| MatchExpr<out exp>		
			| TryExpr<out exp>
			| LazyExpr<out exp>	
		).
		
	VariantLiteral<out ElaExpression exp> = 
		(. 
			exp = null; 
			var vl = default(ElaVariantLiteral);
		.)
		(
			variantTok 
			(. vl = new ElaVariantLiteral(t) { Tag = t.val.Substring(1) }; .)
			[ Literal<out exp> (. vl.Expression = exp; .) ]
			(. exp = vl; .)
		).
		
	Primitive<out ElaExpression exp> = 
		(. exp = null; .)
		(
			intTok  (. exp = new ElaPrimitive(t) { Value = ParseInt(t.val) };	.)
			| realTok (. exp = new ElaPrimitive(t) { Value = ParseReal(t.val) }; .)
			| stringTok (. exp = new ElaPrimitive(t) { Value = ParseString(t.val) }; .)
			| charTok (. exp = new ElaPrimitive(t) { Value = ParseChar(t.val) }; .)
			| TRUE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(true) }; .) 
			| FALSE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(false) }; .)
		).
		
	VariableReference<out ElaExpression exp> =
		(. exp = null; .)
		(
			ident (. exp = GetBuiltin(t, t.val); .)
			| "_" (. exp = new ElaPlaceholder(t); .)
		).
		
	TupleLiteral<out ElaExpression exp> =
		(. 
			var ot = default(Token);
			exp = null; 
		.)
		(
			"(" 
				(. ot = t; .)
				[ GroupExpr<out exp> ] 
			")"
		)
		(.
			if (exp == null)
				exp = new ElaUnitLiteral(ot);
		.).			
		
	GroupExpr<out ElaExpression exp> = 
		(. 
			exp = null; 
			var cexp = default(ElaExpression);
			var pat = default(ElaPattern); 
			var ot = t;
		.)
		(
			OperatorExpr<out exp>	
			|
			(
				MemberAccess<hiddenVar, out exp>
				(. exp = GetPartialFun(exp); .)
			)
			|
			(
				"?" 
				(. ot = t; .)
				IsOperatorPattern<out pat>
				(. exp = GetPartialFun(new ElaIs(ot) { Expression = hiddenVar, Pattern = pat }); .)
			)
			|
			(
				":" 
				(. ot = t; .)
				ident 
				(. exp = GetPartialFun(new ElaCast(ot) { CastAffinity = GetType(t.val), Expression = hiddenVar });.)
			)
			|
			(
				Expr<out exp>
				[
					(
						(. 
							var tuple = new ElaTupleLiteral(ot); 
							tuple.Parameters.Add(exp);
							exp = tuple; 
						.)		
						","
						(	
							[
								Expr<out cexp> 
								(. tuple.Parameters.Add(cexp); .)
							]
							{ "," Expr<out cexp> (. tuple.Parameters.Add(cexp); .) }
						)
					)
				]
			)
		).
		
	MemberAccess<ElaExpression target, out ElaExpression exp> =
		(. exp = null; .)
		"."
		(  
			(
				"["
					(.
						var indExp = new ElaIndexer(t) { TargetObject = target };
						exp = indExp;
					.)
					(. var cexp = default(ElaExpression); .)
					Expr<out cexp>
					(. indExp.Index = cexp;	.)
				"]"
			)
			|
			(
				ident
				(. exp = new ElaFieldReference(t) { FieldName = t.val, TargetObject = target }; .)
			)
		)
		[ MemberAccess<exp, out exp> ].
	
	ArgumentReference<out ElaExpression exp> =					
		argIdent (. exp = new ElaArgument(t) { ArgumentName = t.val.Substring(1) }; .).
		
	BaseReference<out ElaExpression exp> =
		(.
			var baseRef = default(ElaBaseReference);
			exp = null;
		.)
		(
			BASE 
			(. baseRef = new ElaBaseReference(t); .)
			"." 
			(. var ot = t; .)
			ident
			(. exp = new ElaFieldReference(ot) { FieldName = t.val, TargetObject = baseRef }; .)
		).
			
		
	/* Match */
	
	MatchExpr<out ElaExpression exp> = 
		MATCH
		(. 
			var match = new ElaMatch(t);
			exp = match; 
			var cexp = default(ElaExpression);
		.)
		Expr<out cexp> (. match.Expression = cexp; .)
		WITH
		(
			MatchEntry<match> { SEMI [MatchEntry<match>] }
		)		
		ENDS.
					
	MatchEntry<ElaMatch match> = 
		(. var cexp = default(ElaExpression); .)
		(		
			(. 
				var pat = default(ElaPattern); 
				var ot = t; 
			.)			
			[ RootPattern<out pat> ]
			(. 
				var entry = new ElaMatchEntry(ot);
				entry.Pattern = pat;				
				match.Entries.Add(entry);
			.)
			[ 
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
		)
		(	
			"=" Expr<out cexp>
			(. entry.Expression = cexp; .)	
		)
		[ 
			WhereBinding<out cexp> 
			(. entry.Where = cexp; .) 
		].
		
	Guard<out ElaExpression exp> = 
		(. exp = null; .)
		"|" 		
		(
			(
				BinaryExpr<out exp>
				{
					(. var old = exp; .)
					"," 
					(. var ot = t; .)
					BinaryExpr<out exp>
					(.
						exp = new ElaBinary(t) { Operator = ElaOperator.BooleanAnd, Left = old, Right = exp };
					.)
				}
			)
			| "else" (. exp = new ElaOtherwiseGuard(t); .)
		).	
		
	RootPattern<out ElaPattern pat> =
		OrPattern<out pat> 
		[ ConsPattern<pat, out pat> ].
		
	ParenPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			OrPattern<out pat> 
		)
		[ ConsPattern<pat, out pat> ]		
		[ TuplePattern<pat, out pat> ].
		
	VariantPattern<out ElaPattern pat> = 
		(. 
			pat = null; 
			var vp = default(ElaVariantPattern);
			var cpat = default(ElaPattern);
		.)
		(
			(
				variantTok (. vp = new ElaVariantPattern(t) { Tag = t.val.Substring(1) }; .)
				[ AsPattern<out cpat> (. vp.Pattern = cpat; .) ]
				(. pat = vp; .)
			)
			|
			(
				"`" (. vp = new ElaVariantPattern(t); .)
				[ AsPattern<out cpat> (. vp.Pattern = cpat; .) ]
				(. pat = vp; .)
			)
		).
			
	OrPattern<out ElaPattern pat> =	
		(. pat = null; .)
		(VariantPattern<out pat> | AsPattern<out pat>).
		
	FuncPattern<out ElaPattern pat> =
		AsPattern<out pat> [ ConsPattern<pat, out pat> ].
					
	SinglePattern<out ElaPattern pat> =			
		(. pat = null; .)
		(
			DefaultPattern<out pat>
			| UnitPattern<out pat>
			| LiteralPattern<out pat> 
			| ListPattern<out pat>
			| ArrayPattern<out pat>
			| RecordPattern<out pat>
			| IsPattern<out pat>
		).
			
	AsPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			SinglePattern<out pat>
			[
				"@" 
				(. 
					var asPat = new ElaAsPattern(t) { Pattern = pat }; 
					pat = asPat;				
				.)
				ident (. asPat.Name = t.val; .)
			]		
		).

	ArrayPattern<out ElaPattern pat> = 		
		(.
			var seq = new ElaArrayPattern(t); 
			var cpat = default(ElaPattern);
			pat = seq;
		.)
		"[|"
			(
				AsPattern<out cpat> 
				(.  seq.Patterns.Add(cpat);  .)
				{ 
					"," AsPattern<out cpat> 
					(. seq.Patterns.Add(cpat); .)
				}
			)
		"|]".
		
	UnitPattern<out ElaPattern pat> = 
		(.
			var ot = t;
			pat = null;
		.)
		(
			"(" [ ParenPattern<out pat> ] ")" 
		)
		(. 
			if (pat == null)
				pat = new ElaUnitPattern(ot); 
		.). 
		
	DefaultPattern<out ElaPattern pat> = 
		"_" (. pat = new ElaDefaultPattern(t); .). 
		
	BindingPattern<out string name, out ElaPattern pat> =
		(. pat = null; name = null; .)
		(
			ident (. name = t.val; .)
			|
			DefaultPattern<out pat>
			|
			RecordPattern<out pat>
			|
			ListPattern<out pat>
			|
			ArrayPattern<out pat>
			|
			"(" ParenPattern<out pat> ")" 
		).		
		
	ForeachPattern<out ElaPattern pat> =
		(. pat = null; string name = null; .)
		(
			ident (. name = t.val; .) (. pat = new ElaVariablePattern(t) { Name = name }; .)							
			|
			LiteralPattern<out pat>
			|
			RecordPattern<out pat>
			|
			ListPattern<out pat>
			|
			ArrayPattern<out pat>
			|
			UnitPattern<out pat>
		).
		
	IsOperatorPattern<out ElaPattern pat> = 
		(. pat = null; .)
		(
			ident (. pat = new ElaIsPattern(t) { TypeAffinity = GetType(t.val) }; .)
			|
			LiteralPattern<out pat>
			|
			RecordPattern<out pat>
			|
			ListPattern<out pat>
			|
			ArrayPattern<out pat>
			|
			UnitPattern<out pat>
			|
			TraitPattern<out pat>
		).
		
	TraitPattern<out ElaPattern pat> =
		(. 
			var trait = default(ElaTraits); 
			var isp = new ElaIsPattern(t);
			var tmp = default(ElaTraits);
		.)
		(
			"<"
				ident 
				(. 
					tmp = Builtins.Trait(t.val); 
					
					if (tmp == ElaTraits.None) {
						AddError(ElaParserError.UnknownTrait, t.val);
					}
					
					trait |= tmp;
				.)
				{ 
					"," ident 
					(. 
						tmp = Builtins.Trait(t.val); 
						
						if (tmp == ElaTraits.None) {
							AddError(ElaParserError.UnknownTrait, t.val);
						}
						
						trait |= tmp;
					.)
				}
			">"
		)
		(.
			isp.Traits = trait;
			pat = isp;
		.).
						
	IsPattern<out ElaPattern pat> =
		(. pat = null; .)
		ident (. var name = t.val; .)
		(			
			(
				"?"
				(
					(
						ident 
						(. 
							var typ = new ElaIsPattern(t) { VariableName = name }; 
							typ.TypeAffinity = GetType(t.val); 
							pat = typ;
						.)
					)
					|
					(
						TraitPattern<out pat>
						(. ((ElaIsPattern)pat).VariableName = name; .)
					)
				)
			)
			|
			(
				":" 
				(. var cst = new ElaCastPattern(t) { VariableName = name }; pat = cst; .)
				ident (. cst.TypeAffinity = GetType(t.val); .)
			)
			|
			(. pat = new ElaVariablePattern(t) { Name = t.val }; .)
		).	
		
	RecordPattern<out ElaPattern pat> = 
		(. 
			pat = null; 
			var cpat = default(ElaFieldPattern);
		.)
		(
			"{"
				(. 
					var rec = new ElaRecordPattern(t); 
					pat = rec; 
				.)				
				[
					FieldPattern<out cpat>
					(. rec.Fields.Add(cpat); .)
					{
						","
						FieldPattern<out cpat>
						(. rec.Fields.Add(cpat); .)
					}
				]
			"}"		
		).
		
	FieldPattern<out ElaFieldPattern fld> =
		(. 
			fld = null;
			var cpat = default(ElaPattern);
		.)
		(
			(
				stringTok
				(. fld = new ElaFieldPattern(t) { Name = ReadString(t.val) }; .)		
				"=" AsPattern<out cpat>
				(. fld.Value = cpat; .)
			)
			|
			(
				ident
				(. fld = new ElaFieldPattern(t) { Name = t.val }; .)		
				[
					"=" AsPattern<out cpat>
				]
				(. 
					if (cpat == null)
						cpat = new ElaVariablePattern(t) { Name = fld.Name };
					
					fld.Value = cpat; 
				.)
			)
		).	
			
	TuplePattern<ElaPattern prev, out ElaPattern pat> = 
		(.
			var seq = new ElaTuplePattern(t); 
			seq.Patterns.Add(prev);
			var cpat = default(ElaPattern);
			pat = seq;
		.)
		(
			"," 
			[
				AsPattern<out cpat> [ ConsPattern<cpat, out cpat> ]	
				(. seq.Patterns.Add(cpat); .)
				{ 
					"," 
					AsPattern<out cpat> [ ConsPattern<cpat, out cpat> ]	
					(. seq.Patterns.Add(cpat); .)
				}
			]
		).
			
	ConsPattern<ElaPattern prev, out ElaPattern exp> =
		(. 
			var cexp = default(ElaPattern); 
			var ht = new ElaHeadTailPattern(t); 
			ht.Patterns.Add(prev);
			exp = ht;				
		.)
		(
			"::" AsPattern<out cexp>
			(. ht.Patterns.Add(cexp); .)
			{
				"::" AsPattern<out cexp>
				(. ht.Patterns.Add(cexp); .)
			}
		).
				
	LiteralPattern<out ElaPattern pat> =
		(
			(. 
				var val = new ElaLiteralPattern(t); 
				pat = val;
			.) 
			(
				stringTok (. val.Value = ParseString(t.val); .)
				| charTok (. val.Value = ParseChar(t.val); .)
				| intTok (. val.Value = ParseInt(t.val); .)
				| realTok (. val.Value = ParseReal(t.val); .)
				|
				(
					"--"
					(
						intTok (. val.Value = ParseInt(t.val).MakeNegative(); .)
						| realTok (. val.Value = ParseReal(t.val).MakeNegative(); .)
					)
				)
				| "true" (. val.Value = new ElaLiteralValue(true); .)
				| "false" (. val.Value = new ElaLiteralValue(false); .)
			)
		).		
			
	ListPattern<out ElaPattern pat> = 
		(.
			var cexp = default(ElaPattern); 
			var ht = default(ElaHeadTailPattern); 
			pat = null;
		.)
		"["
			[
				(.
					ht = new ElaHeadTailPattern(t);			
				.)
				AsPattern<out cexp> 
				(.  ht.Patterns.Add(cexp);  .)
				{ 
					"," AsPattern<out cexp> 
					(. ht.Patterns.Add(cexp); .)
				}
				(.
					ht.Patterns.Add(new ElaNilPattern(t));
					pat = ht;
				.)
			]
			(.
				if (pat == null)
					pat = new ElaNilPattern(t);
			.)
		"]".
			
	/* End Match */
		
		
	RecordLiteral<out ElaExpression exp> =
		(. 
			exp = null; 
			var fld = default(ElaFieldDeclaration);
		.)
		(
			"{"
				(. var rec = new ElaRecordLiteral(t); exp = rec; .) 
				RecordField<out fld> (. rec.Fields.Add(fld); .)				
				{ "," RecordField<out fld> (. rec.Fields.Add(fld); .) }
			"}"
		).
		
	RecordField<out ElaFieldDeclaration fld> = 
		(. 
			fld = null; 
			var cexp = default(ElaExpression);
			var mutable = false;
		.)
		(
			[ "mutable" (. mutable = true; .) ]
			(
				(
					ident 
					(. fld = new ElaFieldDeclaration(t) { FieldName = t.val, Mutable = mutable }; .) 
					"=" 
					Expr<out cexp> 
					(. fld.FieldValue = cexp; .)
				)
				|
				(
					stringTok
					(. fld = new ElaFieldDeclaration(t) { FieldName = ReadString(t.val), Mutable = mutable }; .) 
					"=" 
					Expr<out cexp> 
					(. fld.FieldValue = cexp; .)
				)
			)
		).
		
	RangeExpr<ElaExpression first, ElaExpression sec, out ElaRange rng> = 
		(. 
			rng = new ElaRange(t) { First = first, Second = sec };
			var cexp = default(ElaExpression);
		.)
		".."
		[
			Expr<out cexp>
			(. rng.Last = cexp; .)
		].
		
				
	ParamList<. out List<ElaExpression> list, out ElaComprehension comp, out ElaRange rng .> =
		(. 
			var exp = default(ElaExpression); 
			list = null;
			comp = null;
			rng = null;
		.)
		Expr<out exp> 
		[
			ComprehensionExpr<exp, out comp>
			| 
			RangeExpr<exp, null, out rng>
			|
			(
				(. var oexp = exp; .)
				"," Expr<out exp> 
				(
					RangeExpr<oexp, exp, out rng>
					|
					(
						(. 
							list = new List<ElaExpression>();
							list.Add(oexp);
							list.Add(exp);
						.)
						{ 
							"," Expr<out exp> 
							(. list.Add(exp); .)
						}
					)
				)
			)
		]
		(.
			if (list == null && comp == null && rng == null && exp != null)
			{
				list = new List<ElaExpression>();
				list.Add(exp);
			}
		.).
		
	ListLiteral<out ElaExpression exp> = 
		"["
			(. 
				var list = default(List<ElaExpression>);
				var comp = default(ElaComprehension);
				var rng = default(ElaRange);
				var ot = t;
				
				exp = null;
			.)
			[ 
				(
					ParamList<out list, out comp, out rng> 
					(. 
						if (list != null)
						{
							var listExp = new ElaListLiteral(ot) { Values = list };
							exp = listExp;	
						}
						else if (comp != null)
						{
							comp.Initial = new ElaListLiteral(ot);
							exp = comp;
						}
						else if (rng != null)
						{
							rng.Initial = new ElaListLiteral(ot);
							exp = rng;
						}
					.)
				)
				|
				(
					(. var cexp = default(ElaExpression); .)
					"&" Expr<out cexp> ComprehensionExpr<cexp, out comp>
					(. 
						comp.Lazy = true;
						comp.Initial = new ElaListLiteral(ot);
						exp = comp;
					.)
				)
			] 
			(.
				if (exp == null)
					exp = new ElaListLiteral(ot);
			.)
		"]".
		
	ArrayLiteral<out ElaExpression exp> = 
		"[|"
			(. 
				var list = default(List<ElaExpression>);
				var comp = default(ElaComprehension);
				var rng = default(ElaRange);
				var ot = t;
				
				exp = null;
			.)
			[ 
				(
					ParamList<out list, out comp, out rng> 
					(. 
						if (list != null)
						{
							var arrExp = new ElaArrayLiteral(ot) { Values = list };
							exp = arrExp;	
						}
						else if (comp != null)
						{
							comp.Initial = new ElaArrayLiteral(ot);
							exp = comp;
						}
						else if (rng != null)
						{
							rng.Initial = new ElaArrayLiteral(ot);
							exp = rng;
						}
					.)
				)
			]
			(.
				if (exp == null)
					exp = new ElaArrayLiteral(ot);
			.)
		"|]".
					
	LetBinding<out ElaExpression exp> = 
		(. 
			exp = null; 
			var flags = ElaVariableFlags.Immutable;
			var inExp = default(ElaExpression);
		.)
		LET [VariableAttributes<out flags>] VariableDeclarationBody<flags, out exp>
		IN Expr<out inExp> 
		(. ((ElaBinding)exp).In = inExp; .).					
		
	RootLetBinding<out ElaExpression exp> = 
		(. 
			exp = null; 
			var flags = ElaVariableFlags.Immutable;
			var inExp = default(ElaExpression);
		.)
		LET [VariableAttributes<out flags>] VariableDeclarationBody<flags, out exp>
		[
			IN Expr<out inExp> 
			(. ((ElaBinding)exp).In = inExp; .)
		].
		
	VariableAttributes<out ElaVariableFlags flags> =
		(. flags = ElaVariableFlags.Immutable; .)
		(
			(
				"mutable" (. flags ^= ElaVariableFlags.Immutable; .)
				[ "private" (. flags |= ElaVariableFlags.Private; .) ]
			)
			|
			(
				"private" (. flags |= ElaVariableFlags.Private; .)				
				[ "mutable" (. flags ^= ElaVariableFlags.Immutable; .) ]
			)
		).
			
		
	WhereBinding<out ElaExpression exp> = WHERE WhereBindingBody<out exp> ENDS.
	
	WhereBindingBody<out ElaExpression exp> =
		(. 
			var varExp = new ElaBinding(t) { VariableFlags = ElaVariableFlags.Immutable }; 
			exp = varExp;
			var cexp = default(ElaExpression); 
		.)		
		(
			(
				(. var pat = default(ElaPattern); string name = null; .)
				BindingPattern<out name, out pat>
				(. 
					if (name != null)
						varExp.VariableName = name;
					else
						varExp.Pattern = pat; 
				.)	
				(
					(
						"=" Expr<out cexp>
						(. varExp.InitExpression = cexp; .)
					)
					|
					(
						(.
							var gexp = default(ElaExpression);
							var cexp3 = default(ElaExpression);
							var cond = new ElaCondition(t);
							varExp.InitExpression = cond;
						.)
						(
							"|" BindingGuard<out gexp> (. cond.Condition = gexp; .) "=" Expr<out cexp3> (. cond.True = cexp3; .) SEMI
							BindingGuardList<ref cond>
						)
					)
					|
					(
						(. if (name == null) AddError(ElaParserError.InvalidFunctionDeclaration); .)				
						FunExpr<out cexp>
						(. varExp.InitExpression = cexp; .)
					)
				)
				(. SetFunMetadata(varExp, cexp, ElaVariableFlags.Immutable); .)
			)
			[ 
				(. var cd = default(ElaExpression); .)
				AND WhereBindingBody<out cd>
				(. varExp.And = (ElaBinding)cd; .)
			]
		).
		
	BindingGuard<out ElaExpression exp> = 
		(. exp = null; .)
		(
			BinaryExpr<out exp>
			{
				(. var old = exp; .)
				"," 
				(. var ot = t; .)
				BinaryExpr<out exp>
				(.
					exp = new ElaBinary(t) { Operator = ElaOperator.BooleanAnd, Left = old, Right = exp };
				.)
			}
		).
		
	BindingGuardList<ref ElaCondition cond> =
		(.
			var gexp = default(ElaExpression);
			var cexp = default(ElaExpression);
		.)
		(				
			"|" 
			(
				(
					(.
						var newCond = new ElaCondition(t);
						cond.False = newCond;
						cond = newCond;
					.)
					BindingGuard<out gexp> (. cond.Condition = gexp; .) "=" Expr<out cexp> (. cond.True = cexp; .)
					[ SEMI BindingGuardList<ref cond> ]
				)
				|
				(
					"else" "=" Expr<out cexp> (. cond.False = cexp; .)
				)
			)
		).
		
	VariableDeclarationBody<ElaVariableFlags flags, out ElaExpression exp> =
		(. 
			var varExp = new ElaBinding(t) { VariableFlags = flags }; 
			exp = varExp;
			var cexp = default(ElaExpression); 
		.)		
		(
			(
				(. var pat = default(ElaPattern); string name = null; .)
				BindingPattern<out name, out pat>
				(. 
					if (name != null)
						varExp.VariableName = name;
					else
						varExp.Pattern = pat; 
				.)	
				[
					(
						(. if (name == null) AddError(ElaParserError.InvalidFunctionDeclaration); .)				
						FunExpr<out cexp>
						(. varExp.InitExpression = cexp; .)
					)
					|
					(
						(.
							var gexp = default(ElaExpression);
							var cexp3 = default(ElaExpression);
							var cond = new ElaCondition(t);
							varExp.InitExpression = cond;
						.)
						(
							"|" BindingGuard<out gexp> (. cond.Condition = gexp; .) "=" Expr<out cexp3> (. cond.True = cexp3; .) SEMI
							BindingGuardList<ref cond>
						)
					)
					| 
					(
						"=" Expr<out cexp>
						(. varExp.InitExpression = cexp; .)
						[
							(. var cexp2 = default(ElaExpression); .)
							WhereBinding<out cexp2> 
							(. varExp.Where = (ElaBinding)cexp2; .)
						]
					)
				]
				(. SetFunMetadata(varExp, cexp, flags); .)
			)
			|
			(
				operatorTok (. varExp.VariableName = t.val; .)
				FunExpr<out cexp>
				(. 
					 varExp.InitExpression = cexp; 
					((ElaFunctionLiteral)cexp).FunctionType = ElaFunctionType.Operator; 
					((ElaFunctionLiteral)cexp).Name = varExp.VariableName;
				.)
			)
		)
		[
			AND VariableDeclarationBody<flags, out exp>
			(.
				((ElaBinding)varExp).And = (ElaBinding)exp;
				exp = varExp;
			.)
		].
			
	FunExpr<out ElaExpression exp> =
		(
			(. 
				var ot = t;
				var mi = new ElaFunctionLiteral(t);
				exp = mi;
				mi.Body = new ElaMatch(t);
			.)	
			FunBodyExpr<mi.Body>
			(. 
				if (mi.Body.Entries.Count > 1)
				{
					var patterns = default(List<ElaPattern>);
					var pars = 0;
				
					if (mi.Body.Entries[0].Pattern.Type != ElaNodeType.PatternGroup)
						pars = 1;
					else
					{
						patterns = ((ElaPatternGroup)mi.Body.Entries[0].Pattern).Patterns;
						pars = patterns.Count;
					}
								
					var tp = new ElaTupleLiteral(ot);
					
					for (var i = 0; i < pars; i++)
					{
						if (patterns != null && patterns[i].Type == ElaNodeType.VariablePattern)
						{
							tp.Parameters.Add(new ElaVariableReference(ot) {
								VariableName = ((ElaVariablePattern)patterns[i]).Name
							});
						}
						else
							tp.Parameters.Add(new ElaVariableReference(ot) { VariableName = "$" + i });
					}
					
					mi.Body.Expression = tp;
				}
			.)			
		).
		
	FunBodyExpr<ElaMatch match> =
		(.
			var ot = t;
			var pat = default(ElaPattern);
			var seq = default(ElaPatternGroup);
			var cexp = default(ElaExpression);
			
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)
		(
			(	
				FuncPattern<out pat> (. entry.Pattern = pat; .)
				{ 
					FuncPattern<out pat> 
					(. 
						if (seq == null)
						{
							seq = new ElaPatternGroup(ot);
							seq.Patterns.Add(entry.Pattern);
							entry.Pattern = seq;							
						}
					
						seq.Patterns.Add(pat); 
					.) 
				} 				
			)
			[
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			[ SEMI [ChildFunBodyExpr<match>] ]
		).
		
	ChildFunBodyExpr<ElaMatch match> =
		(.
			var ot = t;
			var pat = default(ElaPattern);
			var seq = default(ElaPatternGroup);
			var cexp = default(ElaExpression);
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)
		(
			[	
				FuncPattern<out pat> (. entry.Pattern = pat; .)
				{ 
					FuncPattern<out pat> 
					(. 
						if (seq == null)
						{
							seq = new ElaPatternGroup(ot);
							seq.Patterns.Add(entry.Pattern);
							entry.Pattern = seq;							
						}
					
						seq.Patterns.Add(pat); 
					.) 
				} 				
			]
			[
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			[ SEMI [ChildFunBodyExpr<match>] ]
		).
		
	LambdaBodyExpr<ElaMatch match> =
		(.
			var ot = t;
			var pat = default(ElaPattern);
			var seq = default(ElaPatternGroup);
			
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)
		(
			(		
				FuncPattern<out pat> (. entry.Pattern = pat; .)
				{ 
					FuncPattern<out pat> 
					(. 
						if (seq == null)
						{
							seq = new ElaPatternGroup(ot);
							seq.Patterns.Add(entry.Pattern);
							entry.Pattern = seq;							
						}
					
						seq.Patterns.Add(pat); 
					.) 
				} 				
			)
			[
				(. var cexp = default(ElaExpression); .)
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"->" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
		).
		
	IncludeStat<out ElaExpression exp> = 
		(. exp = null; .)
		(
			OPEN (. var inc = new ElaModuleInclude(t); .)
			ident
			(.
				inc.Alias = inc.Name = t.val;
				exp = inc;
			.)	
			[
				"["
				(
					ident (. inc.DllName = t.val; .)
					| 
					stringTok (. inc.DllName = ReadString(t.val); .)
				)
				"]"
			]		
			[ AT stringTok (. inc.Folder = ReadString(t.val); .) ]
			[ AS ident (. inc.Alias = t.val; .) ]
			[ WITH IncludeImports<inc> ]
		).
		
	IncludeImports<ElaModuleInclude inc> =
		(
			ident 
			(. 
				var imp = new ElaImportedName(t) { LocalName = t.val, ExternalName = t.val }; 
				inc.Imports.Add(imp); 
			.) 
			[ "=" ident (. imp.ExternalName = t.val; .) ]
		)
		[ "," IncludeImports<inc> ].
				
	WhileExpr<out ElaExpression exp> = 
		(
			WHILE
			(.
				var wex = new ElaWhile(t);
				exp = wex;
				var cexp = default(ElaExpression);
			.)
			Expr<out cexp> (. wex.Condition = cexp; .)
			DO Expr<out cexp>
			(. wex.Body = cexp; .)
		).
		
	ForExpr<out ElaExpression exp> = 
		FOR
		(. 
			var ot = t;
			var it = new ElaFor(t);
			exp = it;
			var cexp = default(ElaExpression);
			var pat = default(ElaPattern);
		.)
		(
			ForeachPattern<out pat> 			
			[ "=" BinaryExpr<out cexp> (. it.InitExpression = cexp; .) ]
			[ 
				Guard<out cexp>
				(. it.Guard = cexp; .)				
			]	
			(. it.Pattern = pat; .)
			(
				IN (. it.ForType = ElaForType.Foreach; .)
				| UPTO (. it.ForType = ElaForType.ForTo; .)
				| DOWNTO (. it.ForType = ElaForType.ForDownto; .)
			)
			Expr<out cexp> (. it.Target = cexp; .)
		)
		DO Expr<out cexp>
		(. it.Body = cexp; .).
	
	IfExpr<out ElaExpression exp> = 
		IFS
		(. 
			var cond = new ElaCondition(t); 
			var cexp = default(ElaExpression);	
			exp = cond;
		.)
		Expr<out cexp> (. cond.Condition = cexp; .)
		THEN Expr<out cexp> (. cond.True = cexp; .)
		ELSE Expr<out cexp> (. cond.False = cexp; .).
    
	RaiseExpr<out ElaExpression exp> = 
		RAISE
		(. 
			var r = new ElaRaise(t);
			exp = r;
			var cexp = default(ElaExpression); 
			var code = String.Empty;
		.)		
		ident (. code = t.val; .)
		[ "(" Expr<out cexp> ")" ]
		(. 
			r.ErrorCode = code;
			r.Expression = cexp; 
		.).
		
	FailExpr<out ElaExpression exp> = 
		FAIL
		(. 
			var r = new ElaRaise(t);
			exp = r;
			var cexp = default(ElaExpression); 
		.)		
		Expr<out cexp>
		(. 
			r.Expression = cexp; 
			r.ErrorCode = "Failure"; 
		.).	
		
	ReturnExpr<out ElaExpression exp> = 
		RETURN 
		(. var cexp = default(ElaExpression);.)
		Expr<out cexp>
		(. exp = new ElaReturn(t) { Expression = cexp }; .).		
		
	BreakExpr<out ElaExpression exp> = 
		BREAK (. exp = new ElaBreak(t); .).
			
	ContinueExpr<out ElaExpression exp> = 
		CONTINUE (. exp = new ElaContinue(t); .).
		
	TryExpr<out ElaExpression exp> =
		TRY
		(. 
			var ot = t;
			var match = new ElaTry(t);
			exp = match; 
			var cexp = default(ElaExpression);
		.)		
		Expr<out cexp> (. match.Expression = cexp; .)
		WITH
		(
			MatchEntry<match> { SEMI [MatchEntry<match>] }
		)
		ENDS.
			
	/* Expr */
		
	AssignExpr<out ElaExpression exp> = 
		BackwardPipeExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			(
				"<-" (. op = ElaOperator.Assign; .)
				| "<->" (. op = ElaOperator.Swap; .)
			)			
			BackwardPipeExpr<out cexp>			
			(. exp = new ElaBinary(t) { Operator = op, Left = exp, Right = cexp }; .)
		}.
		
	BackwardPipeExpr<out ElaExpression exp> =
		ForwardPipeExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var ot = t;
				var mi = default(ElaFunctionCall);  
			.)
			(
				"<|" ForwardPipeExpr<out cexp>
				(. 
					if (mi == null)
					{
						mi = new ElaFunctionCall(ot) { Target = exp };
						exp = mi; 
					}
				
					mi.Parameters.Add(cexp); 
				.)
			)
		}.
		
	ForwardPipeExpr<out ElaExpression exp> = 
		OrExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
			.)
			(
				"|>"
				OrExpr<out cexp>
				(. 
					var mi = new ElaFunctionCall(t) { Target = cexp };
					mi.Parameters.Add(exp);
					exp = mi;
				.)
			)
		}.
				
	OrExpr<out ElaExpression exp> =
		AndExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"||" AndExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaOperator.BooleanOr, Right = cexp }; 
			.)			
		}.
		
	AndExpr<out ElaExpression exp> =
		EqExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"&&" EqExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaOperator.BooleanAnd, Right = cexp }; 
			.)
		}.	
			
	EqExpr<out ElaExpression exp> =
		ShiftExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			(
				"==" (. op = ElaOperator.Equals; .)
				| "<>" (. op = ElaOperator.NotEquals; .)
				| ">" (. op = ElaOperator.Greater; .)
				| "<" (. op = ElaOperator.Lesser; .)
				| ">=" (. op = ElaOperator.GreaterEqual; .)
				| "<=" (. op = ElaOperator.LesserEqual; .)
			)
			[ ShiftExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, op, false);
				else
					exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
			
	ShiftExpr<out ElaExpression exp> =
		ConcatExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			(
				">>>" (. op = ElaOperator.ShiftRight; .) |
				"<<<" (. op = ElaOperator.ShiftLeft; .)
			)
			[ ConcatExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, op, false);
				else
					exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
				
	ConcatExpr<out ElaExpression exp> =
		ConsExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			"++" (. op = ElaOperator.Concat; .)
			[ ConsExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, op, false);
				else
					exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
		
	ConsExpr<out ElaExpression exp> =
		AddExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			"::" (. op = ElaOperator.ConsList; .)
			[ ConsExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, op, false);
				else
					exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp };
			.)
		}.				
		
	AddExpr<out ElaExpression exp> =
		MulExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			(
				"+" (. op = ElaOperator.Add; .) |
				"-" (. op = ElaOperator.Subtract; .)
			)
			[ MulExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, op, false);
				else
					exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
		
	MulExpr<out ElaExpression exp> =
		CastExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			(
				"*" (. op = ElaOperator.Multiply; .) |
				"/" (. op = ElaOperator.Divide; .) |
				"%" (. op = ElaOperator.Modulus; .) |
				"**" (. op = ElaOperator.Power; .)
			)
			[ CastExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, op, false);
				else
					exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
		
	CastExpr<out ElaExpression exp> = 
		InfixExpr<out exp>
		{
			(
				(
					":" ident 
					(. exp = new ElaCast(t) { CastAffinity = GetType(t.val), Expression = exp };.)
				)
				|
				(
					(. var pat = default(ElaPattern); .)
					"?" IsOperatorPattern<out pat> 
					(. exp = new ElaIs(t) { Expression = exp, Pattern = pat }; .)
				)
				|
				(
					(. 
						var comp = default(ElaComprehension); 
						var cexp = default(ElaExpression);
					.)
					"@@" "[" Expr<out cexp> ComprehensionExpr<cexp, out comp> "]"
					(. 
						comp.Initial = exp;
						exp = comp; 
					.)
				)
			)
		}.		
		
	InfixExpr<out ElaExpression exp> = 
		BitOrExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = ElaOperator.None;
				var name = String.Empty;
				var ot = t;
			.)
			(
				operatorTok (. op = ElaOperator.Custom; name = t.val; .)
				| funcTok (. name = t.val.Trim('`'); .)
			)
			[ BitOrExpr<out cexp> ]
			(. 
				if (op == ElaOperator.None)
				{
					var fc = new ElaFunctionCall(ot) 
					{ 
						Target = GetBuiltin(ot, name)
					};
					fc.Parameters.Add(exp);			
					
					if (cexp != null)
						fc.Parameters.Add(cexp);
									
					exp = fc;
				}
				else
					exp = new ElaBinary(t) { CustomOperator = name, Left = exp, Operator = op, Right = cexp }; 
			.)
		}.
		
	BitOrExpr<out ElaExpression exp> =
		BitXorExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"|||" 
			[ BitXorExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, ElaOperator.BitwiseOr, false);
				else
					exp = new ElaBinary(t) { 
						Left = exp, Operator = ElaOperator.BitwiseOr, Right = cexp }; 
			.)
		}.
		
	BitXorExpr<out ElaExpression exp> =
		BitAndExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"^^^" 
			[ BitAndExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, ElaOperator.BitwiseXor, false);
				else
					exp = new ElaBinary(t) { 
						Left = exp, Operator = ElaOperator.BitwiseXor, Right = cexp }; 
			.)
		}.
		
	BitAndExpr<out ElaExpression exp> =
		BackwardCompExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"&&&" 
			[ BackwardCompExpr<out cexp> ]
			(. 
				if (cexp == null)
					exp = GetOperatorFun(exp, ElaOperator.BitwiseAnd, false);
				else
					exp = new ElaBinary(t) { 
						Left = exp, Operator = ElaOperator.BitwiseAnd, Right = cexp }; 
			.)
		}.
		
	BackwardCompExpr<out ElaExpression exp> = 
		ForwardCompExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			(
				"<<" (. op = ElaOperator.CompBackward; .)		
				[ ForwardCompExpr<out cexp> ]
				(. 
					if (cexp == null)
						exp = GetOperatorFun(exp, op, true);
					else
						exp = new ElaBinary(t) { Right = exp, Operator = op, Left = cexp }; 
				.)
			)
		}.
		
	ForwardCompExpr<out ElaExpression exp> = 
		UnaryExpr<out exp>
		{
			(. 
				var cexp = default(ElaExpression); 
				var op = default(ElaOperator);
			.)
			(
				">>" (. op = ElaOperator.CompForward; .)
				[ ForwardCompExpr<out cexp> ]
				(. 
					if (cexp == null)
						exp = GetOperatorFun(exp, op, false);
					else
						exp = new ElaBinary(t) { Left = exp, Operator = op, Right = cexp }; 
				.)
			)
		}.		
	
		
	UnaryExpr<out ElaExpression exp> =
		(. exp = null; .)
		(
			(
				"--" [ Application<out exp> ]
				(. 
					if (exp == null)
						exp = new ElaBuiltinFunction(t) { Kind = ElaBuiltinFunctionKind.Negate };
					else
						exp = new ElaUnary(t) { Expression = exp, Operator = ElaUnaryOperator.Negate }; 
				.) 
			)
			| 
			(
				"~~~" [ Application<out exp> ]
				(. 
					if (exp == null)
						exp = new ElaBuiltinFunction(t) { Kind = ElaBuiltinFunctionKind.Bitnot };
					else
						exp = new ElaUnary(t) { Expression = exp, Operator = ElaUnaryOperator.BitwiseNot };
				.) 
			)
			| 
			Application<out exp>
		).
		
	Application<out ElaExpression exp> = 
		(. exp = null; .)
		(
			(
				AccessExpr<out exp>
				(. 
					var ot = t;
					var mi = default(ElaFunctionCall); 
					var cexp = default(ElaExpression);
				.)	
				{
					AccessExpr<out cexp>					
					(. 
						if (mi == null)
						{
							mi = new ElaFunctionCall(ot) { Target = exp };
							exp = mi; 
						}
					
						mi.Parameters.Add(cexp); 
					.)
				}
			)
			|
			VariantLiteral<out exp>				
		).
		
	AccessExpr<out ElaExpression exp> =
		Literal<out exp>
		{ 
			"."
			(
				(
					"["
						(.
							var indExp = new ElaIndexer(t) { TargetObject = exp };
							exp = indExp;
						.)
						(. var cexp = default(ElaExpression); .)
						Expr<out cexp>
						(. indExp.Index = cexp;	.)
					"]"
				)
				|
				(
					ident
					(. exp = new ElaFieldReference(t) { FieldName = t.val, TargetObject = exp }; .)
				)
			)			
		}.			
		
	FuncOperator<out ElaOperator op> =
		(. op = ElaOperator.None; .)
		(
			"+" (. op = ElaOperator.Add; .)
			| "-" (. op = ElaOperator.Subtract; .)
			| "*" (. op = ElaOperator.Multiply; .)
			| "/" (. op = ElaOperator.Divide; .)
			| "%" (. op = ElaOperator.Modulus; .)
			| "**" (. op = ElaOperator.Power; .)
			| "==" (. op = ElaOperator.Equals; .)
			| "<>" (. op = ElaOperator.NotEquals; .)
			| ">" (. op = ElaOperator.Greater; .)
			| "<" (. op = ElaOperator.Lesser; .)
			| "<=" (. op = ElaOperator.LesserEqual; .)
			| ">=" (. op = ElaOperator.GreaterEqual; .)
			| ">>" (. op = ElaOperator.CompForward; .)
			| "<<" (. op = ElaOperator.CompBackward; .)
			| "::" (. op = ElaOperator.ConsList; .)			
			| "&&" (. op = ElaOperator.BooleanAnd; .)
			| "||" (. op = ElaOperator.BooleanOr; .)
			| "&&&" (. op = ElaOperator.BitwiseAnd; .)
			| "|||" (. op = ElaOperator.BitwiseOr; .)
			| "^^^" (. op = ElaOperator.BitwiseXor; .)
			| "<<<" (. op = ElaOperator.ShiftLeft; .)
			| ">>>" (. op = ElaOperator.ShiftRight; .)			
			| "++" (. op = ElaOperator.Concat; .)
		).
		
	OperatorExpr<out ElaExpression exp> =
		(. 
			exp = null; 
			var ot = t;
			var op = ElaOperator.None;
			var opName = String.Empty;
			var funName = String.Empty;
		.)
		(
			FuncOperator<out op>
			| operatorTok (. opName = t.val; .)
			| funcTok (. funName = t.val.Trim('`'); .)
		)
		[
			(. var nexp = default(ElaExpression);  .)
			Literal<out nexp>
			(.
				exp = 
					funName.Length != 0 ? GetPrefixFun(funName, nexp, true) :
					opName.Length != 0 ? GetCustomOperatorFun(opName, nexp) :
					GetOperatorFun(nexp, op, true);
			.)
		]
		(.
			if (exp == null)
			{
				if (opName.Length == 0 && funName.Length == 0)
					exp = new ElaBuiltinFunction(ot) 
					{ 
						Kind = ElaBuiltinFunctionKind.Operator,
						Operator = op
					};
				else 
					exp = new ElaCustomOperator(ot) { Operator = opName };
			}
		.).
					
	LambdaExpr<out ElaExpression exp> =
		(. exp = null; .)
		(
			LAMBDA 		
			(
				(. 
					var ot = t;
					var mi = new ElaFunctionLiteral(t);
					exp = mi;
					mi.Body = new ElaMatch(t);
				.)	
				LambdaBodyExpr<mi.Body>
			)
		).
					
	BinaryExpr<out ElaExpression exp> = 
		AssignExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"$" 
			(. var ot = t; .)
			AssignExpr<out cexp>
			(. 
				exp = new ElaBinary(ot) { Left = exp, Right = cexp, Operator = ElaOperator.Sequence };
			.)
		}.
		
	EmbExpr<out ElaExpression exp> = 
		(. exp = null; .)
		( 
			BinaryExpr<out exp>
			| IfExpr<out exp>
			| LambdaExpr<out exp>
			
			| IterExpr<out exp>
			| ReturnExpr<out exp>
			| BreakExpr<out exp>
			| ContinueExpr<out exp>
			
			| RaiseExpr<out exp>
			| FailExpr<out exp>
		).
	
	Expr<out ElaExpression exp> = 
		(. exp = null; .)
		( 
			EmbExpr<out exp>	
			| LetBinding<out exp>
		).
		
	LazyExpr<out ElaExpression exp> =
		(
			"(&" 
				(. var lazy = new ElaLazyLiteral(t); .)
				Expr<out exp>
				(.
					var m = new ElaMatch(t);
					m.Entries.Add(new ElaMatchEntry { Pattern = new ElaUnitPattern(), Expression = exp });
					lazy.Body = m;
					exp = lazy;
				.)
			")"
		).
		
	IterExpr<out ElaExpression exp> =
		(. exp = null; .)
		(
			WhileExpr<out exp>	
			| ForExpr<out exp>
		).
	
	ComprehensionExpr<ElaExpression sel, out ElaComprehension exp> =
		(. 	
			var it = default(ElaFor); 
			var ot = t;		
		.)
		"@" ComprehensionEntry<sel, out it>
		(. exp = new ElaComprehension(ot) { Generator = it }; .).
		
	ComprehensionEntry<ElaExpression body, out ElaFor it> =
		(.
			it = new ElaFor(t) { 
				ForType = ElaForType.Foreach
			};
			var cexp = default(ElaExpression);
			var pat = default(ElaPattern);
		.)
		(
			ForeachPattern<out pat> "<-" Expr<out cexp>
			(. 
				it.Pattern = pat;
				it.Target = cexp;
			.)
			[
				Guard<out cexp>
				(. it.Guard = cexp; .)
			]
		)
		(. it.Body = body; .)
		[ 
			(. var cit = default(ElaFor); .)
			"," ComprehensionEntry<body, out cit>
			(. it.Body = cit; .)
		].
		
	Ela = 
		(
			(
				(. var exp = default(ElaExpression); .)
				EmbExpr<out exp> 
				(. Expression = exp; .)
			)
			| 
			(
				(.
					var b = new ElaBlock(t);
					Expression = b;
				.)
				DeclarationBlock<b>
			)
		).		
		
	DeclarationBlock<ElaBlock b> =
		(. var exp = default(ElaExpression); .)
		(
			(	
				RootLetBinding<out exp>
				| IncludeStat<out exp>
			)
			(. b.Expressions.Add(exp); .)
			[ DeclarationBlock<b> ]
		).
		
END Ela.