/*
  Module peano
  Created by Basil Voronkov in 2012
*/
open string number list

/* Construction */
type peano = Zero | Succ peano

one # qualified
one = Succ Zero

infinity # qualified
infinity = inf Zero 
  where inf a = Succ (& inf a)

min # qualified
min = Zero
max # qualified
max = infinity

fromInt # qualified
fromInt = fromIntegral

fromLong # qualified
fromLong = fromIntegral

fromIntegral # qualified
fromIntegral a = from a
  where from 0 = Zero
        from n = Succ (& from (n-1))

/* Instances */
instance Show peano where 
  showf _ p = string.fromList ("peano(" :: show p)
    where 
      show Zero = ["0)"]
      show (Succ a) = "1+" :: show a

instance Eq peano where
  (==) = comp (==)
  (<>) = comp (<>)

instance Ord peano where
  (>) = comp (>)
  (<) = comp (<)
  (>=) = comp (>=)
  (<=) = comp (<=)

instance Enum peano where
  succ a = a + one
  pred a = a - one
  enumFrom fst snd = map' fromInt [(toInt fst),(toInt snd)..]
  enumFromTo max fst snd = map fromInt [(toInt fst),(toInt snd)..(toInt max)]

instance Additive peano where
  x+y = add x y
  x-y = subtract x y
  --x = Zero - x

instance Ring peano where
  x*y  = multiply x y
  x**y = power x y

instance Modulo peano where
  mod x y = snd (divideMod x y)
  rem x y = snd (divideMod x y)

instance Integral peano where
  div x y = fst (divideMod x y)
  quot x y = fst (divideMod x y)

instance Absolute peano where
  abs = id
  signum Zero = Zero
  signum (Succ _) = one

instance IntLike peano where
  toInt = toIntegral 0

instance LongLike peano where
  toLong = toIntegral 0L

instance ListLike peano where
  toList = list 0
    where list n Zero = [n]
          list n (Succ a) = n :: (& list (n+1) a)

/* Functions */
listLength [] = Zero
listLength (x::xs) = add one (& listLength xs)

(?) = fromIntegral

add Zero b = b
add (Succ a) b = Succ (& add a b)

subtract Zero Zero = Zero
subtract Zero b = fail "peano: out of range!"
subtract b Zero = b
subtract (Succ a) (Succ b) = & subtract a b

subtractNeg Zero y = (false, y)
subtractNeg x Zero = (true, x)
subtractNeg (Succ x) (Succ y) = & subtractNeg x y

multiply Zero _ = Zero
multiply _ Zero = Zero
multiply (Succ x) y = add y (& multiply x y)

power b Zero = one
power b e = p e one
  where p Zero r = r
        p n r = p (n `subtract` one) (r `multiply` b)

divideMod x y 
  | neg  = (Zero,x)
  | else = let &(q,r) = & divideMod d y in (Succ q,r)
  where (neg,d) = subtractNeg y x

toIntegral2 # private
toIntegral2 a b = toInt 0L 0L a b
  where
    toInt x y Zero Zero = (x,y)
    toInt x y Zero _ = (x,y+1)
    toInt x y _ Zero = (x+1,y)
    toInt x y (Succ a) (Succ b) = toInt (x+1) (y+1) a b

comp # private
comp f a b = x `f` y 
  where (x,y) = toIntegral2 a b

toIntegral # private
toIntegral n Zero = n
toIntegral n (Succ v) = toIntegral (n+1) v
