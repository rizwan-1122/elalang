/*
  Module data
  Created by Basil Voronkov in 2012
*/
/* Reflection API */
//Constructor name: Alg->String
consName          = __internal api1

//Constructor parameter number: Alg->Int
consParamNumber   = __internal api2

//Constructor index: Alg->Int
consIndex         = __internal api3

//Constructor is infix symbol: Alg->Bool
consInfix         = __internal api7

//Constructor parameters: Alg->Tuple or Alg->Unit
consParams        = __internal api8

//Constructor unique ID: Alg->Int
consCode          = __internal api9

//Constructor unique ID by index: Int->Int->Int
consCodeByIndex   = __internal api104

//Type name: (any)->String
typeName          = __internal api4

//Type unique ID: (any)-Int
typeCode          = __internal api5

//Number of constructor in type: Int->Int
typeConsNumber    = __internal api6

//Index of a parameter in constructor: String->Int->Int
consParamIndex    = __internal api101

//Value of a parameter in constructor: Int->Alg->(any)
consParamValue    = __internal api102

//Name of a parameter: Int->Int->String
consParamName     = __internal api103

//Checks is a cons parameter exists: String->Int->Bool
consParamExist    = __internal api105

//Creates a default instance: Int->Alg
consCreateDefault = __internal api14

//Create a production: Int->Fun or Int->Alg
consCreate        = __internal api15

/* Default instances */
//Only for algebraic, open types are welcome
instance Show where
  showf f a 
    | consInfix a and len == 2 = showf f (consParamValue 0 a) ++ " " 
                                 ++ consName a ++ " " ++ showf f (consParamValue 1 a)
    | else = toString <| show (stringBuilder +> consName a) 0
    where len = consParamNumber a
          show sb n 
            | n < len = show (sb +> " " +> showf f (consParamValue n a)) (n+1)
            | else = sb

//Only for algebraic, open types are welcome
instance Eq where
  a == b = consCode a == consCode b and consParams a == consParams b
  a <> b = not (a == b)

//Only for algebraic, bettern not to use with open types
instance Ord where
  a > b
    | consParamNumber a == 0 or consParamNumber b == 0 = consIndex a > consIndex b 
    | else = consIndex a > consIndex b or consParams a > consParams b
  a < b
    | consParamNumber a == 0 or consParamNumber b == 0 = consIndex a < consIndex b 
    | else = consIndex a < consIndex b or consParams a < consParams b
  a >= b = a > b or a == b
  a <= b = a < b or a == b

//Only for algebraic, open types are welcome
instance Name where
  getField nm xs = consParamValue (consParamIndex nm (consCode xs)) xs
  isField fld a = consParamExist fld (consCode a)

//Only for algebraic, open types are welcome
instance Len where
  length = consParamNumber

//Only for algebraic, open types are welcome
instance Ix where
  getValue = consParamValue

//Only for algebraic, better not to use with open types
instance Enum where
  succ a = consCreateDefault (consCodeByIndex (typeCode a) (consIndex a + 1))
  pred a = consCreateDefault (consCodeByIndex (typeCode a) (consIndex a - 1))
  enumFrom fst snd = map (\x -> consCreateDefault (consCodeByIndex tc x)) [consIndex fst,consIndex snd..typeConsNumber (typeCode fst) - 1]
    where tc = typeCode fst
  enumFromTo max fst snd = map (\x -> consCreateDefault (consCodeByIndex tc x)) [consIndex fst,consIndex snd..consIndex max]
    where tc = typeCode fst

//Only for algebraic, better not to use with open types
instance IntLike where
  toInt = consIndex
  fromInt = undefined

//Only for algebraic, better not to use with open types
instance LongLike where
  toLong = toLong << consIndex
  fromLong = undefined

//Only for algebraic, open types are welcome
instance StringLike where
  toString = consName
  fromString = undefined

//Only for algebraic, open types are welcome
instance TupleLike where
  toTuple a
    | consParamNumber a == 0 = fail "TupleLike.toTuple: Type constructor has no parameters."
    | else = consParams a
  fromTuple = undefined

//Only for algebraic, open types are welcome
instance ListLike where
  toList a
    | len == 0 = []
    | else = tol 0
    where
      len = consParamNumber a
      tol n 
        | n < len = consParamValue n a :: tol (n+1)
        | else = []
  fromList = undefined

/* Privates */
map # private
map _ [] = []
map f (x::xs) = f x :: map f xs
