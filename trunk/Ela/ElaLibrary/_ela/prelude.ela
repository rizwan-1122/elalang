/* 
  Ela standard prelude module
  Created in 2011-2012 by Basil Voronkov
*/
import lang

/* Built-in types */
type Int
  deriving Eq Ord Show Additive Ring Field Modulo Bit

type Long
  deriving Eq Ord Show Additive Ring Field Modulo Bit

type Single
  deriving Eq Ord Show Additive Ring Field Modulo

type Double
  deriving Eq Ord Show Additive Ring Field Modulo

type Bool
  deriving Eq Show

type Char
  deriving Eq Ord Show Cat

type String
  deriving Eq Ord Show Cat Seq Len Ix

type Tuple
  deriving Len Ix Cat

type Record
  deriving Len Ix Name Cat

type Module
  deriving Eq Show Name

type Fun
  deriving Eq Show

type Unit
  deriving Eq Show

type Object

type List = a :: b | Nil
  deriving Seq

/* Eq */
class Eq(Eq) a where 
  (==) a->a 
  (<>) a->a

instance Eq Tuple
  where x == y = x `eqTuple` y
        x <> y = not (x `eqTuple` y)

instance Eq Record
  where x == y = x `eqRecord` y
        x <> y = not (x `eqRecord` y)

instance Eq List
  where x == y = x `eqList` y
        x <> y = not (x `eqList` y)

eqTuple # private
eqTuple tup1 tup2 = len == length tup2 and eq 0
        where len = length tup1
              eq n | n < len = if tup1:n == tup2:n then eq (n+1) else false
                   | else = true

eqRecord # private
eqRecord rec1 rec2 = len == length rec2 and eq 0
         where len = length rec1
               eq n | n < len = if rec1~n == rec2~n and rec1:n == rec2:n then eq (n+1) else false
                    | else = true

eqList # private
eqList (x::xs) (y::ys) | x == y = xs `eqList` ys | else = false
eqList [] [] = true
eqList [] _ = false
eqList _ [] = false

/* Ord */
class Ord(Ord) a where
  (>) a->a
  (<) a->a
  (>=) a->a
  (<=) a->a

instance Ord Tuple where 
  x < y  = tupleAny (<) x y
  x > y  = tupleAny (>) x y
  x <= y = tupleAny (<=) x y
  x >= y = tupleAny (>=) x y

tupleAny # private 
tupleAny f tup1 tup2 
  | length tup2 <> len = fail "prelude: Tuples should be of the same length."
  | else = fold 0
  where len = length tup1
        fold n | n == len - 1 = e
               | else = if e then true else fold (n+1)
               where e = tup1:n `f` tup2:n

/* Numerical classes */
class Additive(Additive) a where
  (+) a->a
  (-) a->a
  (--) a

class Ring(Ring) a where
  (*) a->a
  (**) a->a

class Field(Field) a where 
  (/) a->a

class Modulo(Modulo) a where
  mod a->a
  rem a->a

(%) = rem

/* Bit */
class Bit(Bit) a where 
  (&&&) a->a
  (|||) a->a
  (^^^) a->a
  (~~~) a
  (<<<) a->_
  (>>>) a->_

/* Enum */
class Enum a where
  succ a
  pred a
  enumFrom a->a
  enumFromTo a->a->a

instance Enum Int Long where
  succ = (+1)
  pred = (-1)
  enumFrom fst snd = genInf fst (snd-fst)
    where genInf e step = e :: (& genInf (e+step) step)
  enumFromTo max fst snd 
    | snd < fst = genLt [] max fst (snd-fst)
    | else = genGt [] max fst (snd-fst)
    where genLt xs max e step
            | e < max = lang.__reverseList xs
            | else = genLt(e::xs) max (e+step) step
          genGt xs max e step
            | e > max = lang.__reverseList xs
            | else = genGt(e::xs) max (e+step) step

/* Seq */
class Seq(Seq) a where
  head a
  tail a
  isnil a

/* Ix */
class Ix(Ix) a where 
  getValue _->a

instance Ix List where
  getValue n xs = get 0 xs
    where get _ [] = fail "Ix.getValue: Index is out of range."
          get i (x::xs) | i == n = x
                        | else = get (i+1) xs

(:) = __internal getvaluer

/* Len */
class Len(Len) a where
  length a

instance Len List where
  length xs
    | lang.__isLazyList xs = len 0 xs
    | else = lang.__listLength xs
    where len n [] = n
          len n (x::xs) = len (n+1) xs

/* Name */
class Name(Name) a where
  getField _->a
  hasField _->a

/* Cat */
class Cat(Cat) a where
  (++) a->_

instance Cat List where 
  xs ++ ys = cat (reverse xs) ys
             where cat (x::xs) ys = cat xs (x::ys)
                   cat [] ys = ys

reverse # private
reverse xs 
  | lang.__isLazyList xs = rev [] xs 
  | else = lang.__reverseList xs
  where rev ys [] = ys
        rev ys (x::xs) = rev (x::ys) xs

/* Show */
class Show(Show) a where 
  showf _->a

show = showf ""

instance Show Tuple where 
  showf f t = lang.__stringFromList ("(" :: tos 0)
    where len = length t
          tos n | n == len - 1 = [e, (if len == 1 then ",)" else ")")]
                | else = e :: "," :: tos (n+1)
                where e = showf f (t:n) 

instance Show List where 
  showf _ [] = "[]"
  showf f xs = lang.__stringFromList ("[" :: tos xs)
    where tos (x::[]) = [showf f x, "]"]
          tos (x::xs) = showf f x :: "," :: tos xs

instance Show Record where 
  showf f t = lang.__stringFromList ("{" :: tos 0)
    where len = length t
          tos n | n == len - 1 = [fld, "}"]
                | else = fld :: "," :: tos (n+1)
                where fld = t~n ++ "=" ++ showf f (t:n)

/* xLike */
class IntLike a where
  toInt a

class LongLike a where
  toLong a

class SingleLike a where
  toSingle a

class DoubleLike a where
  toDouble a

class BoolLike a where
  toBool a

class CharLike a where
  toChar a

class StringLike a where
  toString a

class ListLike a where
  toList a

class TupleLike a where
  toTuple a

class RecordLike a where
  toRecord a

instance ListLike List where
  toList a = a

instance TupleLike Tuple where
  toTuple a = a

instance RecordLike Record where
  toRecord a = a

instance IntLike Int Long Single Double Char Bool where
  toInt = lang.__toInt

instance LongLike Long Int Single Double Char Bool where
  toLong = lang.__toLong

instance SingleLike Single Double Long Int where
  toSingle = lang.__toSingle

instance DoubleLike Double Single Long Int where
  toDouble = lang.__toDouble

instance CharLike Char Int where
  toChar = lang.__toChar

instance BoolLike Bool Int Long where
  toBool = lang.__toBool

instance StringLike String Char where
  toString = lang.__toString

/* Misc operators */
not = __internal not

/* Function related operators and functions */
(>>) f g x = g (f x)
(<<) f g x = f (g x)
(|>) = __internal fpipe
(<|) = __internal bpipe
flip f x y = f y x
curry f x y = f (x, y)
uncurry f (x, y) = f x y
curry3 f x y z = f (x, y, z)
uncurry3 f (x, y, z) = f x y z

/* Tuple functions */
x => y = (x, y)
swap (x, y) = (y, x)
swap3 (x, y, z) = (y, x, z)
fst (x,_) = x
snd (_,y) = y
fst3 (x,_,_) = x
snd3 (_,y,_) = y

/* Complex behaviors */
getType x = lang.__getTypeInfo (force x)
force = __internal force

/* Variants */
tag = __internal gettag
untag x = lang.__unwrap (force x)

/* Combinators */
id x = x//I
const x _ = x//K
sub x y z = x z (y z)//S
fix f = f (& fix f)
on cmb f x y = f x `cmb` f y

/* Misc */
until p f x | p x  = x | else = until p f (f x)
even x = x % 2 == 0
odd x = x % 2 <> 0

/* Default instances */
instance Eq where
  a == b = tag a == tag b and untag a == untag b
  a <> b = tag a <> tag b or untag a <> untag b

instance Ord where
  a > b
    | (aa is Unit) or (bb is Unit) = cid a > cid b 
    | else = cid a >= cid b and aa > bb
    where aa = untag a; bb = untag b
  a < b
    | (aa is Unit) or (bb is Unit) = cid a < cid b 
    | else = cid a <= cid b and aa < bb
    where aa = untag a; bb = untag b
  a >= b
    | (aa is Unit) or (bb is Unit) = cid a >= cid b 
    | else = cid a >= cid b and aa >= bb
    where aa = untag a; bb = untag b
  a <= b 
    | (aa is Unit) or (bb is Unit) = cid a <= cid b 
    | else = cid a <= cid b and aa <= bb
    where aa = untag a; bb = untag b

instance Show where
  showf f a 
    | lang.__isInfix lang a = showf f (u:0) ++ " " ++ tag a ++ " " ++ showf f (u:1)
    | else = lang.__stringFromList (tag a :: v)
    where u = untag a 
          v = match u with () = []; _  = " " :: showParamList f u

instance Len where
  length v
    | o is Unit = 0
    | else = length o
    where o = lang.__unwrap v

instance Name where
  getField nm xs
    | idx < 0 = fail "Name.getField: Unknown field."
    | else = lang.__unwrap xs : idx
    where idx = lang.__getParameterIndex lang xs nm
  hasField nm xs = idx >= 0
    where idx = lang.__getParameterIndex lang xs nm

instance Ix where
  getValue idx xs = lang.__unwrap xs : idx

instance Enum where
  succ a = lang.__conssucc lang a
  pred a = lang.__conspred lang a
  enumFrom fst snd = enumFromTo (lang.__consfromint lang fst (lang.__consmax lang fst)) fst snd
  enumFromTo max fst snd = map (lang.__consfromint lang max) [toi fst,toi snd..toi max]
    where toi = lang.__constoint lang
          map _ [] = []
          map f (x::xs) = f x :: map f xs

instance IntLike where
  toInt a = lang.__constoint lang a

instance LongLike where
  toLong a = toLong (lang.__constoint lang a)

instance StringLike where
  toString a = tag a

instance TupleLike where
  toTuple a
    | v is Unit = fail "prelude.toTuple: Type constructor has no parameters."
    | else = v
    where v = untag a

showParamList # private
showParamList f t = tos 0
  where len = length t
        tos n | n == len - 1 = [e]
              | else = e :: " " :: tos (n+1)
              where e = showf f (t:n) 

cid # private
cid = lang.__constructorIndex

/* Privates */
(~) # private
(~) = __internal recfield
