/* 
  Module list
  Created in 2011-2012 by Basil Voronkov
*/
open core lang

class ListLike a where
  toList a

//Strict sort based on merge sort
mergeBy # private
mergeBy pred (x::xs) (y::ys) 
  | pred x y = x :: mergeBy pred xs (y::ys)
  | else = y :: mergeBy pred (x::xs) ys
mergeBy pred xs [] = xs
mergeBy pred [] ys = ys

sortBy pred [x] = [x]
sortBy pred xs = mergeBy pred (sortBy pred xs1) (sortBy pred xs2)
  where (xs1,xs2) = splitHalf xs
sortBy pred [] = []

sort = sortBy (<=)

//Lazy sort based on quick sort
sort' x = qsort x []
  where qsort [] y = y
        qsort [x] y = x::y
        qsort (x::xs) y = part xs [] [x] []  
          where part [] l e g = qsort l (e ++ (& qsort g y))
                part (z::zs) l e g | z > x = part zs l e (z::g) 
                                   | z < x = part zs (z::l) e g 
                                   | else  = part zs l (z::e) g

last (x::[]) = x
last (_::xs) = last xs
last []      = fail "list.last: Empty list"

init (x::[])   = []
init (x::xs)   = x :: init xs
init []        = fail "list.init: Empty list"

takeWhile f (x::xs) | f x  = x :: takeWhile f xs
                    | else = []
takeWhile f [] = []

take = tak []
  where
    tak ys 0 _       = lang.__reverseList ys
    tak ys n (x::xs) = tak (x::ys) (n-1) xs
    tak ys _ []      = []

skip 0 xs      = xs
skip n (_::xs) = skip (n-1) xs
skip _ []      = []

map f (x::xs) = f x :: map f xs
map _ []      = []

map' f (x::xs) = f x :: (& map' f xs)
map' _ []      = []

filter p (x::xs) | p x  = x :: filter p xs
                 | else = filter p xs
filter _ [] = []

filter' p (x::xs) | p x  = x :: (& filter' p xs)
                  | else = filter' p xs
filter' _ [] = []

foldl f z (x::xs) = foldl f (f z x) xs
foldl _ z [] = z

foldr f z xs = foldl f z (reverse xs)

fold f xs = foldr f [] xs

foldl' f z (x::xs) = foldl' f (& f z x) xs
foldl' _ z []      = z

foldr' f z (x::xs) = f x (& foldr' f z xs)
foldr' _ z []      = z
    
fold' f xs = foldr' f [] xs

concat (x::xs) = x ++ concat xs 
concat []      = []

concatMap f (x::xs) = f x :: concatMap f xs 
concatMap _ []      = []

sum xs = sum' 0 xs
  where sum' s (x::xs) = sum' (s + x) xs
        sum' s [] = s

product xs = product' 1 xs
  where product' p (x::xs) = product' (p * x) xs
        product' p []      = p

minimum (x::xs) = minimum' x xs
  where minimum' v (x::xs) | x < v = minimum' x xs
                           | else  = minimum' v xs
        minimum' v [] = v

maximum (x::xs) = maximum' x xs
  where maximum' v (x::xs) | x > v = maximum' x xs
                           | else  = maximum' v xs
        maximum' v [] = v

reverse xs 
  | lang.__isLazyList xs = rev [] xs
  | else = lang.__reverseList xs
  where rev ys [] = ys
        rev ys (x::xs) = rev (x::ys) xs

zipWith z (x::xs) (y::ys) = z x y :: zipWith z xs ys
zipWith _ _ _ = []

zip = zipWith (\x y -> (x,y))

zipWith3 z (a::as) (b::bs) (c::cs) =  z a b c :: zipWith3 z as bs cs
zipWith3 _ _ _ _ = []

zip3 =  zipWith3 (\x y z -> (x,y,z))

any f (x::xs) | f x  = true
              | else = any f xs
any _ []             = false

all f (x::xs) | f x  = all f xs
              | else = false
all _ []             = true

splitAt 0 xs = ([],xs)
splitAt _ [] = ([],[])
splitAt n (x::xs) | n > 0 = (x::xs',xs2')
                  | else = fail "list.splitAt: negative argument"
                  where (xs',xs2') = splitAt (n-1) xs

splitHalf xs = go xs xs 
  where go (x::xs) (_::_::zs) = (x::us,vs) where (us,vs) = go xs zs
        go xs _ = ([],xs)

span p [] = ([],[])
span p (x::xs')@xs | p x  = (x::ys, zs)
                   | else = ([],xs)
                   where (ys,zs) = span p xs'

breakList p xs = span (not << p) xs

drop 0 xs              = xs
drop _ []              = []
drop n (_::xs) | n > 0 = drop (n-1) xs
               | else  = fail "list.drop: negative argument"

dropWhile p [] = []
dropWhile p (x::xs) | p x  = dropWhile p xs
                    | else = x::xs

index e lst = index' 0 lst
  where index' n (x::xs) | x <> e = index' (n+1) xs
                         | else   = n
        index' n [] = n

elem x = any (==x)

notElem x = all (<>x)

elemBy _  _ [] = false
elemBy eq y (x::xs) = y `eq` x or elemBy eq y xs

scanl f q (x::xs) = q :: scanl f (f q x) xs
scanl _ q []      = q :: []

scanr f q0 [] = q0::[]
scanr f q0 (x::xs) = f x q :: qs
  where (q::_)@qs = scanr f q0 xs

repeat x = x :: (& repeat x)

cycle (head::tail) = head :: (& cycle' tail)
  where cycle' (x::xs) = x :: (& cycle' xs)
        cycle' []      = head :: (& cycle' tail)

iterate f x = x :: (& iterate f (f x))

replicate n x = take n (repeat x)

deleteBy p x (y::ys) | p x y  = ys
                     | else   = y :: deleteBy p x ys
deleteBy _ _ [] = []

delete = deleteBy (==)

insertBy _   x [] = x::[]
insertBy cmp x (y::ys')@ys = 
  match cmp x y with
        GT = y :: insertBy cmp x ys'
        _  = x :: ys

insert = insertBy compare

nubBy eq xs = nubBy' xs []
  where nubBy' [] _ = []
        nubBy' (y::ys) xs | elemBy eq y xs = nubBy' ys xs
                          | else = y :: nubBy' ys (y::xs)

nub = nubBy (==)

intersperse e (x::[]) = x :: intersperse e []
intersperse e (x::xs) = x :: e :: intersperse e xs
intersperse _ []      = []

transpose ([]::xs)      = transpose xs
transpose ((x::xs)::ys) = (x :: [h \\ (h::_) <- ys]) :: transpose (xs :: [t \\ (_::t) <- ys])
transpose []            = []

intercalate xs xss = concat (intersperse xs xss)

nonEmptySubsequences (x::xs) = (x::[]) :: fold f (nonEmptySubsequences xs)
                               where f ys r = ys :: (x :: ys) :: r
nonEmptySubsequences [] = []

subsequences xs = [] :: nonEmptySubsequences xs 

permutations []  = []
permutations xs0 = xs0 :: perms xs0 []
  where perms [] _ = []
        perms (t::ts) is' = foldr interleave (perms ts (t::is')) (permutations is')
          where interleave xs r    = zs where (_,zs) = interleave' id xs r 
                interleave' _ [] r = (ts, r)
                interleave' f (y::ys) r = (y::us, f (t::y::us) :: zs)
                  where (us,zs) = interleave' (f << (y::)) ys r

groupBy eq (x::xs) = (x::ys) :: groupBy eq zs
                     where (ys,zs) = span (eq x) xs
groupBy _  [] = []

group = groupBy (==)

intersectBy eq xs ys =  [x \\ x <- xs | any (eq x) ys]

intersect = intersectBy (==)

count f = count' 0
  where count' n (x::xs) | f x = count (n+1) xs | else = count n xs
        count' n [] = n
