/* 
    Ela standard prelude module
    Created in 2011-2012 by Basil Voronkov
*/

/* Built-in types */
type int
type long
type single
type double
type bool
type char
type string
type tuple
type list
type record
type module
type thunk
type typeinfo
type fun
type unit
type object
type variant

/* Typeable */
class Typeable __internal Typeable cast

let toInt    = cast 0
let toLong   = cast 0L
let toSingle = cast 0F
let toDouble = cast 0D
let toBool   = cast false
let toChar   = cast '\0'
let toList   = cast []
let toString = cast ""

instance Typeable bool //toInt

instance Typeable char //toString, toInt

instance Typeable double //toInt, toLong, toSingle

instance Typeable int //toChar, toDouble, toLong, toSingle

instance Typeable long //toDouble, toInt, toSingle

instance Typeable single //toDouble, toLong, toInt

instance Typeable string //toList

instance Typeable list
  where cast ?string x = castString x

let castString (x::xs) = toString x ++ castString xs
    castString [] = ""

/* Eq */
class Eq __internal Eq (==) (<>)

instance Eq int

instance Eq char

instance Eq bool

instance Eq double

instance Eq single

instance Eq long

instance Eq string

instance Eq unit

instance Eq typeinfo

instance Eq fun

instance Eq module

instance Eq tuple
  where x == y = x `eqTuple` y
     et x <> y = not (x `eqTuple` y)

instance Eq record
  where x == y = x `eqRecord` y
     et x <> y = not (x `eqRecord` y)

instance Eq list
  where x == y = x `eqList` y
     et x <> y = not (x `eqList` y)

instance Eq variant
  where x == y = tag x == tag y and untag x == untag y
     et x <> y = tag x <> tag y or untag x <> untag y

let private
  eqTuple tup1 tup2 = len == length tup2 and eq 0
          where len = length tup1
             et eq n | n < len = if tup1:n == tup2:n then eq (n+1) else false
                     | else = true

let private
  eqRecord rec1 rec2 = len == length rec2 and eq 0
           where len = length rec1
              et (!!) = __internal recfield
              et eq n | n < len = if rec1!!n == rec2!!n and rec1:n == rec2:n then eq (n+1) else false
                      | else = true

let private
  eqList (x::xs) (y::ys) | x == y = xs `eqList` ys | else = false
  eqList [] [] = true
  eqList [] _ = false
  eqList _ [] = false

/* Ord */
class Ord __internal Ord (>) (<) (>=) (<=)

instance Ord int

instance Ord long

instance Ord single

instance Ord double

instance Ord char

instance Ord string

instance Ord tuple
  where x<y = foldTuple (<) x y
     et x>y = foldTuple (>) x y
     et x<=y = foldTuple (<=) x y
     et x>=y = foldTuple (>=) x y

let private 
  foldTuple f tup1 tup2 | length tup2 <> len = fail "Tuples should be of the same length."
                        | else = fold 0
                        where len = length tup1
                           et fold n | n == len - 1 = e
                                     | else = if e then true else fold (n+1)
                                     where e = tup1:n `f` tup2:n

/* Num */
class Num __internal Num (+) (-) (*) (/) (**) (%) (--)

instance Num int

instance Num long

instance Num single

instance Num double

instance Num tuple
  where (+) = joinTuple (+)
     et x-y = joinTuple (-) x y
     et x*y = joinTuple (*) x y
     et x/y = joinTuple (/) x y
     et x**y = joinTuple (**) x y
     et x%y = joinTuple (%) x y
     et x-- = mapTuple (--) x

let private 
  mapTuple f tup = map 0
            where len = length tup
               et map n | n == len - 1 = e
                        | else = e ++ map (n+1)
                        where e = ( f (tup:n), )
                         
let private 
  joinTuple f tup1 tup2 | length tup2 <> len = fail "Tuples should be of the same length." | else = join 0
              where len = length tup1
                 et join n | n == len - 1 = e
                           | else = e ++ join (n+1)
                           where e = (tup1:n `f` tup2:n, )

/* Bit */
class Bit __internal Bit (&&&) (|||) (^^^) (~~~) (<<<) (>>>)

instance Bit int

instance Bit long

/* Enum */
class Enum __internal Enum succ pred

instance Enum int

instance Enum long

instance Enum double

instance Enum single

instance Enum char

instance Enum tuple
  where succ = mapTuple succ
     et pred = mapTuple pred
/*     et sp fun tup = sp' 0
           where sp' n | n == len - 1 = (fun (tup:n),)
                       | else = (fun (tup:n),) ++ sp' (n+1)
              et len = length tup*/



/* Seq */
class Seq __internal Seq head tail isnil

instance Seq list

instance Seq string

/* Ix */
class Ix __internal Ix (:) length

instance Ix string

instance Ix tuple

instance Ix record

instance Ix list
  where length xs = len 0 xs
               where len n [] = n
                     len n (x::xs) = len (n+1) xs
     et xs:n = get 0 xs
               where get _ [] = raise IndexOutOfRange ("Index " ++ n ++ " is out of range.")
                     get i (x::xs) | i == n = x
                                   | else = get (i+1) xs

/* Cons */
class Cons __internal Cons (::) nil

/* Cat */
class Cat __internal Cat (++)

instance Cat char

instance Cat string

instance Cat tuple

instance Cat record

instance Cat list
  where xs++ys = cat (reverse xs) ys
                 where cat (x::xs) ys = cat xs (x::ys)
                       cat [] ys = ys

let private
  reverse xs = rev [] xs
          where (:) = flip (::)
             et rev z [] = z
                rev z (x::xs) = rev (z:x) xs

/* Show */
class Show __internal Show showf

let show = showf ""

instance Show int

instance Show long

instance Show single

instance Show double

instance Show char

instance Show bool

instance Show string

instance Show unit

instance Show typeinfo

instance Show fun

instance Show module

instance Show variant
  where showf f x = if v is ?unit then tag x else tag x ++ " " ++ showf f v
                    where v = untag x

instance Show tuple
  where showf f t = "(" ++ tos 0 ++ ")"
                    where tos n | n == len - 1 = e ++ (if len == 1 then "," else "")
                                | else = e ++ "," ++ tos (n+1)
                                where e = showf f (t:n) 
                       et len = length t

instance Show list
  where showf _ [] = "[]"
        showf f xs = "[" ++ tos xs ++ "]"
                     where tos (x::[]) = showf f x
                           tos (x::xs) = showf f x ++ "," ++ tos xs

instance Show record
  where showf f t = "{" ++ tos 0 ++ "}"
                    where tos n | n == len - 1 = fld
                                | else = fld ++ "," ++ tos (n+1)
                                where fld = t!!n ++ "=" ++ showf f (t:n)
                       et len = length t
                       et (!!) = __internal recfield

/* Read 
class Read
      readf (readf)


let read = readf "" 
let readInt     = readf "" ?int
let readLong    = readf "" ?long
let readSingle  = readf "" ?single
let readDouble  = readf "" ?double
let readBool    = readf "" ?bool
let readList    = readf "" ?list
let readTuple   = readf "" ?tuple
let readRecord  = readf "" ?record */

/* Boolean operators */
let not = __internal not

/* Function related operators and functions */
let (>>) f g x = g (f x)
let (<<) f g x = f (g x)
let flip = __internal flip
let curry f x y = f (x, y)
let uncurry f (x, y) = f x y
let curry3 f x y z = f (x, y, z)
let uncurry3 f (x, y, z) = f x y z

/* Tuple functions */
let (=>) x y = (x, y)
let swap (x, y) = (y, x)
let swap3 (x, y, z) = (y, x, z)
let fst (x,_) = x
let snd (_,y) = y
let fst3 (x,_,_) = x
let snd3 (_,y,_) = y

/* Complex behaviors */
let typeinfo = __internal typeinfo
let force = __internal force

/* Variants */
let tag   = __internal gettag
let untag = __internal untag

/* Combinators */
let id x = x//I
let const x _ = x//K
let sub x y z = x z (y z)//S
let fix f = f (& fix f)
let on cmb f x y = f x `cmb` f y

/* Misc */
let f! = f()
let (|>) = __internal fpipe
let (<|) = __internal bpipe
let until p f x | p x  = x  | else = until p f (f x)
let compare x y | x == y = EQ | x < y = LT | else = GT