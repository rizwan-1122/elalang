/* 
    Module test
    Created in 2011-2012 by Basil Voronkov
*/
open core reflect format@form

let assert =
    {
        eq  = op' "eq"  (==),
        neq = op' "neq" (<>),
        gt  = op' "gt"  (>),
        lt  = op' "lt"  (<),
        gte = op' "gte" (>=),
        lte = op' "lte" (<=),
        eqt = op' "eqt" (==) true,
        eqf = op' "eqf" (==) false
    } 
    where op' m op x y | op x y = ()
                       | else   = raise AssertFailed m

let funData mod fun = (moduleName mod ++ "." ++ funName fun, fun)

let regFun fun xs = funData fun  :: xs

let regFuns mod xs = xs ++ (vals |> filter (\x -> x is ?fun) |> map (funData mod))
                     where vals = map (:"value") (moduleExportList mod)

let run xs = (res, failed)
        where exec (n, f) = try (f assert $ n, true, "") with 
                                 AssertFailed m = (n, false, ": Assert failed: " ++ m)
                                 v              = (n, false, ": Error occured: " ++ untag v)
           et count f xs = length <| filter f xs
           et res = map exec xs
           et failed = count (not << snd3) /*(\(_,y,_) -> not y)*/ res
              
let fmt f prf (tests, failed) =
        out "Test session started" 
            (all' f tests 1 "")
            "Test session finished"
            (format "Executed tests: {0}" (length tests))
            (format "Successful tests: {0}" (length tests - failed))
            (format "Failed tests: {0}" failed)
        where out v = prf v $ out
           et tag' true  = "Success "
              tag' false = "FAILED "
           et fmt' i (n, r, m) = format "{0}. {1}: {2} {3}\r\n" i n (tag' r) m
           et all' _ [] _ s = s
              all' f x::xs i s | f x  = (s ++ fmt' i x) |> all' f xs (i + 1)
                               | else = all' f xs (i + 1) s