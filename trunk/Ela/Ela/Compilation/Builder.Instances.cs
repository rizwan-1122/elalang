using System;
using System.Collections.Generic;
using Ela.CodeModel;

namespace Ela.Compilation
{
    //This Part is responsible for compilation of type class instances
    internal sealed partial class Builder
    {
        //Main method for instnace compilation
        private void CompileInstance(ElaClassInstance s, LabelMap map)
        {
            //Obtain type class data
            var mod = default(CodeFrame);
            var mbr = default(ClassData);
            var modId = -1;
            ObtainTypeClass(s, out mbr, out modId, out mod);
            var notFound = mbr == null && (mod == null || !mod.InternalClasses.TryGetValue(s.TypeClassName, out mbr));

            //Type class not found, nothing else to do
            if (notFound)
            {
                if (!options.IgnoreUndefined)
                    AddError(ElaCompilerError.UnknownClass, s, s.TypeClassName);
                else
                {
                    //Add an instance anyway - the IgnoreUndefine flag is usually set just to gather some module metadata,
                    //so we need to populate it anyway.
                    frame.InternalInstances.Add(new InstanceData(s.TypeName, s.TypeClassName, -1, modId, s.Line, s.Column));
                }
            }
            else
            {
                //Now we need to obtain a local ID of a module where type is defined
                var typCode = -1;
                ObtainType(s, out typCode);

                //Add new instance registration information
                frame.InternalInstances.Add(new InstanceData(s.TypeName, s.TypeClassName, typCode, modId, s.Line, s.Column));

                //Fill a list of classMembers, this list is used in this method to validate
                //whether all members of a class have an implementation
                var classMembers = new List<String>(mbr.Members.Length);

                for (var i = 0; i < mbr.Members.Length; i++)
                    classMembers.Add(mbr.Members[i].Name);

                if (s.Where != null)
                    foreach (var b in s.Where.Equations)
                    {
                        var err = false;

                        //Patterns are now allowed in member bindings
                        if (!b.IsFunction() && b.Left.Type != ElaNodeType.NameReference)
                        {
                            AddError(ElaCompilerError.MemberNoPatterns, b.Left, FormatNode(b.Left));
                            err = true;
                        }

                        var name = b.GetLeftName();

                        //Only member functions can be declared inside instance
                        if (!classMembers.Contains(name))
                        {
                            AddError(ElaCompilerError.MemberInvalid, b, name, s.TypeClassName);
                            err = true;
                        }

                        //Compile member function                 
                        if (!err)
                        {
                            classMembers.Remove(name);
                            CompileInstanceMember(s.TypeClassName, s.TypeClassPrefix, b, map, s.TypePrefix, s.TypeName);
                        }
                    }

                //Not all of the members are implemented, which is an error if an instance is
                //not generated by a compiler
                if (!IsAutoGenerated(s, typCode) && classMembers.Count > 0)
                    AddError(ElaCompilerError.MemberNotAll, s, s.TypeClassName, s.TypeClassName + " " + s.TypeName);
            }

            if (s.And != null)
                CompileInstance(s.And, map);
        }

        //This method returns type class data including: type class metadata (ClassData), module local ID
        //(modId) and compiled module where class is defined.
        private void ObtainTypeClass(ElaClassInstance s, out ClassData mbr, out int modId, out CodeFrame mod)
        {
            mbr = null;
            modId = -1;
            mod = null;

            //If a type class prefix is not set we need to obtain a type ID using a special '$$$*' variable
            //that is initialized during type class compilation
            if (s.TypeClassPrefix == null)
            {
                //We first check if a class definition is non-local
                if (!frame.InternalClasses.TryGetValue(s.TypeClassName, out mbr))
                {
                    var sv = GetVariable("$$$" + s.TypeClassName, CurrentScope, GetFlags.NoError, s.Line, s.Column);

                    if (sv.IsEmpty() && !options.IgnoreUndefined)
                    {
                        AddError(ElaCompilerError.UnknownClass, s, s.TypeClassName);
                        return;
                    }

                    //The trick is - here sv can be only an external name (we do check prior to this
                    //if a class is not local). If it is an external name that first byte contains a
                    //local index of a referenced module - that is exactly what we need here to obtain
                    //a compiled module frame (from refs array).
                    modId = sv.Address & Byte.MaxValue;

                    if (modId < refs.Count && modId >= 0)
                        mod = refs[modId];
                }
            }
            else
            {
                //Type class prefix is set. The prefix itself should be local name (a module alias)
                var sv = GetVariable(s.TypeClassPrefix, s.Line, s.Column);

                if (sv.IsEmpty())
                    return;

                //A name was found but this is not a module alias
                if ((sv.Flags & ElaVariableFlags.Module) != ElaVariableFlags.Module)
                {
                    AddError(ElaCompilerError.InvalidQualident, s, s.TypeClassPrefix);
                    return;
                }

                //In this case we can look for a reference based on its alias (alias should be unique within
                //the current module).
                modId = frame.References[s.TypeClassPrefix].LogicalHandle;
                
                if (modId < refs.Count && modId >= 0)
                    mod = refs[modId];
            }
        }

        //Here we obtain type information - local ID of a module where a type is defined.
        private void ObtainType(ElaClassInstance s, out int typCode)
        {
            typCode = -1;

            if (s.TypePrefix == null)
            {
                //First we check that type is not defined locally
                if (!frame.InternalTypes.ContainsKey(s.TypeName))
                {
                    var sv = GetVariable("$$" + s.TypeName, CurrentScope, GetFlags.NoError, s.Line, s.Column);

                    if (sv.IsEmpty() && !options.IgnoreUndefined)
                    {
                        AddError(ElaCompilerError.UndefinedType, s, s.TypeName);
                        return;
                    }

                    //The trick is - here sv can be only an external name (we do check prior to this
                    //if a type is not local). If it is an external name that first byte contains a
                    //local index of a referenced module - and typCode is effectly a local ID of a module
                    //where a type is declared
                    typCode = sv.Address & Byte.MaxValue;
                }
            }
            else
            {
                //TypePrefix is a local name that should correspond to a module alias
                var sv = GetVariable(s.TypePrefix, s.Line, s.Column);

                if (sv.IsEmpty())
                    return;

                //A name exists but this is not a module alias
                if ((sv.Flags & ElaVariableFlags.Module) != ElaVariableFlags.Module)
                {
                    AddError(ElaCompilerError.InvalidQualident, s, s.TypePrefix);
                    return;
                }

                //Obtain a local ID of a module based on TypePrefix (which is module alias
                //that should be unique within this module).
                typCode = frame.References[s.TypePrefix].LogicalHandle;
            }
        }

        //Compile an instance member. Argument classPrefix is null if a class is not prefixed, otherwise 
        //it should be used to lookup class members.
        private void CompileInstanceMember(string className, string classPrefix, ElaEquation s, LabelMap map, 
            string currentTypePrefix, string currentType)
        {
            //Obtain a 'table' function of a class
            var name = s.GetLeftName();
            var btVar = default(ScopeVar);

            if (classPrefix == null)
                btVar = GetVariable(name, CurrentScope, GetFlags.NoError, s.Line, s.Column);
            else
            {
                var fr = default(CodeFrame);
                btVar = FindByPrefix(classPrefix, name, out fr);
            }

            if (btVar.IsEmpty())
                AddError(ElaCompilerError.MemberInvalid, s, name, className);
            
            var builtin = (btVar.Flags & ElaVariableFlags.Builtin) == ElaVariableFlags.Builtin;
            var args = 0;

            //Here we need to understand how many arguments a class function has.
            //If our declaration has less arguments (allowed by Ela) we need to do
            //eta expansion.
            if (builtin)
                args = BuiltinParams((ElaBuiltinKind)btVar.Data);
            else
                args = btVar.Data;

            //Eta expansion should be done if a member is not a function literal
            //(it can be a partially applied function) or if a number of arguments
            //doesn't match.
            if (!s.IsFunction())
                EtaExpand(s.Right, map, args);
            else if (s.GetArgumentNumber() < args)
                EtaExpand(s, map, args);
            else
                CompileFunction(s);

            AddLinePragma(s);

            //Depending whether this is a built-in class or a different approach is
            //used to add a member function.
            if (!builtin)
                PushVar(btVar);
            else
                cw.Emit(Op.PushI4, (Int32)btVar.Data);

            //We need to obtain a 'real' global ID of the type that we are extending. This
            //is done using this helper method.
            EmitSpecName(currentTypePrefix, "$$" + currentType, s, ElaCompilerError.UndefinedType);

            //Finally adding a member function.
            cw.Emit(Op.Addmbr);
        }

        //Perform an eta expansion for a given expression
        private void EtaExpand(ElaExpression exp, LabelMap map, int args)
        {
            //Here we generate a function which has a provided number of
            //arguments
            StartSection();
            StartScope(true, exp.Line, exp.Column);
            cw.StartFrame(args);
            var funSkipLabel = cw.DefineLabel();
            cw.Emit(Op.Br, funSkipLabel);
            var address = cw.Offset;

            if (exp.Type != ElaNodeType.Equation)
                CompileExpression(exp, map, Hints.None);
            else
                CompileFunction((ElaEquation)exp);

            //Functions are curried so generate a call for each argument
            for (var i = 0; i < args; i++)
                cw.Emit(Op.Call);

            cw.Emit(Op.Ret);
            frame.Layouts.Add(new MemoryLayout(currentCounter, cw.FinishFrame(), address));
            EndSection();
            EndScope();
            cw.MarkLabel(funSkipLabel);
            cw.Emit(Op.PushI4, args);
            cw.Emit(Op.Newfun, frame.Layouts.Count - 1);
        }

        //An instance might be missing a body. If this instance corresponds to
        //an auto-generated instance we are OK with this, otherwise we will generate
        //an error (on the caller side).
        private bool IsAutoGenerated(ElaClassInstance b, int code)
        {
            var tc = TCF.GetTypeCode(b.TypeName);

            if (b.TypePrefix != null || b.TypeClassPrefix != null || code != -1 || tc == ElaTypeCode.None)
                return false;

            switch (b.TypeClassName)
            {
                case "Eq":
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Char ||
                        tc == ElaTypeCode.Boolean ||
                        tc == ElaTypeCode.Double ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.String ||
                        tc == ElaTypeCode.Unit ||
                        tc == ElaTypeCode.TypeInfo ||
                        tc == ElaTypeCode.Function ||
                        tc == ElaTypeCode.Module ||
                        tc == ElaTypeCode.Tuple ||
                        tc == ElaTypeCode.Record ||
                        tc == ElaTypeCode.List;
                case "Ord":
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Double ||
                        tc == ElaTypeCode.Char ||
                        tc == ElaTypeCode.String;
                case "Additive":
                case "Ring":
                case "Field":
                case "Modulo":
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Double;
                case "Bit":
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long;
                case "Enum":
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Double ||
                        tc == ElaTypeCode.Char;
                case "Seq":
                    return
                        tc == ElaTypeCode.List ||
                        tc == ElaTypeCode.String;
                case "Ix":
                    return
                        tc == ElaTypeCode.String ||
                        tc == ElaTypeCode.Tuple ||
                        tc == ElaTypeCode.Record;
                case "Cat":
                    return
                        tc == ElaTypeCode.Char ||
                        tc == ElaTypeCode.String ||
                        tc == ElaTypeCode.Tuple ||
                        tc == ElaTypeCode.Record;
                case "Show":
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Double ||
                        tc == ElaTypeCode.Char ||
                        tc == ElaTypeCode.Boolean ||
                        tc == ElaTypeCode.String ||
                        tc == ElaTypeCode.Unit ||
                        tc == ElaTypeCode.TypeInfo ||
                        tc == ElaTypeCode.Function ||
                        tc == ElaTypeCode.Module;
                default:
                    return false;
            }
        }
    }
}
