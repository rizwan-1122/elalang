using System;
using System.Collections.Generic;
using Ela.CodeModel;

namespace Ela.Compilation
{
    //This Part is responsible for compilation of type class instances
    internal sealed partial class Builder
    {
        //Main method for instnace compilation
        private void CompileInstance(ElaClassInstance s, LabelMap map)
        {
            //Obtain type class data
            var mod = default(CodeFrame);
            var mbr = default(ClassData);
            var modId = -1;
            var classId = ObtainTypeClass(s, out mbr, out modId, out mod);
            var notFound = mbr == null && (mod == null || !mod.InternalClasses.TryGetValue(s.TypeClassName, out mbr));

            //Type class not found, nothing else to do
            if (notFound)
            {
                if (!options.IgnoreUndefined)
                    AddError(ElaCompilerError.UnknownClass, s, s.TypeClassName);
                else
                {
                    //Add an instance anyway - the IgnoreUndefine flag is usually set just to gather some module metadata,
                    //so we need to populate it anyway.
                    frame.InternalInstances.Add(new InstanceData(s.TypeName, s.TypeClassName, -1, modId, s.Line, s.Column));
                }
            }
            else
            {
                //Now we need to obtain a local ID of a module where type is defined
                var typeModuleCode = -1;
                var typeId = ObtainType(s, out typeModuleCode);

                //Add new instance registration information
                frame.InternalInstances.Add(new InstanceData(s.TypeName, s.TypeClassName, typeModuleCode, modId, s.Line, s.Column));

                //Fill a list of classMembers, this list is used in this method to validate
                //whether all members of a class have an implementation
                var classMembers = new List<String>(mbr.Members.Length);

                for (var i = 0; i < mbr.Members.Length; i++)
                    classMembers.Add(mbr.Members[i].Name);

                if (s.Where != null)
                    foreach (var b in s.Where.Equations)
                    {
                        var err = false;

                        //Patterns are now allowed in member bindings
                        if (!b.IsFunction() && b.Left.Type != ElaNodeType.NameReference)
                        {
                            AddError(ElaCompilerError.MemberNoPatterns, b.Left, FormatNode(b.Left));
                            err = true;
                        }

                        var name = b.GetLeftName();

                        //Only member functions can be declared inside instance
                        if (!classMembers.Contains(name))
                        {
                            AddError(ElaCompilerError.MemberInvalid, b, name, s.TypeClassName);
                            err = true;
                        }

                        //Compile member function                 
                        if (!err)
                        {
                            classMembers.Remove(name);
                            CompileInstanceMember(s.TypeClassName, s.TypeClassPrefix, b, map, s.TypePrefix, s.TypeName);
                        }
                    }

                //Not all of the members are implemented, which is an error if an instance is
                //not generated by a compiler
                if (!IsBuiltIn(classId, typeId) && classMembers.Count > 0)
                {
                    if (classId <= 0 || classMembers.Count != mbr.Members.Length || !IsAutoGenerated(classId, s))
                        AddError(ElaCompilerError.MemberNotAll, s, s.TypeClassName, s.TypeClassName + " " + s.TypeName);
                }
            }

            if (s.And != null)
                CompileInstance(s.And, map);
        }

        //This method returns type class data including: type class metadata (ClassData), module local ID
        //(modId) and compiled module where class is defined.
        private int ObtainTypeClass(ElaClassInstance s, out ClassData mbr, out int modId, out CodeFrame mod)
        {
            mbr = null;
            modId = -1;
            mod = null;

            //If a type class prefix is not set we need to obtain a type class ID using a special '$$$*' variable
            //that is initialized during type class compilation
            if (s.TypeClassPrefix == null)
            {
                //We first check if a class definition is non-local
                if (!frame.InternalClasses.TryGetValue(s.TypeClassName, out mbr))
                {
                    var sv = GetVariable("$$$" + s.TypeClassName, CurrentScope, GetFlags.NoError, s.Line, s.Column);

                    if (sv.IsEmpty() && !options.IgnoreUndefined)
                    {
                        AddError(ElaCompilerError.UnknownClass, s, s.TypeClassName);
                        return -1;
                    }

                    //The trick is - here sv can be only an external name (we do check prior to this
                    //if a class is not local). If it is an external name that first byte contains a
                    //local index of a referenced module - that is exactly what we need here to obtain
                    //a compiled module frame (from refs array).
                    modId = sv.Address & Byte.MaxValue;

                    if (modId < refs.Count && modId >= 0)
                        mod = refs[modId];

                    return sv.Data;
                }
                else
                {
                    var sv = GetVariable("$$$" + s.TypeClassName, CurrentScope, GetFlags.NoError, s.Line, s.Column);
                    return sv.Data;
                }
            }
            else
            {
                //Type class prefix is set. The prefix itself should be local name (a module alias)
                var sv = GetVariable(s.TypeClassPrefix, s.Line, s.Column);

                if (sv.IsEmpty())
                    return -1;

                //A name was found but this is not a module alias
                if ((sv.Flags & ElaVariableFlags.Module) != ElaVariableFlags.Module)
                {
                    AddError(ElaCompilerError.InvalidQualident, s, s.TypeClassPrefix);
                    return -1;
                }

                //In this case we can look for a reference based on its alias (alias should be unique within
                //the current module).
                modId = frame.References[s.TypeClassPrefix].LogicalHandle;
                
                if (modId < refs.Count && modId >= 0)
                    mod = refs[modId];

                //Now we need to obtain 'data' of a type class variable - it might a type class
                //typeId if this type class is built-in.
                ScopeVar sv2;

                if (mod != null && mod.GlobalScope.Locals.TryGetValue("$$$" + s.TypeClassName, out sv2))
                    return sv.Data;
                else
                    return -1;
            }
        }

        //Here we obtain type information - local ID of a module where a type is defined.
        private int ObtainType(ElaClassInstance s, out int typeModuleCode)
        {
            typeModuleCode = -1;

            if (s.TypePrefix == null)
            {
                //First we check that type is not defined locally
                if (!frame.InternalTypes.ContainsKey(s.TypeName))
                {
                    var sv = GetVariable("$$" + s.TypeName, CurrentScope, GetFlags.NoError, s.Line, s.Column);

                    if (sv.IsEmpty() && !options.IgnoreUndefined)
                    {
                        AddError(ElaCompilerError.UndefinedType, s, s.TypeName);
                        return -1;
                    }

                    //The trick is - here sv can be only an external name (we do check prior to this
                    //if a type is not local). If it is an external name that first byte contains a
                    //local index of a referenced module - and typeModuleCode is effectly a local ID of a module
                    //where a type is declared
                    typeModuleCode = sv.Address & Byte.MaxValue;
                    return sv.Data;
                }
                else
                {
                    var sv = GetVariable("$$" + s.TypeName, CurrentScope, GetFlags.NoError, s.Line, s.Column);
                    return sv.Data;
                }
            }
            else
            {
                //TypePrefix is a local name that should correspond to a module alias
                var sv = GetVariable(s.TypePrefix, s.Line, s.Column);

                if (sv.IsEmpty())
                    return -1;

                //A name exists but this is not a module alias
                if ((sv.Flags & ElaVariableFlags.Module) != ElaVariableFlags.Module)
                {
                    AddError(ElaCompilerError.InvalidQualident, s, s.TypePrefix);
                    return -1;
                }

                //Obtain a local ID of a module based on TypePrefix (which is module alias
                //that should be unique within this module).
                var frm = frame.References[s.TypePrefix];
                typeModuleCode = frm.LogicalHandle;

                //Now we need to obtain type variable data - it may have the typeId of a type
                //if this is a built-in type.
                ScopeVar sv2;

                if (frm != null && typeModuleCode < refs.Count && typeModuleCode >= 0 &&
                    refs[typeModuleCode].GlobalScope.Locals.TryGetValue("$$" + s.TypeName, out sv2))
                    return sv2.Data;

                return -1;
            }
        }

        //Compile an instance member. Argument classPrefix is null if a class is not prefixed, otherwise 
        //it should be used to lookup class members.
        private void CompileInstanceMember(string className, string classPrefix, ElaEquation s, LabelMap map, 
            string currentTypePrefix, string currentType)
        {
            //Obtain a 'table' function of a class
            var name = s.GetLeftName();
            var btVar = default(ScopeVar);

            if (classPrefix == null)
                btVar = GetVariable(name, CurrentScope, GetFlags.NoError, s.Line, s.Column);
            else
            {
                var fr = default(CodeFrame);
                btVar = FindByPrefix(classPrefix, name, out fr);
            }

            if (btVar.IsEmpty())
                AddError(ElaCompilerError.MemberInvalid, s, name, className);
            
            var builtin = (btVar.Flags & ElaVariableFlags.Builtin) == ElaVariableFlags.Builtin;
            var args = 0;

            //Here we need to understand how many arguments a class function has.
            //If our declaration has less arguments (allowed by Ela) we need to do
            //eta expansion.
            if (builtin)
                args = BuiltinParams((ElaBuiltinKind)btVar.Data);
            else
                args = btVar.Data;

            //First we check if this binding is simply a function reference
            if (!TryResolveInstanceBinding(args, s.Right))
            {
                //Eta expansion should be done if a member is not a function literal
                //(it can be a partially applied function) or if a number of arguments
                //doesn't match.
                if (!s.IsFunction())
                    EtaExpand(s.Right, map, args);
                else if (s.GetArgumentNumber() < args)
                    EtaExpand(s, map, args);
                else
                    CompileFunction(s);
            }

            AddLinePragma(s);

            //Depending whether this is a built-in class or a different approach is
            //used to add a member function.
            if (!builtin)
                PushVar(btVar);
            else
                cw.Emit(Op.PushI4, (Int32)btVar.Data);

            //We need to obtain a 'real' global ID of the type that we are extending. This
            //is done using this helper method.
            EmitSpecName(currentTypePrefix, "$$" + currentType, s, ElaCompilerError.UndefinedType);

            //Finally adding a member function.
            cw.Emit(Op.Addmbr);
        }

        //This method checks if an instance member binding is a function reference with a correct number
        //of arguments.
        private bool TryResolveInstanceBinding(int args, ElaExpression exp)
        {
            if (exp == null)
                return false;

            //A simple case - a direct name reference, need to check its type arguments
            if (exp.Type == ElaNodeType.NameReference)
            {
                var sv = GetVariable(exp.GetName(), CurrentScope, GetFlags.NoError, 0, 0);

                if ((sv.VariableFlags & ElaVariableFlags.Function) == ElaVariableFlags.Function && sv.Data == args)
                {
                    AddLinePragma(exp);
                    PushVar(sv);
                    return true;
                }
            }
            else if (exp.Type == ElaNodeType.FieldReference)
            {
                //A more complex case - this can be a qualified name (with a module alias)
                var fr = (ElaFieldReference)exp;

                if (fr.TargetObject.Type != ElaNodeType.NameReference)
                    return false;

                CodeFrame _;
                var sv = FindByPrefix(fr.TargetObject.GetName(), fr.FieldName, out _);

                if ((sv.VariableFlags & ElaVariableFlags.Function) == ElaVariableFlags.Function && sv.Data == args)
                {
                    AddLinePragma(exp);
                    PushVar(sv);
                    return true;
                }
            }
            
            return false;
        }

        //Perform an eta expansion for a given expression
        private void EtaExpand(ElaExpression exp, LabelMap map, int args)
        {
            //Here we generate a function which has a provided number of
            //arguments
            StartSection();
            StartScope(true, exp.Line, exp.Column);
            cw.StartFrame(args);
            var funSkipLabel = cw.DefineLabel();
            cw.Emit(Op.Br, funSkipLabel);
            var address = cw.Offset;

            if (exp.Type != ElaNodeType.Equation)
                CompileExpression(exp, map, Hints.None);
            else
                CompileFunction((ElaEquation)exp);

            //Functions are curried so generate a call for each argument
            for (var i = 0; i < args; i++)
                cw.Emit(Op.Call);

            cw.Emit(Op.Ret);
            frame.Layouts.Add(new MemoryLayout(currentCounter, cw.FinishFrame(), address));
            EndSection();
            EndScope();
            cw.MarkLabel(funSkipLabel);
            cw.Emit(Op.PushI4, args);
            cw.Emit(Op.Newfun, frame.Layouts.Count - 1);
        }

        //An instance might be missing a body. If this instance corresponds to
        //an auto-generated instance we are OK with this, otherwise we will generate
        //an error (on the caller side).
        private bool IsBuiltIn(int classId, int typeId)
        {
            var tc = (ElaTypeCode)typeId;
            var cc = (TypeClass)classId;

            if (tc == ElaTypeCode.None || typeId == -1 || cc == TypeClass.None || classId == -1 || classId == 0)
                return false;

            switch (cc)
            {
                case TypeClass.Eq:
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Char ||
                        tc == ElaTypeCode.Boolean ||
                        tc == ElaTypeCode.Double ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.String ||
                        tc == ElaTypeCode.Unit ||
                        tc == ElaTypeCode.Function ||
                        tc == ElaTypeCode.Module ||
                        tc == ElaTypeCode.Tuple ||
                        tc == ElaTypeCode.Record ||
                        tc == ElaTypeCode.List;
                case TypeClass.Ord:
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Double ||
                        tc == ElaTypeCode.Char ||
                        tc == ElaTypeCode.String;
                case TypeClass.Additive:
                case TypeClass.Modulo:
                case TypeClass.Ring:
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Double;
                case TypeClass.Field:
                    return
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Double;
                case TypeClass.Bit:
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long;
                case TypeClass.Seq:
                    return
                        tc == ElaTypeCode.List ||
                        tc == ElaTypeCode.String;
                case TypeClass.Ix:
                    return
                        tc == ElaTypeCode.String ||
                        tc == ElaTypeCode.Tuple ||
                        tc == ElaTypeCode.Record;
                case TypeClass.Cat:
                    return
                        tc == ElaTypeCode.Char ||
                        tc == ElaTypeCode.String ||
                        tc == ElaTypeCode.Tuple ||
                        tc == ElaTypeCode.Record;
                case TypeClass.Show:
                    return
                        tc == ElaTypeCode.Integer ||
                        tc == ElaTypeCode.Long ||
                        tc == ElaTypeCode.Single ||
                        tc == ElaTypeCode.Double ||
                        tc == ElaTypeCode.Char ||
                        tc == ElaTypeCode.Boolean ||
                        tc == ElaTypeCode.String ||
                        tc == ElaTypeCode.Unit ||
                        tc == ElaTypeCode.Function ||
                        tc == ElaTypeCode.Module;
                default:
                    return false;
            }
        }

        //This function tries to autogenerate an instance (similar to derived in Haskell).
        //Only a limited set of classes supported, if this function fails to autogenerate,
        //it returns fails and an error is raised.
        private bool IsAutoGenerated(int classId, ElaClassInstance inst)
        {
            var cc = (TypeClass)classId;
            
            //Currently only classes Eq, Ord, Show, Ix are supported
            if (cc == TypeClass.Eq)
            {
                GenerateMember(ElaBuiltinKind.Equal, "Eq", inst);
                GenerateMember(ElaBuiltinKind.NotEqual, "Eq", inst);
                return true;
            }
            else if (cc == TypeClass.Ord)
            {
                GenerateMember(ElaBuiltinKind.Greater, "Ord", inst);
                GenerateMember(ElaBuiltinKind.Lesser, "Ord", inst);
                GenerateMember(ElaBuiltinKind.LesserEqual, "Ord", inst);
                GenerateMember(ElaBuiltinKind.GreaterEqual, "Ord", inst);
                return true;
            }
            else if (cc == TypeClass.Show)
            {
                GenerateMember(ElaBuiltinKind.Showf, "Show", inst);
                return true;
            }
            else if (cc == TypeClass.Ix)
            {
                GenerateMember(ElaBuiltinKind.Length, "Ix", inst);
                GenerateMember(ElaBuiltinKind.Get, "Ix", inst);
                return true;
            }
            else
                return false;
        }

        //Generates an instance member using one of the generic prelude functions.
        private void GenerateMember(ElaBuiltinKind builtin, string instName, ElaClassInstance inst)
        {
            //Determine a name of a prelude function based on the built-in name
            var fun =
                    builtin == ElaBuiltinKind.Equal ? "genericEq" :
                    builtin == ElaBuiltinKind.NotEqual ? "genericNeq" :
                    builtin == ElaBuiltinKind.Showf ? "genericShow" :
                    builtin == ElaBuiltinKind.Greater ? "genericGt" :
                    builtin == ElaBuiltinKind.Lesser ? "genericLt" :
                    builtin == ElaBuiltinKind.GreaterEqual ? "genericGtEq" :
                    builtin == ElaBuiltinKind.LesserEqual ? "genericLtEq" :
                    builtin == ElaBuiltinKind.Length ? "genericLength" :
                    builtin == ElaBuiltinKind.Get ? "genericItem" :
                    String.Empty;

            var sv = GetVariable(fun, globalScope, GetFlags.NoError, 0, 0);

            //We couldn't find a function, generate an error
            if (!options.IgnoreUndefined && (sv.IsEmpty() || ((sv.Flags & ElaVariableFlags.Infrastructure) != ElaVariableFlags.Infrastructure)))
            {
                var tname = instName + " " + (inst.TypePrefix == null ? inst.TypeName : inst.TypePrefix + "." + inst.TypeName);
                AddError(ElaCompilerError.UnableAutoGenerateInstance, inst, tname, fun);
            }

            //Generate a member
            PushVar(sv);
            cw.Emit(Op.PushI4, (Int32)builtin);
            EmitSpecName(inst.TypePrefix, "$$" + inst.TypeName, inst, ElaCompilerError.UndefinedType);
            cw.Emit(Op.Addmbr);
        }
    }
}
