COMPILER Ela

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	newLine = cr + lf.
	tab = '\t'.    
	letter = 'A' .. 'Z' + 'a' .. 'z' + '_'.
	ucase = 'A' .. 'Z'.
	lcase = 'a' .. 'z'.
	digit = "0123456789".
	notDigit = ANY - digit.
	hexDigit = digit + "ABCDEFabcdef".
	verbatimChar = ANY - "]>".
	stringChar = ANY - '"' - '\\' - newLine.
	char = ANY - "'" - '\\' - newLine.
	op = "!%&*+-.:/\\<=>?@^|~".
	op2 = "!%&*+-.:/\\<=?@^|~".
	op3 = "!%&*+-.:/\\=>?@^~".
	op4 = "!%&*+.:/\\<=>?@^|~".
	op5 = "!%&*+-./\\<=>?@^|~".
	
	op6 = "!%&*+.:/\\<=?@^|~".
	

TOKENS
	ident = lcase { letter | digit | "'" }
			| "_" ("'"|letter) { letter | digit | "'" }
			| "'" letter [ (letter|digit|"'") {letter|digit|"'"} (letter|digit) ].	
    
	variantTok = ucase { letter | digit | "'" }.
	
	intTok = ( digit { digit } | digit { digit } CONTEXT ("." notDigit) | 
			( "0x" | "0X" ) hexDigit { hexDigit } ) [ "L" | "l" ].
			
	realTok = "." digit { digit } [ ( "e" | "E") [ "+" | "-" ] digit { digit } ] [ "D" | "d" | "F" | "f"| "M" | "m" ] 
			| digit { digit } 
			( 
				"." digit { digit } 
				[ ( "e" | "E" ) ["+" | "-" ] digit { digit } ] [ "D" | "d" | "F" | "f"| "M" | "m" ] 
				| ( "e" | "E") ["+" | "-" ] digit { digit } [ "D" | "d" | "F" | "f" | "M" | "m" ]  | "D" | "d" | "F" | "f"| "M" | "m"
			).		
			
	stringTok = "\"" { stringChar
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					| "\\x" digit digit digit digit digit
					}  
				"\""
				| "<[" {verbatimChar} "]>".
				
	charTok = 	"'" ( char
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					| "\\x" digit digit digit digit digit
					)  
				"'".
				
    operatorTok0 = ("|"|"&") { op }.
	operatorTok1 = (
	      "=" { op }
        | ">" [ op2 { op } ]
		| "<" [ op3 { op } ]
		).
	operatorTok2 = "^" { op }.
	operatorTok3 = "::" { op }.
	operatorTok4 = (
		"+" { op }
		| "-" [
		        op4 op { op }
		        | op6 { op }
		    ]
		).
	operatorTok5 = ("*"|"/"|"%") { op }.		
	operatorTok6 = "<<" { op }.
	operatorTok7 = ">>" { op }.
	operatorTok8 = (("~"|"--"|"!"|"?") { op }
	               | ":" [ op5 { op } ])
	               | "." op { op }.
	operatorTok9 = "<|" { op }.
	
	LBRA = "{".
	RBRA = "}".
	LILB = "[".
	LIRB = "]".
	
	PIPE = "|".
	ARROW = "->".
	LAMBDA = "\\".
	COMPO = "\\\\".
	
	DOT = ".".
	IN = "in".
	MATCH = "match".
	ASAMP = "@".
	IS = "is".	
	LET = "let".
	OPEN = "open".	
	WITH = "with".
	IFS = "if".
	ELSE = "else".
	THEN = "then".
	RAISE = "raise".
	TRY = "try".
	TRUE = "true".
	FALSE = "false".
	FAIL = "fail".
	WHERE = "where".
	INSTANCE = "instance".
	TYPE = "type".
	CLASS = "class".
	IMPORT = "import".
	DATA = "data".
	OPENTYPE = "opentype".
	
	EBLOCK = ";".
	
	
COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/"
IGNORE cr + lf

PRODUCTIONS
	EndBlock = EBLOCK (. if (!t.virt) scanner.PopIndent(); .).
	
	Literal<out ElaExpression exp> = 
		(. exp = null; .)
		(	
			Primitive<out exp>
			| RecordLiteral<out exp>
			| ListLiteral<out exp>
			| TupleLiteral<out exp>
			| SimpleExpr<out exp>
		)
		[ As<ref exp> ].		
		
	Attribute<ref ElaExpression head> =
	    (. 
	        scanner.InjectBlock(); 
	        var flags = ElaVariableFlags.None;
	        
	        if (head.Type != ElaNodeType.NameReference)
	            AddError(ElaParserError.InvalidAttribute, head.ToString());
	    .)
	    "#" 
	    ident (. flags = ProcessAttribute(t.val,flags); .) 
	    { ident (. flags = ProcessAttribute(t.val,flags); .) } 
	    EndBlock
	    (.
	        var h = new ElaHeader { Name = head.GetName(), Attributes = flags };
	        h.SetLinePragma(head.Line, head.Column);
	        head = h;
	    .).
		
	SimpleExpr<out ElaExpression exp> = 
		VariableReference<out exp>.
		
	Primitive<out ElaExpression exp> = 
		(. exp = null; .)
		(
			intTok  (. exp = new ElaPrimitive(t) { Value = ParseInt(t.val) };	.)
			| realTok (. exp = new ElaPrimitive(t) { Value = ParseReal(t.val) }; .)
			| stringTok (. exp = new ElaPrimitive(t) { Value = ParseString(t.val) }; .)
			| charTok (. exp = new ElaPrimitive(t) { Value = ParseChar(t.val) }; .)
			| TRUE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(true) }; .) 
			| FALSE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(false) }; .)
		).
		
	VariableReference<out ElaExpression exp> =
		(. exp = null; .)
		(
			(
			    ident (. exp = new ElaNameReference(t) { Name = t.val }; .)
			    | variantTok (. exp = new ElaNameReference(t) { Name = t.val, Uppercase = true }; .)
			)
			| "_" (. exp = new ElaPlaceholder(t); .)
		).
		
	TupleLiteral<out ElaExpression exp> =
		(. 
			var ot = default(Token);
			exp = null; 
		.)
		(
			"(" 
				(. ot = t; .)
				[ GroupExpr<out exp> ]
				(.
				    if (exp != null)
				        exp.Parens = true;
				.)
			")"
		)
		(.
			if (exp == null)
				exp = new ElaUnitLiteral(ot);
		.).			
		
	GroupExpr<out ElaExpression exp> = 
		(. 
			exp = null; 
			var cexp = default(ElaExpression);
			var ot = t;
		.)
		(
			Expr<out exp>
			[
				(
					(. 
						var tuple = new ElaTupleLiteral(ot); 
						tuple.Parameters.Add(exp);
						exp = tuple; 
					.)		
					","
					(	
						[
							Expr<out cexp> 
							(. tuple.Parameters.Add(cexp); .)
						]
						{ "," Expr<out cexp> (. tuple.Parameters.Add(cexp); .) }
					)
				)
			]
		).
		
	RecordLiteral<out ElaExpression exp> =
		(. 
			exp = null; 
			var fld = default(ElaFieldDeclaration);
		.)
		(
			"{"
				(. var rec = new ElaRecordLiteral(t); exp = rec; .) 
				RecordField<out fld> (. rec.Fields.Add(fld); .)				
				{ "," RecordField<out fld> (. rec.Fields.Add(fld); .) }
			"}"
		).
		
	RecordField<out ElaFieldDeclaration fld> = 
		(. 
			fld = null; 
			var cexp = default(ElaExpression);
		.)
		(
			(
				(
					ident
					(. fld = new ElaFieldDeclaration(t) { FieldName = t.val }; .) 
					[						
						"=" Expr<out cexp> 
						(. fld.FieldValue = cexp; .)
					]
					(.
						if (fld.FieldValue == null)
							fld.FieldValue = new ElaNameReference(t) { Name = t.val };
					.)
				)
				|
				(
					stringTok
					(. fld = new ElaFieldDeclaration(t) { FieldName = ReadString(t.val) }; .) 
					"=" 
					Expr<out cexp> 
					(. fld.FieldValue = cexp; .)
				)
			)
		).
		
	RangeExpr<ElaExpression first, ElaExpression sec, out ElaRange rng> = 
		(. 
			rng = new ElaRange(t) { First = first, Second = sec };
			var cexp = default(ElaExpression);
		.)
		".."
		[
			Expr<out cexp>
			(. rng.Last = cexp; .)
		].
						
	ParamList<. out List<ElaExpression> list, out ElaComprehension comp, out ElaRange rng .> =
		(. 
			var exp = default(ElaExpression); 
			list = null;
			comp = null;
			rng = null;
		.)
		Expr<out exp> 
		[
			ComprehensionExpr<exp, out comp>
			| RangeExpr<exp, null, out rng>
			|
			(
				(. var oexp = exp; .)
				"," Expr<out exp> 
				(
					RangeExpr<oexp, exp, out rng>
					|
					(
						(. 
							list = new List<ElaExpression>();
							list.Add(oexp);
							list.Add(exp);
						.)
						{ 
							"," Expr<out exp> 
							(. list.Add(exp); .)
						}
					)
				)
			)
		]
		(.
			if (list == null && comp == null && rng == null && exp != null)
			{
				list = new List<ElaExpression>();
				list.Add(exp);
			}
		.).
		
	ListLiteral<out ElaExpression exp> = 
	    (. exp = null; .)
	    (
		    (
		        "["
			        (. 
				        var list = default(List<ElaExpression>);
				        var comp = default(ElaComprehension);
				        var rng = default(ElaRange);
				        var ot = t;
        				
				        exp = null;
			        .)
			        [ 
				        (
					        ParamList<out list, out comp, out rng> 
					        (. 
						        if (list != null)
						        {
						            var listExp = new ElaListLiteral(ot) { Values = list };
							        exp = listExp;
						        }	
						        else if (comp != null)
						            exp = comp;
						        else if (rng != null)
						            exp = rng;
					        .)
				        )
			        ] 
			        (.
				        if (exp == null)
					        exp = new ElaListLiteral(ot);
			        .)
		        "]"
		    )
		    |
		    (
		        "[&"
			        (. 
				        var comp = default(ElaComprehension);
				        var ot = t;        				
				        exp = null;
			        .)
		   	        (
				        (. var cexp = default(ElaExpression); .)
				        Expr<out cexp> ComprehensionExpr<cexp, out comp>
				        (. 
					        comp.Lazy = true;
					        exp = comp;
				        .)
			        )
		        "]"
		    )
		).
		
	Operators = operatorTok0|operatorTok1|operatorTok2|operatorTok3|operatorTok4|operatorTok5|operatorTok6|operatorTok7|operatorTok8|operatorTok9|"::".
			
	IfExpr<out ElaExpression exp> = 
		IFS
		(. 
			var cond = new ElaCondition(t); 
			var cexp = default(ElaExpression);	
			exp = cond;
		.)
		Expr<out cexp> (. cond.Condition = cexp; .)
		THEN Expr<out cexp> (. cond.True = cexp; .)
		WEAK ELSE Expr<out cexp> (. cond.False = cexp; .).
		
	MatchExpr<out ElaExpression exp> = 
	    (. 
	        scanner.InjectBlock(); 
	        bindings.Push(unit);
	    .)
		SYNC MATCH
		(. 
			var match = new ElaMatch(t);
			exp = match; 
			var block = default(ElaEquationSet);
			var cexp = default(ElaExpression);
		.)
		Expr<out cexp> (. match.Expression = cexp; .)
		WITH BindingChain<out block>
		(. 
		    match.Entries = block; 
		    bindings.Pop();
		.)
		EndBlock.
		
	TryExpr<out ElaExpression exp> = 
	    (. 
	        scanner.InjectBlock(); 
	        bindings.Push(unit);
	    .)
		SYNC TRY
		(. 
			var match = new ElaTry(t);
			exp = match; 
			var block = default(ElaEquationSet);
			var cexp = default(ElaExpression);
		.)
		Expr<out cexp> (. match.Expression = cexp; .)
		WITH BindingChain<out block>
		(. 
		    match.Entries = block; 
		    bindings.Pop();
		.)
		EndBlock.
			
	/* Expr */
					
	OrExpr<out ElaExpression exp> =
		AndExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"or" AndExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaOperator.BooleanOr, Right = cexp }; 
			.)			
		}.
		
	AndExpr<out ElaExpression exp> =
		OpExpr0<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"and" OpExpr0<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaOperator.BooleanAnd, Right = cexp }; 
			.)
		}.		
			
	OpExpr0<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr1b<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok0 (. op = t.val; .)
					[ OpExpr1b<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok0 (. op = t.val; .)
				[ 
					OpExpr1b<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = op };
				.)
			)
		).
			
	OpExpr1b<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr1<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok9 (. op = t.val; .)
					[ OpExpr1b<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}			
			)
			|
			(
				operatorTok9 (. op = t.val; .)
				[ 
					OpExpr1<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = t.val };
				.)
			)
		).
			
	OpExpr1<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr2<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok1 (. op = t.val; .)
					[ OpExpr2<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok1 (. op = t.val; .)
				[ 
					OpExpr2<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = op };
				.)
			)
		).
			
	OpExpr2<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr3<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok2 (. op = t.val; .)
					[ OpExpr3<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok2 (. op = t.val; .)
				[ 
					OpExpr3<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = t.val };
				.)
			)
		).
			
			
	OpExpr3<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr4<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					(operatorTok3|"::") (. op = t.val; .)
					[ OpExpr3<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}			
			)
			|
			(
				(operatorTok3|"::") (. op = t.val; .)
				[ 
					OpExpr4<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = t.val };
				.)
			)
		).
		
	OpExpr4<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr5<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok4 (. op = t.val; .)
					[ OpExpr5<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok4 (. op = t.val; .)
				[ 
					OpExpr5<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = t.val };
				.)
			)
		).
		
	OpExpr5<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				InfixExpr<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok5 (. op = t.val; .)
					[ InfixExpr<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok5 (. op = t.val; .)
				[ 
					InfixExpr<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = t.val };
				.)
			)
		).
		
	InfixExpr<out ElaExpression exp> = 
		(. 
			exp = null;
			var ot = t; 
			var funexp = default(ElaExpression);
		.)				
		(
			(
				OpExpr6<out exp>
				{
					(. 
						var cexp = default(ElaExpression); 
						ot = t;
					.)
					(
						"`" OpExpr6<out funexp> "`"
					)
					[ OpExpr6<out cexp> ]
					(. 
						var fc = new ElaJuxtaposition(ot) { 
								Target = funexp
							};
						fc.Parameters.Add(exp);			
						
						if (cexp != null)
							fc.Parameters.Add(cexp);
										
						exp = fc;
					.)
				}
			)
			|
			(
				(
					"`" OpExpr6<out funexp> "`"
				)
				[ 
					OpExpr6<out exp> 
					(. exp = GetPrefixFun(funexp, exp, true);	.)
				]
				(.
					if (exp == null)
						exp = funexp;
				.)				
			)
		).
		
	OpExpr6<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr7<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok6 (. op = t.val; .)
					[ OpExpr6<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}			
			)
			|
			(
				operatorTok6 (. op = t.val; .)
				[ 
					OpExpr7<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = t.val };
				.)
			)
		).
		
	OpExpr7<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr8<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok7 (. op = t.val; .)
					[ OpExpr8<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}			
			)
			|
			(
				operatorTok7 (. op = t.val; .)
				[ 
					OpExpr8<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = t.val };
				.)
			)
		).
		
	OpExpr8<out ElaExpression exp> = 
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)
		(
			(
				Application<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					(operatorTok8) (. op = t.val; .)
					[ Application<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				(operatorTok8) (. op = t.val; .)
				[ 
					Application<out exp>
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaNameReference(ot) { Name = t.val };
				.)
			)
		).
			
	Application<out ElaExpression exp> = 
		(. exp = null; .)
		(
			AccessExpr<out exp>
			(. 
				var ot = t;
				var mi = default(ElaJuxtaposition); 
				var cexp = default(ElaExpression);
			.)	
			{
				AccessExpr<out cexp>					
				(. 
					if (mi == null)
					{
					    mi = new ElaJuxtaposition(ot) { Target = exp };
						exp = mi;
					}
				
				    if (mi != null)
					    mi.Parameters.Add(cexp); 
				.)					
			}								
		).
		
	AccessExpr<out ElaExpression exp> =
		Literal<out exp>
		{ 
			"."
			(
				(
					"("
						(ident|variantTok|Operators)
						(. exp = new ElaFieldReference(t) { FieldName = t.val, TargetObject = exp }; .)
					")"
				)
				|
				(
					(ident|variantTok) (. exp = new ElaFieldReference(t) { FieldName = t.val, TargetObject = exp }; .)					
				)
			)			
		}.	
					
	BinaryExpr<out ElaExpression exp> = 
		(. 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OrExpr<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					"$"
					OrExpr<out cexp>
					(. 
						exp = new ElaBinary(t) { Operator = ElaOperator.Sequence, Left = exp, Right = cexp };
					.)
				}
			)
		).	
		
	EmbExpr<out ElaExpression exp> = 
		(. exp = null; .)
		(  
			BinaryExpr<out exp> [TypeCheckExpr<ref exp>]
			| IfExpr<out exp>  
			| LazyExpr<out exp>
			| LetBinding<out exp>			
			| Builtin<out exp>	
			| LambdaExpr<out exp>
			| FailExpr<out exp>
			| MatchExpr<out exp>
			| TryExpr<out exp>
		).
	
	TypeCheckExpr<ref ElaExpression pat> = 
		IS
		(. 
			var eis = new ElaTypeCheck(t) { Expression = pat };
			pat = eis; 			
			var fst = default(String); 
			var snd = default(String);
		.)
		(
		    { 
                (ident|variantTok) (. fst = t.val; snd = null; .) 
                [ "." (ident|variantTok) (. snd = t.val; .) ]
                (.
                    var ti = new TraitInfo(snd != null ? fst : null, snd != null ? snd : fst);
                    eis.Traits.Add(ti);
                .)			                
            }
		).
		
	As<ref ElaExpression exp> =
	    (
	        "@" 
	        (. 
	            var @as = new ElaAs(t) { Expression = exp }; 
	            exp = @as; 
	        .)
	        (
	            ident (. @as.Name = t.val; .)
	            | "(" Operators (.  @as.Name = t.val; .) ")"
	        )
	    ).
        
	Expr<out ElaExpression exp> = 
		(. exp = null; .)
		( 
			EmbExpr<out exp>			
		).
		
	Builtin<out ElaExpression exp> = 
	    (
		    "__internal" ident
		    (. exp = new ElaBuiltin(t) { Kind = Builtins.Kind(t.val) }; .)
	    ).
		
	LazyExpr<out ElaExpression exp> =
		(
			"&" 
			(. var lazy = new ElaLazyLiteral(t); .)
			Expr<out exp>
			(.
			    lazy.Expression = exp;
				exp = lazy;
			.)
		).
		
	FailExpr<out ElaExpression exp> = 
		FAIL
		(. 
			var r = new ElaRaise(t);
			exp = r;
			var cexp = default(ElaExpression); 
		.)		
		Expr<out cexp>
		(. 
			r.Expression = cexp; 
		.).	
		
	ComprehensionExpr<ElaExpression sel, out ElaComprehension exp> =
		(. 	
			var it = default(ElaGenerator); 
			var ot = t;		
		.)
		"\\\\" ComprehensionEntry<sel, out it>
		(. exp = new ElaComprehension(ot) { Generator = it }; .).
		
	ComprehensionEntry<ElaExpression body, out ElaGenerator it> =
		(.
			it = new ElaGenerator(t);
			it.Body = body;
			var cexp = default(ElaExpression);
			var pat = default(ElaExpression);
		.)
		(
			Expr<out pat> "<-" Expr<out cexp>
			(. 
				it.Pattern = pat;
				it.Target = cexp;
			.)
		)
		[ 
			(
				(. var cit = default(ElaGenerator); .)
				"," ComprehensionEntry<body, out cit>
				(. it.Body = cit; .)
			)
			|
			(
				"|" Expr<out cexp>
				(. it.Guard = cexp; .)
				[
				    (
				        (. var cit = default(ElaGenerator); .)
				        "," ComprehensionEntry<body, out cit>
				        (. it.Body = cit; .)
			        )
				]
			)
		].		
	
	LambdaExpr<out ElaExpression exp> =
		SYNC LAMBDA
		(.
		    var lambda = new ElaLambda(t);
		    exp = lambda;
			var left = default(ElaExpression);
			var right = default(ElaExpression);
		.)
		(
		    Expr<out left>
			(
				"->" Expr<out right> 
	            | "|" LambdaGuard<out right>
			)
			(.
			    lambda.Left = left;
			    lambda.Right = right;
			.)
		).
		
	LambdaGuard<out ElaExpression exp> = 
	    (. 
	        var ifExp = new ElaCondition(t);
	        exp = ifExp;
	        
	        var cond = default(ElaExpression);
	        var trueExp = default(ElaExpression);
	        var falseExp = default(ElaExpression);
	    .)
	    (
	        Expr<out cond> (. ifExp.Condition = cond; .)
	        "->" Expr<out trueExp> (. ifExp.True = trueExp; .)
	        (
	            "|" 
	            (
	                ( "else" "->" Expr<out falseExp>)
	                | LambdaGuard<out falseExp>
	            )
	            (. ifExp.False = falseExp; .)
	        )
	    ).   
		
	WhereBinding<out ElaEquationSet block> = 
		(. 
		    scanner.InjectBlock(); 
		    bindings.Push(null);
		    var skip = false;
		.) 
		SYNC WHERE [EndBlock (. skip=true; .)]
		BindingChain<out block> 
		(. bindings.Pop(); .)
		(. if (!skip) .) EndBlock.
	
	LetBinding<out ElaExpression exp> = 
	    (. exp = null; .)
	    (
	        SYNC LET 
	        (. 
	            var bid = new ElaLetBinding(t);
	            var block = default(ElaEquationSet);
	            var cexp = default(ElaExpression);
	            exp = bid;
	        .)
		    BindingChain<out block> 
		    IN Expr<out cexp>
		    (.
		        bid.Equations = block;
		        bid.Expression = cexp;
		    .)
		).
		
	BindingChain<out ElaEquationSet block> =
	    (. 
	        block = new ElaEquationSet(); 
	        scanner.InjectBlock();
	    .)
	    (
	        Binding<block> (. if (RequireEndBlock()) .) EndBlock
	        {	            
	            (. scanner.InjectBlock(); .)
	            Binding<block>
	            (. if (RequireEndBlock()) .) EndBlock
	        }
	    ).	 
	    
	Guard<out ElaExpression exp> = 
	    (. 
	        var ifExp = new ElaCondition(t);
	        exp = ifExp;
	        
	        var cond = default(ElaExpression);
	        var trueExp = default(ElaExpression);
	        var falseExp = default(ElaExpression);
	    .)
	    (
	        Expr<out cond> (. ifExp.Condition = cond; .)
	        "=" Expr<out trueExp> (. ifExp.True = trueExp; .)
	        (
	            "|" 
	            (
	                ( "else" "=" Expr<out falseExp>)
	                | Guard<out falseExp>
	            )
	            (. ifExp.False = falseExp; .)
	        )
	    ).   
		
	Binding<ElaEquationSet block> =
	    (. 
	        var bid = default(ElaEquation);
	        var left = default(ElaExpression);
	        var right = default(ElaExpression);
	    .)
	    (
	        Expr<out left> (. bid = new ElaEquation(t); .)
	        [ 
	            "=" Expr<out right> 
	            | "|" Guard<out right>
	            | Attribute<ref left>
	        ]
	        [
	            (. var cb = default(ElaEquationSet); .)
	            WhereBinding<out cb>
	            (. 
	                if (left != null && left.Type == ElaNodeType.Header)
	                    AddError(ElaParserError.InvalidAttributeWhere);
	            
	                var letb = new ElaLetBinding();                    
                    if (cb != null) letb.SetLinePragma(cb.Line, cb.Column);                    
                    letb.Equations = cb;
	                    
	                if (right != null)
	                {
	                    letb.Expression = right;
                        right = letb;
	                }
	                else
	                {
	                    letb.Expression = left;
	                    left = letb;
	                }	                    
	            .)
	        ]
	        (. ProcessBinding(block, bid, left, right); .)
	    ).
	    
	IncludeStat = 
		(. var qual = false; .)
		(
			(. scanner.InjectBlock(); .)
			SYNC (OPEN|IMPORT (. qual=true; .))
			IncludeStatElement<qual>
			EndBlock
		).
	
	IncludeStatElement<bool qual> =
	    (
			(. var inc = new ElaModuleInclude(t) { RequireQualified=qual }; .)
			Qualident<inc.Path>
			(.
				var name = inc.Path[inc.Path.Count - 1];				
				inc.Path.RemoveAt(inc.Path.Count - 1);				
				inc.Alias = inc.Name = name;
				
				if (Program.Includes == null)
				    Program.Includes = inc;
				else
				{
				    inc.And = Program.Includes;
				    Program.Includes = inc;
				}
			.)	
			[
				"#"
				(
					ident (. inc.DllName = t.val; .)
					| stringTok (. inc.DllName = ReadString(t.val); .)
				)
			]		
			[ 
				"@" ident 
				(. inc.Alias = t.val; .) 
			]
			[
				(. var imp = default(ElaImportedVariable); .)
				"("
					ImportName<out imp> (. inc.ImportList.Add(imp); .)
					{ "," ImportName<out imp> (. inc.ImportList.Add(imp); .) }
				")"
			]
		)
		[ IncludeStatElement<qual> ].
		
	ImportName<out ElaImportedVariable imp> =
		(. 
		    imp = new ElaImportedVariable(t); 
		.)
		(
			ident (. imp.Name = imp.LocalName = t.val; .)
			[ 
			    ident 
			    (. 
			        if (imp.Name != "private")
			            AddError(ElaParserError.UnknownAttribute, imp.Name);
			        
			        imp.Private = true;
			        imp.Name = imp.LocalName = t.val; 
			    .)
			]
			[ "=" ident (. imp.Name = t.val; .) ]
		).
		
	Qualident<. List<String> path .> = 
		(. var val = String.Empty; .)
		(
			ident (. val = t.val; .)
			| stringTok (. val = ReadString(t.val); .)
		)
		(. path.Add(val); .)
		[ "." Qualident<path> ].
		
	TypeClass = 
	    (. 
	        var tc = default(ElaTypeClass);
	        scanner.InjectBlock();
	    .)
	    (
	        CLASS 
	        (. 
	            tc = new ElaTypeClass(t); 	            
	            tc.And = Program.Classes;
	            Program.Classes = tc;
	        .)
	        variantTok
	        (. 
	            var nm = default(String);
	            tc.Name = t.val;
	        .)
	        [ "(" variantTok (. tc.BuiltinName=t.val; .) ")" ]
	        (
	            (
	                (. var targ = String.Empty; .)
	                ident (. targ = t.val; .)
	                (
	                    "where"
	                    (
	                        (ident (. nm=t.val; .) |Operators (. nm=t.val; .) | "(" (Operators|ident) (. nm=t.val; .) ")") 
	                        (.
	                            var count = 0;
	                            var mask = 0;
	                        .)
	                        (
	                            (ident|"_") (. BuildMask(ref count, ref mask, t.val, targ); .)
	                            { "->" (ident|"_") (. BuildMask(ref count, ref mask, t.val, targ); .)  }
	                        )
	                        (.	                        
	                            tc.Members.Add(new ElaClassMember(t) { Name = nm, Arguments = count, Mask = mask });
	                        .)
	                    )
	                    { 
	                        (ident (. nm=t.val; .) |Operators (. nm=t.val; .) | "(" (Operators|ident) (. nm=t.val; .) ")") 
	                        (.
	                            count = 0;
	                            mask = 0;
	                        .)
	                        (
	                            (ident|"_") (. BuildMask(ref count, ref mask, t.val, targ); .)
	                            { "->" (ident|"_") (. BuildMask(ref count, ref mask, t.val, targ); .)  }
	                        )
	                        (.	                        
	                            tc.Members.Add(new ElaClassMember(t) { Name = nm, Arguments = count, Mask = mask });
	                        .)
	                    }
	                )
	            )
	        )
	        EndBlock
	    ).
	    
    NewType = 
        (. 
            scanner.InjectBlock(); 
            var extends = false;
            var opened = false;
        .)
        (
            (TYPE|DATA (. extends=true; .)|OPENTYPE (. opened=true; .))
            (. var nt = new ElaNewtype(t) { Extends=extends,Opened=opened }; .) 
            (
                ident (. nt.Prefix = t.val; .) "." variantTok (. nt.Name = t.val; .)
                | variantTok (. nt.Name = t.val; .)
            )
            (.
                nt.And = Program.Types;
	            Program.Types = nt;
            .)
            [
                (
                    (. var cexp = default(ElaExpression); .)
                    "="
                    ["|"] NewTypeConstructor<nt>
                    {  "|" NewTypeConstructor<nt> }
                )
                |
                (
                    "#" (. nt.Header = true; .)
	                ident (. nt.Flags = ProcessAttribute(t.val,nt.Flags); .) 
	                { ident (. nt.Flags = ProcessAttribute(t.val,nt.Flags); .) } 
                )
		    ]
		    [
		        "deriving" 
		        (. 
		            var tt = t; 
		            string pf;
		            string nm;
		        .)
		        {
		            (
                       ident (. pf=t.val; .) "." variantTok (. nm=t.val; .)
                       | variantTok (. pf=null;nm=t.val; .)
                    )
                    (.                        
	                    var ci = new ElaClassInstance(tt);
	                    ci.And = Program.Instances;
	                    Program.Instances = ci;
	                    ci.TypeName = nt.Name;
	                    ci.TypePrefix = nt.Prefix;
	                    ci.TypeClassPrefix = pf;
	                    ci.TypeClassName = nm;
                    .)
                }
                
		    ]
		    EndBlock      
        ).
        
    NewTypeConstructor<ElaNewtype nt> = 
        (. 
            var flags = ElaVariableFlags.None; 
            var exp = default(ElaExpression);
        .)
        (
            OpExpr0<out exp>
            [
                "#" 
	            ident (. flags = ProcessAttribute(t.val,flags); .) 
	            { ident (. flags = ProcessAttribute(t.val,flags); .) } 
	        ]
	        (. 
	            nt.Constructors.Add(exp); 
	            nt.ConstructorFlags.Add(flags);
	        .)
	    ).
        
	ClassInstance = 
	    (. 
	        var block = default(ElaEquationSet);
	        var ot = t;
	        var list = default(List<ElaClassInstance>);
	    .)
	    (
	        INSTANCE
	        (.
	            var ci = new ElaClassInstance(t);	            
	            ci.And = Program.Instances;
	            Program.Instances = ci;
	            ot = t;
	        .)
	        (
	            ident (. ci.TypeClassPrefix=t.val; .) "." variantTok (. ci.TypeClassName=t.val; .)
	            | variantTok (. ci.TypeClassName=t.val; .)
	        )
	        {
	            (.
	                if (ci.TypeName != null)
	                {
	                    if (list == null)
	                    {
	                        list = new List<ElaClassInstance>();
	                        list.Add(ci);
	                    }
    	                
	                    ci = new ElaClassInstance { TypeClassPrefix = ci.TypeClassPrefix, TypeClassName = ci.TypeClassName };
	                    ci.SetLinePragma(ot.line, ot.col);
	                    ci.And = Program.Instances;
	                    Program.Instances = ci;
	                    list.Add(ci);
	                }
	            .)
	            (
	                ident (. ci.TypePrefix = t.val; .) "." variantTok (. ci.TypeName=t.val; .)
	                | variantTok (. ci.TypeName=t.val; .)
	            )
	        }
	        [
	            WhereBinding<out block>
	            (. 
	                if (list == null)
	                    ci.Where = block; 
	                else
	                {
	                    for (var i = 0; i < list.Count; i++)
	                        list[i].Where = block;
	                }
	            .)
	        ]
	    ).
	    		
	TopLevel =
	    (. scanner.InjectBlock(); .)
	    (
	        Binding<Program.TopLevel>
	        | IncludeStat
	        | TypeClass
	        | NewType
	        | ClassInstance
	    )
	    EndBlock
	    [ TopLevel ].
		
	Ela = 
		(
			(. Program = new ElaProgram(); .)			
			TopLevel
		).		
		
END Ela.