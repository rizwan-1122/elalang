let simple {eqt} =
        eqt <| v is Some
        $ eqt <| v2 is Some 2
        $ eqt <| v3 is None
        where v = Some
           et v2 = Some 2
           et v3 = None
    
let simple2 {eqt} = 
        eqt <| v is (Some (12, _))
        $ eqt <| v2 is (Some (1::x::xs))
        where v = Some (12, 20)
           et v2 = Some [1,2,3]

let matchTest {eq} =
        match v with
                Some m = eq m "message"
        where v = Some "message"

let nested {eqt} =
        match n with
              Left x = eqt (x is Right)
              Right _ = eqt false
        where n = Left (Right 12)

let caseMatch {eqf,eqt} = 
        eqf (n is Some)
        $ eqt (n is SOme)
        where n = SOme 0

let tagTest {eq} =
          eq (tag v) "Some"
        $ eq (tag v2) "Foo"
        $ eq (tag v3) "Bar"
        where v  = Some "message"
           et v2 = Foo (1,2,3)
           et v3 = Bar

let untagTest {eq} = 
          eq (untag v) "message"
        $ eq (untag v2) (1,2,3)
        $ eq (untag v3) ()
        where v  = Some "message"
           et v2 = Foo (1,2,3)
           et v3 = Bar

let identityVariant {eq} =
        eq (toFoo(Foo 12)) (toFoo(Foo 12))
        $ eq (toFoo 12) (toFoo(Foo 12))
        where toFoo (Foo)@x = x
              toFoo x = Foo x

let compare {eq,neq} =
        eq v1 v3
        $ neq v1 v7
        $ eq v4 v5
        $ eq v2 v6
        where v1 = Foo 12
           et v2 = Foo true
           et v3 = Foo 12
           et v4 = Foo (& 12)
           et v5 = Foo (& 12)
           et v6 = Foo (& true)
           et v7 = Foo 23

let typeCheck {eqt} =
        let vr  = None in
        eqt (vr is ?variant)

