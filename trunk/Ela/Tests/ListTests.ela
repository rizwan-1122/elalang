let fromLiteral {eq} =
        let list = ['E', 'l', 'a'] in
        eq (length list) 3
        $ eq (list:0) 'E'
        $ eq (list:1) 'l'
        $ eq (list:2) 'a'

let cons {eq} =
        let list = 0::1::2::3::[] in
        eq (length list) 4
        $ eq (list:0) 0
        $ eq (list:3) 3

let headTail {eq} =
        let head x::_ = x
         et tail _::xs = xs
         et list = [0, 1, 2, 3]
        in
        eq (head list) 0
        $ eq ((tail list) |> length) 3
        $ eq ((tail list):0) 1
       
let headTail2 {eqt} = eqt res
        where lst = [1,2,3]
           et res = match lst with
                          [1]   = false
                          [1,2] = false
                          x::xs = (xs is [2,3])

let zips {eqt} =
        let zip x::xs y::ys = (x, y) :: zip xs ys
            zip _ _         = [] in
        let f1 = zip [1,2,3,4,5] [5,5,5,5,5] in
        let f2 = zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"] in
        eqt (f1:0 is (1, 5))
        $ eqt (f1:1 is (2, 5))
        $ eqt (f1:2 is (3, 5))
        $ eqt (f1:3 is (4, 5))
        $ eqt (f1:4 is (5, 5))
        $ eqt (f2:0 is (5,"im"))
        $ eqt (f2:1 is (3,"a"))
        $ eqt (f2:2 is (2,"turtle"))

let structuralComp {eqt,eqf} =
        eqt (xs1 == xs2)
        $ eqf (xs1 == xs3)
        $ eqt (xs1 <> xs3)
        $ eqt (xs2 <> xs3)
        $ eqt (xs3 == [1..10])
        $ eqt (xs3 == xs4)
        $ eqf (xs2 == xs4)
        where xs1 = [1..5]
           et xs2 = [1..5]
           et xs3 = [1..10]
           et xs4 = [& x \\ x <- [1..10]]
           
let reverseElems {eqt} =
        let reverse' x::xs = reverse' xs ++ [x]
            reverse' []    = [] 
        in
        let res = reverse' [0, 1, 2, 3, 4, 5] in
        eqt (res is [5,4,3,2,1,0])
        
let skipElems {eqt} = 
        let skip lst n = 
                    let ps x::xs i | i == n = xs
                                   | else   = ps xs (i + 1)
                        ps _     _          = () 
                    in
                    if ps lst 1 is (list@r) then Some r else None 
        in
        let res = skip [0, 1, 2, 3] 2 in
        eqt <| res is Some [2,3]

let takeElems {eqt} =
        let take lst n =
                    let pt x::xs i | i == n = [x]
                                   | else   = x :: pt xs (i + 1)
                        pt _     _          = [] 
                    in
                    let r = pt lst 1 in
                    if r is [] then None else Some r 
        in
        let res = take [0, 1, 2, 3, 4] 3 in
        eqt <| res is Some [0,1,2]

let lazyList {eq} =
        eq [3,4,5] (filter' (>2) xs)
        where xs = (& [1..5])
           et filter' p [] = []
              filter' p (x::xs) | p x  = x :: filter' p xs
                                | else = filter' p xs

let typeCheck {eqt} =
        let list = [0, 1] in
        eqt (list is ?list)