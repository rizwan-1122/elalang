1. Possibly change syntax for partial application of operators, e.g. instead of (+2) use <+2>.
2. Make type conversion operator (:) extendable (probably through pervasives).==Probably remove this syntax at all.
3. Move all reflection API to the standard library.==Reconsidered. API refactored but will remain the part of Ela core.
4. Think about inability to convert to other than built-in types.
5. Make sequencing operator a function. (Important)==Done

What is a _type system_? This term might seem pretty obvious and commonly used however giving a clear definition to it is not a trivial task. As Pierce mentiones, <it is difficult to define "type system" in a way that covers its informal usage by programming language designers and implementors but is still specific enough to have any bite> (1). Pierce tries to give such a definition anyway and in his interpretation type system is <a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute> (1). It might seem like a pretty wide understand of what a type system is however when Pierce tries to explain he specifically stresses that a type system can be basically regarded as a _static_ approximation of a run-time program behavior. (2) Static here describes a verification performed specifically during compile time. Static, according to Pierce, becomes a crucial property of a type system. As a result, he concludes: <Terms like "dynamically typed" are arguably misnomers and should probably be replaced by "dynamically checked," but the usage is standard.> (2)

Ela is a dynamically types language that (mostly) doesn't perform any type verifications _statically_, in compile time. It seems to render this whole chapter useless - it even has a title that looks like a misnomer for Pierce. But the purpose of this chapter is not to discuss the term usage or to prove that the term "type system" should have a better and broader definition which will including dynamically typed language as well. The purpose of this chapter is to describe something to which I refer using a common term "type system".

But what is a type system anyway? If we agree with the fact that some of the programming languages may simply lack it and still be successful and useful type system becomes a specific property that might even be used to differentiate languages one from another. 

Let's say that type system is a special type of prover - like theorem prover or the guy who tries to convince you that one programming language is more powerful than another. And type system simply proves that our program doesn't contain illegal operation with types.

But even this definition is not too helpful. We have clarified the term type system but clarification itself involves yet another commonly used term (which of course is equally difficult to define) - the term "type". If dynamic typing is truly a misnomer and dynamic languages don't have types than Pierce position about type system becomes crystal clear. Surely type system is a system that has to do with types and the lack of the latter renders type system useless. There is nothing to prove when the whole subject is completely missing.

However as you remember we have used a term type quite frequently so far. Even if the term was simply misused we still were referring to something, we were using the term "type" to call what seemed to us best suited for such a title. Was it a sort of a run-time tag as Pierce suggests? Not exactly. Probably instead of looking for Right Definitions we can start from explaining ourselves - what we actually meant under "type" so far?

Stating that a type in a dynamic language is a tag attached to value is a completely valid in many (if not most) cases. Such tag, a demarkation criteria, is used as a simple descriptor of a value that is acquired by a run-time environment and used to understand how it should deal with the value, what size is has, what's its internal layout, etc. Beign dynamic, Ela surely utilize the same mechanism of tags - without them it won't be possible to distinguish between, for example, 32-bit integers and 64-bit floating point numbers that have different stack behavior and different organization. However this is _not_ what we have called a type.

Type in Ela is a complete and non-conflicting combination of behaviors. What, another term? Behavior? But as soon as we've just invented it there is absolutely no problem to describe what it means exactly. Behavior is what a particular value claims to be. For example it can claim to be a number. Or as a value that can be ordered using comparison operation. Or as something that can be serialized to a string. Instead of tags we have combination of behaviors.

How it is different?

First we can take a look at a weakly typed dynamic language. Let it be JavaScript as one of the most popular and well known. So well known that sometimes it is considered as a representative of the whole kind (and to be honest not a good representative in most cases). In spite of the fact that JavaScript is weakly typed it still should utilize a concept of "types as tags" which is required for a run-time environment to do such things as decoding data from stack or whatever JavaScript does. However these tags are clearly not used for verification. For example, in JavaScript it is possible to multiply strings - it is a valid operation, it won't fail will and produce (in a code sample below) a value NaN. Or you can try to operate with a numeric like it is an array and again nothing will be wrong about that:

var res = "Java" * "Script"; //res is NaN
var i = 0;
var res2 = i[1]; //res2 is undefined

I hope it is clear from these examples that JavaScript doesn't perform any verifications at all. Nobody is trying to understand if your program operates with types correctly or not. And I really doubt that there are any types - what we have instead are containers for values that carry out tags used for value decoding. To summarize - JavaScript doesn't seam like a language with types or type system.

Let's move forward. Let's say that we have a strictly typed dynamic language - not JavaScript alike - that still uses "type as tags" approach. The run-time environment of this language tries to determine if a particular operation is correct by querying these tags. In order to do so run-time environment should poses all knowledge about "types" allowed in specific operations. For example, it knows that you can multiply integers, but you can't multiply strings. You can use indexer operator with arrays but doing so with numbers is not allowed. It seems quite close to what we have in Ela. But it is not exactly the same.

In our imaginative strictly type language all type information is fixed and exposed through a single tag. Of course it doesn't mean that types - or whatever you call them - in such language don't have behaviors. They do. But behaviors are hard coded in the run-time environment. When a run-time have to deal with, for example, an integer value it already knows that integers supports structural equivalence, thay they can be compared, can be resperesented as strings, support arithmentic operations and so on. All this information is built-in to the run-time environment and therefore it is not possible to add a support of a new type - or tag - because this will require rebuild of the whole system. And when it comes to support for some custom data structures there is absolutely no way to define any custom unique combinations of behaviors for them. The only solution that we have here is to utilize a single yet pretty generic type tag - like _object_ - that will be used to mark all custom data structures (if our language even supports any). All these things lead us to a pretty interesting fact. In spite of the fact that at the first glance our strictly typed languages seems so distant from JavaScript and behaves completely different at run-time it still uses this unverifiable non-typed approach as JavaScript does - but simply on a different level.

So far we have only discovered that Pierce's definitions unleash the ugly truth about dynamic typing - it is a misnomer as soon as what we usually do call types in a dynamic language is no more than a tag with a pretty limited purpose. The main question is still unanswered through. How Ela is different here (and is it actually different)?

Ela has an explicit way to describe behaviors. Behaviors can be comined and, as I've mentioned above, a combination of behaviors compiles a unity that is called _type_. The consequences of such design is an ability to implement new types, different in behavior, without the need to make changes to the run-time environment. The advantages of Ela are clear, what is not - is why we dare to speak about type system when all the previously mentioned languages obviously lacks them.

With the help of Pierce we have defined type system as a prover that program doesn't have a bad behavior but in a dynamic language correctness of operation with types is not something that has to be proved - we deal with type information only at run-time when this information is available at its most and all we have to do is simply check the type tag or behavior tag, whatever you call it, and raise a run-time error if our validation fails. In other words it is not even the question if we can add new types with different behaviors or not - in any case no verification is required.

1. Benjamin C. Pierce, Types and Programming Languages, p.1, MIT Press, 2002, ISBN:0262162091
2. Benjamin C. Pierce, Types and Programming Languages, p.2, MIT Press, 2002, ISBN:0262162091