<?xml-stylesheet type="text/xsl" href="Template.xsl"?>
<article title="Pattern Matching">

<section level="1" title="Introduction" />
This article discusses pattern matching in Ela and lists all available patterns.

<section level="1" title="Pattern Matching Constructs" />

<section level="2" title="Match Expression" />
The main language construct for pattern matching is <key>match</key> expression. It has the following syntax:
<code>match expr with
      pat [ | guard ] = expr</code>
Match expression can have one or more match entries. A match entry consists of a pattern, an optional boolean guard and expression that is evaluated if an entry is successfully matched.
Here is an example of a simple match expression:
<code>match [1,2,3] with
      x::[] = Some x
      x::xs = Some xs
      []    = None</code>
All match entries should be indented after the <key>match</key> keyword. The order of pattern is significant as soon as patterns are always processed in order. For example if we change
the order of patterns in the example above like so:
<code>match [1,2,3] with
      x::xs = Some xs
      x::[] = Some x
      []    = None</code>
the second pattern <key>x::[]</key> would be unreachable because pattern <key>x::xs</key> is more generic and is tested earlier. In other words a pattern <key>x::xs</key> would work for
a list with single element and for multiple element list when pattern <key>x::[]</key> would only match agains a single element list.
<br/>
Luckily Ela validates match expressions and warns if the order of patterns is incorrect. If you try to compile the above code you will receive the following warning:
<br/>
<key>Warning ELA403: Match entry 'x::[]' is not reachable because it is overlapped by a preceding entry 'x::xs'.
<br/>
Hint ELA502: Consider reordering match entries. Less specific patterns should be moved after more specific patterns.</key>
<br/>
You can also use guards in match entries in the same manner as in bindings. Here is an example of a guarded match entry:
<code>match [1,2,3] with
      x::[] | x > 0 = Some x
            | else  = None
      x::xs = Some xs</code>
Also it is possible to use <key>where</key> bindings to declare names that are scoped to a particular match entry:
<code>match [1,2,3] with
      x::[] | gtz  = Some x
            | else = None
            where gtz = x > 0
      x::xs = Some xs</code>
If none of the patterns match than a <key>MatchFailed</key> exception is raised. This exception can be handled in Ela code, however if you wish to prevent generation of this exception
you can add a so called "default" to clause to a match entry.
<br/>For example, the match expression above is non-exhaustive - it will fail for an empty list. Adding a default clause like so:
<code>match [1,2,3] with
      x::[] | gtz  = Some x
            | else = None
            where gtz = x > 0
      x::xs = Some xs
      _     = Error</code>
will prevent generation of an exception. 
<br/>Default clause should be always the very last entry as soon as it matches any value. Usually a wildcard (<key>_</key>) pattern is used in default clause. This pattern matches
any value and disregards this value. However if you need the value you can a variable pattern instead (it will also match with any value and additionally bind a variable to this
value).
      
<section level="2" title="Is Expression"/>
Expression <key>is</key> represents a lightweight version of a <key>match</key> expression. It is useful if you want to compare a value with a single pattern. For example:
<code>[1,2,3] is (x::xs)</code>
Another peculiarity of <key>is</key> expression is that it doesn't generate an exception if a match fails, instead it returns a boolean value - <key>true</key> if a match was
a success, otherwise - <key>false</key>.
<br/>All bindings done with <key>is</key> expression are in a private scope. If you write <key>is</key> expression at top level, bindings are not lifted to global scope. If you
want to use names bound by <key>is</key> expression in your code, you can embed it in an <key>if</key> expression like so:
<code>if [1,2,3] is (x::xs) then 
  do_something xs 
else 
  do_something_else ()</code>
However it is probably better to use other pattern matching constructs in such cases.

<section level="2" title="Binding Patterns"/>
You can also use pattern matching in <key>let</key> and <key>where</key> bindings. Basically these bindings are always defined using pattern matching with variable pattern as
a trivial case:
<code>let xs = [1..10]</code>
It is possible however to use any patterns and guards in bindings as well:
<code>let (x::xs) = [1..10]
let (Some x) = Some 42</code>

<section level="2" title="Functions"/>
One can use pattern matching in function declarations - in the argument list like so:
<code>let tail (x::xs) = xs</code>
In such a case patterns are separated by spaces and one pattern matches exactly one argument. When matching inside an argument list head/tail pattern and variant pattern should
be always enclosed in parens.

<section level="2" title="Exception Handling"/>
A construct used for exception handling - <key>try/with</key> expression - has effectively the same syntax as <key>match</key> expression with <key>try</key> keyword instead of
<key>match</key>. The major difference is that it doesn't match a given expression but executes it and if (and only if) this expression fails matches an exception object.

<section level="1" title="Patterns"/>
All patterns can be divided in two groups - irrefutable patterns that always match (such as variable pattern that always does the binding even if the value is unit) and refutable
patterns that may not match. Patterns can be nested at any level.
<br/>Ela supports the following patterns:
<table>
  <tr>
    <th>Pattern</th>
    <th>Grammar</th>
    <th>Example</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Name</td>
    <td>ident</td>
    <td>x</td>
    <td>Irrefutable pattern, binds a value to a name.</td>
  </tr>
  <tr>
    <td>As</td>
    <td>pattern@name</td>
    <td>(x::xs)@list</td>
    <td>Irrefutable pattern, binds an expression to a name.</td>
  </tr>
  <tr>
    <td>Wildcard</td>
    <td>_</td>
    <td>_</td>
    <td>Irrefutable pattern, always matches and disregards a value.</td>
  </tr>
  <tr>
    <td>Group</td>
    <td>( pattern )</td>
    <td>(x::xs)</td>
    <td>Grouping pattern, used to group patterns.</td>
  </tr>  
  <tr>
    <td>Unit</td>
    <td>()</td>
    <td>()</td>
    <td>Refutable pattern, matches unit.</td>
  </tr>
  <tr>
    <td>Literal</td>
    <td>literal</td>
    <td>"string"</td>
    <td>Refutable pattern, matches a given literal. Numeric literal, string, chars and booleans are supported.</td>
  </tr>
  <tr>
    <td>Tuple</td>
    <td>(pattern{,pattern})</td>
    <td>(x,1,(x::xs))</td>
    <td>Refutable pattern, matches tuple.</td>
  </tr>  
  <tr>
    <td>Record</td>
    <td>{pattern{,pattern}}</td>
    <td>{x,y,z} or {x'=x,y=y'}</td>
    <td>Refutable pattern, matches a record and binds its fields to names. If names are not specified it creates bindings with tde same names as record fields.</td>
  </tr>  
  <tr>
    <td>List</td>
    <td>[pattern{,pattern}]</td>
    <td>[1,2,x]</td>
    <td>Refutable pattern, matches a linked list of a specified lengtd.</td>
  </tr>
  <tr>
    <td>Head/Tail</td>
    <td>pattern{::pattern}</td>
    <td>x::(1,2)::xs</td>
    <td>Refutable pattern, matches a linked list. Unlike list pattern, it doesn't test a list length and if the last pattern is a name this name gets bound a list tail.</td>
  </tr>  
  <tr>
    <td>Variant</td>
    <td>Tag pattern</td>
    <td>Some x</td>
    <td>Refutable pattern, matches a variant.</td>
  </tr> 
  <tr>
    <td>Type Check</td>
    <td>?typename</td>
    <td>?unit</td>
    <td>Refutable pattern, matches if a type of an expression equals to tde specified type.</td>
  </tr>
</table>
</article>