#file prelude.ela
#title prelude
#category Ela Standard Library
Prelude module is an initialization script that contains definitions of standard types, classes, 
instances, basic combinators and operators. Prelude script is always executed before any Ela 
program unless you explicitly tell Ela not to do so. 

#members

Int
>>42
A 32-bit signed integer number type.

Long
>>42L
A 64-bit singed integer number type.

Single
>>12.2
A 32-bit singed floating point number type.

Double
>>24.4
A 64-bit singed floating point number type.

Bool
>>true false
A boolean type which can be created using two literal forms - `true` or `false`.

Char
>>'a'
A single unicode character.

String
>>"Hello, world!"
An immutable indexed array of unicode characters.

List
>>[1,2,3,4,5]
An immutable single linked list.

Tuple
>>(1, 'c', "Hello", true)
An immutable indexed array of elements of any type.

Record
>>{x = 1, foo = "Foo"}
A tuple with named elements.

Module
Used to represent an Ela module.

Unit
>>()
This type has a single immutable instance and is used to represent a value that can be discarded.

Fun
>>\x -> \y -> x + y
A function.

Object
An object type.

StringBuilder
This type implements an immutable string builder that can be used for string concatenation instead of
`++` operator (which might cause severe performance degradation on long strings).//br
As long this type is immutable, its instance can be created by simply referencing a `stringBuilder`
constant. In order to append a string one can use a `+>` operator which is left associative:
>>>stringBuilder +> "First" +> "Second"
This operator always returns a new instance of `StringBuilder`. In order to convert a string builder
to a string, one can use a standard `toString` method.

Eq
Defines two basic comparison functions - equal `==` and not equal `<>`. Implementation of equality 
functions is fully dependent from a particular instance however normally these functions would 
test for structural, not reference equality.
>>>[1,2,3] == [1,2,3]

Ord
Defines four comparison functions including: greater `>`, lesser `<`, greater or equal `>=` and 
lesser or equal `<=`.

Additive
Defines functions of a commutative group, including addition `+`, subtraction `-` and negation
`--`.
>>>2 + 2
This is the most basic class for all numeric types. Also other types, such as `Char` and `Tuple`
may provide implementations for this class as well.

Ring
Defines functions of a (not necessarily commutative) ring, including multiplication `*` and
power `**`.

Field
Defines a function from a commutative division ring. Instances of this class should implement
real division. That is the reason, why instances of `Field` are not provided for the integral 
data types.

Modulo
Defines a modulus function (`mod`) and a remainder function (`rem).

Bit
Defines bit manipulation functions including: bitwise AND `&&&`, bitwise OR `|||`, bitwise 
XOR `^^^`, bitwise negation `~~~`, left shift `<<<` and right shift `>>>`.

Enum
This class defines operations on sequentially ordered types.//br
Functions `succ` and `pred` can be used to obtain a successor and a predecessor 
of a given value. An implementation of `Enum` for integers has the same effect as addition 
and subtraction:
>>>succ 12 == 12 + 1
When you implement these functions for your own data type, the following equation should
hold:
>>x = succ (pred x)
This is not the case for floating point numbers - and that is the reason, why they don't
provide instances for `Enum` class.//br
Functions `enumFrom` and `enumFromTo` are used to generate ranges. A range in the form
`[n,n'..]` is only a syntax sugar for `enumFrom n n'`, and a range in the form `[n,n'..m]`
is a syntax sugar for `enumFromTo m n n'`. An implementation of `enumFrom` should always
generate a lazy infinite list, and implementation of `enumFromTo` should generate a strict
finite list.//br
When a second element in the range is not specified, it is calculated automatically using 
`succ` function, e.g. a range in the form `[1..10]` is equivalent to `enumFromTo 10 (succ 1) 1`.//br
The names of functions `succ`, `enumFrom` and `enumFromTo` are significant as their applications
are directly generated by Ela compiler. Do not change the names of these functions if you alter
prelude.

Seq
Defines three functions that can be used to deconstruct a given sequence as a linked list. 
A function `head` returns a head element of a sequence, a function `tail` strips a head and 
returns the rest part of a sequence and a function `isNil` tests if a given sequence is nil.
>>>tail [1,2,3]
If an instance of this class is implemented for a particular type, than it is possible to 
deconstruct this type using head/tail pattern, e.g.:
>>match xs with
>>      x::xs = ...
>>      [] = ...

Len
Defines a function `length` that can be implemented by objects for which there is a notion
of measurable length. An example of such object is a linked list or tuple:
>>>length (1,2,3)

Ix
Defines a function `getValue` that maps a given index to a value. This class should be 
implemented by containers which have a strict order of elements, such as lists or tuples.
>>>getValue 1 [1,2,3]
Instance of this class (along with an instance of `Len` class) allows to pattern match a
value using tuple pattern, e.g.:
>>match tup with
>>      (x,y,z) = ...

Name
This class provides an abstraction for a container which elements can be accessed by name.
A function `getField` maps a given name to a value, and a function `isField` checks if a
given name is recognized by a container. A typical example of a container that implements
such an abstraction is a record.
>>>getField "y" {x=1,y=2,z=3}
Instance of this class allows to pattern match a value using record pattern, e.g.:
>>match rec with
>>      {x=xx,y=yy} = ...

Cat
An operator `++` concatenates two entities and produces a new entity that includes elements from 
both entities:
>>>"First" ++ "Second"

Show
A function `showf` formats a given value to a string:
>>>showf "" [1,2,3]
A format string can be used to specify a format if this format is supported by a particular 
implementation of `showf`:
>>>showf ".##" 12.1234

Bounded
This class defines two functions `maxBound` and `minBound` that accept an argument and return a
maximum and a minimum possible value for this argument.
>>>maxBound 0F

ListLike
Defines a `toList` function that can be used to convert list like data structures to a 
linked list.

IntLike
Defines a `toInt` type cast function.

LongLike
Defines a `toLong` type cast function.

SingleLike
Defines a `toSingle` type cast function.

DoubleLike
Defines a `toDouble` type cast function.

BoolLike
Defines a `toBool` type cast function.

CharLike
Defines a `toChar` type cast function.

StringLike
Defines a `toString` type cast function.

TupleLike
Defines a `toTuple` type cast function.

RecordLike
Defines a `toRecord` type cast function.

RecordLike Record
This instance is provided so that `toRecord` applied to a `Record` would be equivalent to an identity
function.

TupleLike Tuple
This instance is provided so that `toTuple` applied to a `Tuple` would be equivalent to an identity
function.

ListLike List
This instance is provided so that `toList` applied to a `List` would be equivalent to an identity
function.

IntLike Int
This instance is provided so that `toInt` applied to an `Int` would be equivalent to an identity
function.

IntLike Long
Implements a type cast of a 64-bit integer to a 32-bit integer.

IntLike Single
Implements a type cast of a 32-bit float to a 32-bit integer.

IntLike Double
Implements a type cast of a 64-bit float to a 32-bit integer.

IntLike Bool
Implements a type cast of a boolean to a 32-bit integer.

IntLike Char
Implements a type cast of a unicode character to a 32-bit integer.

LongLike Long
This instance is provided so that `toLong` applied to a `Long` would be equivalent to an identity
function.

LongLike Int
Implements a type cast of a 32-bit integer to a 64-bit integer.

LongLike Single
Implements a type cast of a 32-bit float to a 64-bit integer.

LongLike Double
Implements a type cast of a 64-bit float to a 64-bit integer.

LongLike Bool
Implements a type cast of a boolean to a 64-bit integer.

LongLike Char
Implements a type cast of a unicode character to a 64-bit integer.

SingleLike Single
This instance is provided so that `toSingle` applied to a `Single` would be equivalent to an identity
function.

SingleLike Int
Implements a type cast of a 32-bit integer to a 32-bit float.

SingleLike Long
Implements a type cast of a 64-bit integer to a 32-bit float.

SingleLike Double
Implements a type cast of a 64-bit float to a 32-bit float.

DoubleLike Double
This instance is provided so that `toDouble` applied to a `Double` would be equivalent to an identity
function.

DoubleLike Int
Implements a type cast of a 32-bit integer to a 64-bit float.

DoubleLike Long
Implements a type cast of a 64-bit integer to a 64-bit float.

DoubleLike Single
Implements a type cast of a 32-bit float to a 64-bit float.

BoolLike Bool
This instance is provided so that `toBool` applied to a `Bool` would be equivalent to an identity
function.

BoolLike Int
Implements a type cast of a 32-bit integer to a boolean.

BoolLike Long
Implements a type cast of a 64-bit integer to a boolean.

CharLike Char
This instance is provided so that `toChar` applied to a `Char` would be equivalent to an identity
function.

CharLike Int
Implements a type cast of a 32-bit integer to a unicode character.

StringLike String
This instance is provided so that `toString` applied to a `String` would be equivalent to an identity
function.

StringLike Char
Implements a type cast of a unicode character to a string.

StringLike StringBuilder
Converts an instance of a type `StringBuilder` to a string.

Eq Tuple
Implements equality functions for a tuple.

Eq Record
Implements equality functions for a record.

Eq List
Implements equality functions for a linked list.

Ord Tuple
Implements comparison functions for a tuple type.

Seq String
Implements functions `head`, `tail` and `isnil` for a string. This instance is automatically 
generated by a compiler. Applying a `head` to a string is equivalent to a substring that eliminates 
the first character:
>>>tail "Bar"
A function `head` always returns a first character:
>>>head "Bar"
A empty string is considered to be a nil string:
>>>isnil ""

Ix Tuple
Implements an indexing and a `length` function for a tuple. Tuple only supports indices of integer 
type. This instance is automatically generated by a compiler.

Ix String
Implements an indexing and a `length` function for a string. String only supports indices of 
integer type. This instance is automatically generated by a compiler.

Ix Module
Implements an indexing and a `length` function for a module. Module only supports indices of 
string type. This instance is automatically generated by a compiler.

Ix Record
Implements an indexing and a `length` function for a module. Record supports indices of type string 
and integer. This instance is automatically generated by a compiler.

Ix List
Implements an indexing and a `length` function for a linked list. The complexity of both `item` and 
`length` functions is O(n) is most of situations. Both `item` and `length` have to traverse a list. 
A `length` function always has to traverse the whole list. Traversing obviously forces calculation 
of a lazy list and trying to obtain a length of an infinite list would never terminate. However, 
both `item` and `length` never force calculation of list elements.

Cat Char
Implements concatenation for two characters. The result of such concatenation is always a string:
>>>'a' ++ 'b'
This instance is automatically generated by a compiler.

Cat Tuple
Implements concatenation for two tuples. The result is a new tuple that contains elements from 
both tuples:
>>>(1,2) ++ (3,4)
This instance is automatically generated by a compiler.

Cat Record
Implements concatenation for two records. The result is a new record that contains elements from 
both records:
>>>{x=1,y=2} ++ {name="Bar"}
This instance is automatically generated by a compiler.

Cat List
Implements concatenation for two linked lists. This is an expensive operation that requires its 
left operand to be traversed twice.
>>>[1,2] ++ [3,4]
A function `++` for linked lists is lazy on its right operand. If a right operand is a thunk than 
a lazy list is created.

Show Tuple
Implements `showf` function for a tuple.

Show List
Implements `showf` function for a list.

Show Record
Implements `showf` function for a variant.

Show StringBuilder
Implements `showf` function for a string builder.

Bounded Int
Provides an implementation of `Bounded` class for 32-bit integers.

Bounded Long
Provides an implementation of `Bounded` class for 64-bit integers.

Bounded Single
Provides an implementation of `Bounded` class for 32-bit floats.

Bounded Double
Provides an implementation of `Bounded` class for 64-bit floats.

stringBuilder
This constant returns an empty string builder (see description of a `StringBuilder` type).

+> sb str
This function is used in conjunction with `StringBuilder` type. It allows to append strings to a given
string builder. This function is pure and always returns a new instance of `StringBuilder`. It is
left associative:
>>>toString <| stringBuilder +> "1" +> "2"

:: e xs
List construction operator. This operator is right associative. In order to construct a list a 
rightmost part of an expression should always be a list. 
>>>1 :: 2 :: []
This function is lazy on its both arguments. It doesn't force a left argument and if a right 
argument is a thunk than a lazy list is constructed.

% x y
An alias for a remainder (`rem`) function from `Modulo` class:
>>>12.2 % 3.0

: x y
Provides a version of `getValue` function from `Ix` class that accepts arguments in a reverse order:
>>>[1,2,3] : 2

show x
Implements a helper function defined like `showf ""` that can be used when a format string is 
not needed.

not b
Performs a logical negation of its operand. 
>>>not (12 > 3)

>>
Forward function composition operator. This function is defined like so:
>>(>>) f g x = g (f x)

<<
Backward function composition operator. This function is defined like so:
>>(<<) f g x = f (g x)

flip fn
Flips first two arguments in a function. A trivial implementation of this function is defined 
like so:
>>flip f x y = f y x

curry
Converts an uncurried function to a curried function. It works with functions for two arguments:
>>>curry fst 2 3

uncurry
Converts an curried function to a uncurried function. It works with functions for two arguments: 
>>>uncurry (%) (5,4)

curry3
Converts an uncurried function to a curried function. It works with functions for three arguments: 
>>>curry3 fst3 1 2 3

uncurry3
Converts an curried function to a uncurried function. It works with functions for three arguments: 
>>>uncurry3 (\x y z -> x + y + z) (5,4,3)

=>
Constructs a pair:
>>>12 => 24

swap x
Swaps first and second elements in a tuple. This function will only work with a tuple of two 
elements: 
>>>swap (1,2)

swap3 x
Swaps first and second elements in a tuple. This function will only work with a tuple of element 
elements: 
>>>swap3 (1,2,3)

fst x
Returns a first element in a tuple. This function will only work with a tuple of two elements: 
>>>fst (1,2)

snd x
Returns a second element in a tuple. This function will only work with a tuple of two elements: 
>>>snd (1,2)

fst3 x
Returns a first element in a tuple. This function will only work with a tuple of three elements: 
>>>fst3 (1,2,3)

snd3 x
Returns a second element in a tuple. This function will only work with a tuple of three elements: 
>>>snd3 (1,2,3)

getType x
Returns type information for a given value:
>>>getType 42
This function is generated by a compiler.

force x
Forces a given expression if this is a thunk. Otherwise works as an identity function:
>>>force 42
This function forces thunks recursively. This function is generated by a compiler.

tag x
When applied to a constructor of an algebraic type, returns a name of this constructor as
a string:
>>>type void = Void
>>>tag Void

untag x
Deconstructs a given value which is considered to be a product of an algebraic type. This
function returns all arguments of a constructor, packed in a tuple. 
>>>type foobar a b = Foo a b | Bar
>>>untag (Foo 12 "string")
If a constructor doesn't have parameters, this function returns unit:
>>>untag Bar == ()
This function (along with `tag`) is important if you want to write generic logic that can
deal with algebraic types. For example, using `untag` and `tag` functions one can define
a generic `show` function that can format any given algebraic type to a string.

id
An identity function (I combinator from SKI calculus): 
>>>id 42

const
Constant function (K combinator from SKI calculus). 

sub
Substitution function (S combinator from SKI calculus).

fix
Fix point combinator: 
>>factabs fact 0 = 1
>>factabs fact x = x * fact (x - 1)
>>res = (fix factabs) 5

on
A combinator that applies a function given as its first argument to result of application of a 
second argument to a third 
and of a second argument to a forth argument: 
>>(*) `on` f = \x y -> f x * f y

until
Function application like so: `until p f` yields the result of applying `f` until `p` holds: 
>>until (<0) (-1) 10

! f
An application operator. It is defined like so:
>>f! = f()

|> e f
A redundant low priority application operator also known as _forward pipe_. It has a normal 
order and left association. This function implementation is generated by a compiler.

<| f x
A redundant low priority application operator also known as _backward pipe_. This operator is 
right associative and has applicative order. This function application is generated by a compiler.

even
Returns `true` if the specified number is even, otherwise returns `false`. 

odd
Returns `true` if the specified number is odd, otherwise returns `false`. 

