<?xml-stylesheet type="text/xsl" href="Template.xsl"?>
<article title="Thunks">

  <section level="1" title="Introduction" />
  This article discusses a thunks and writing non-strict code in Ela.
  
  <section level="1" title="Lazy Evaluation" />
Ela by default is a strict language (like for example C#) but it does provide an extensive support for lazy evaluation. However unlike languages like Haskell lazy evaluation in Ela
is always explicit - one should mark a particular section of code as <i>thunk</i> to enable laziness.
<br/>
This is done using built-in syntax like so:
<code>let x = (&amp; 2+2)</code>
An evaluation of expression enclosed in parenthesis with ampersand is deferred. Also such an expression is evaluated just once (and after that its value is memoized).
<br/>
An expression which evaluation is deferred is called <i>thunk</i>. Thunks are calculated only when their value is actually needed. For example standard prelude operator <key>+</key>
(additional) is strict - therefore if you apply this operator to a thunk a thunk will be immediately evaluated. 
<br/>
However one can write a function with a non-strict semantics. For example a simple tuple construction function defined like so:
<code>let x => y = (x,y)</code>
is non-strict as soon as it doesn't evaluate its arguments. If you pass thunks to this function you will get a tuple with thunks. 
<br/>
<section level="1" title="Lazy Lists" />
Some standard prelude functions are also non-strict. For example, list construction function (<key>::</key>) is non-strict. It doesn't evaluate the tail of a list. If you pass a thunk as
a list tail it will construct a lazy list:
<code>let xs = 1::2::[] //strict list
let xs' = 1::(&amp; 2::[]) //lazy list</code>
The same for concatenation operator <key>++</key>. When used with lists it can construct lazy lists as well as strict lists.
<br/>
A lazy list in the example above is not very useful, however one can easily writen a function that generates an infinite list like so:
<code>open Core
let inf x = x :: (&amp; inf &lt;| x+1)
take 10 &lt;| inf 0
</code>
A function <key>take</key> is defined in <key>Core</key> module and takes first 10 elements from a list. A lazy list is evaluated on demand only. 
In example above we have taken first 10 elements from this list - only ten elements are evaluated.
<br/>
One can define other lazy functions in a similar manner. For example this how a lazy <key>map</key> function 
(which takes a function and a list and maps this functions to the elements of a list) can be defined:
<code>let map _ [] = []
    map f (x::xs) = f x :: (&amp; map f xs)
</code>
And now we can safely map our infinite list using this function:
<code>let xs = map (*2) (inf 0)
take 10 &lt;| xs</code>
The code above evaluates to: <key>[0,2,4,6,8,10,12,14,16,18]</key>.


  <section level="1" title="Forcing Evaluation" />
One can force an evaluation of a thunk using prelude <key>force</key> function like so:
<code>let t = (&amp; 2+2)
force t</code>
Also thunks are automatically forced when used in sequence expressions (created using built-in <key>$</key> operator).
</article>