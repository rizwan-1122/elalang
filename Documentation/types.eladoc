#title User Types
#category Language Reference

=Introduction
Ela provides a support for user defined types. The only way to declare a new type is to use a `type` declaration. 
It has the following syntax:
>>"type" ident "=" Cons { "arg" } { "|" Cons }
Here is a simple example of a type definition:
>>type Maybe = Some a | None
All user types in Ela are in fact algebraic types. It is possible, however, to declare a type with just a single
product:
>>type Any = Any a
Constructors in type declarations are separated by a semicolon character. A type can have an unlimited number of 
constructors. Each constructor can an unlimited number of parameters (however, parameters are not required, as you can
see from a definition of `Maybe` type above).//br
Type names in Ela should always start with a capital letter. The same for constructors. A name of a constructor can have
the same name as an enclosing type. Ela also supports infix, postfix and prefix constructors:
>>type Complex = a :+ a
All types in Ela are open. It is possible to extend an already defined type with new constructors using `data`
declaration.

=Type Constructors
A type declaration should have at least one type constructor. A type constructor can have optional parameters:
>>>type foobar
>>>  where foo x = Foo x
>>>        bar x = Bar x
>>>        empty = Empty
In the code sample above we have created a custom type `foobar` that has two constructor functions (`foo` and `bar`) 
and a constant `empty`. All these constructors are in fact global bindings and are exported in the same way as all 
other bindings. You can also specify attributes for these bindings like so:
>>type foobar
>>  where foo x = Foo x
>>        bar x = Bar x
>>        empty # qualified
>>        empty = Empty
Now, with this declaration in place, we can create an instance of `foobar` type:
>>>x = foo 12
>>>show x
By default a type name and a unique type code are used when presenting a instance of user type as string. This can be 
overrided however by implementing an instance for a `Show` class (see _Classes_ article for details).

=Deconstruction
Types are constructed using constructor functions. In order to deconstruct a type instance, one can use pattern 
matching:
>>>fooInst = foo 42
>>>(Foo xx) = fooInst
>>>xx

=Name Conflicts
Type names should be unique within the same module. However two different modules can define types with the same name 
and this is completely legal. In fact types in Ela are not identified by their names but by their unique IDs which are 
generated during link phase. As a result one can easily declare a type that has the same name as one of Ela built-in types:
>>type int
>>  where void _ = ()
Constructors for types are just regular Ela bindings, therefore shadowing rules for them are exactly the same as for other 
bindings, e.g. if you open a module with a `foobar` type defined above and write a local definition of `foo` function, 
this definition will effectively shadow a `foo` constructor. You can however still use a `foo` constructor by qualifying it 
with a module alias like so:
>>open foobarModule@fb
>>fb.foo 12

=Reflection
In order to obtain type information from a given value one can use a `getType` function defined in prelude:
>>>getType (foo 12)
This function returns an instance of `typeinfo`, that contains two fields - `typeName` with the name of a type and `typeCode` 
with unique type code.//br
It is also possible to check a type of a value using pattern matching like so:
>>(x is foobar) = bar 42
As long as type names are not unique it is allowed to use module aliases in such patterns, e.g.:
>>open foobarModule@fb
>>(x is fb.foobar) = bar42


