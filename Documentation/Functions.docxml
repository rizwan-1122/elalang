<?xml-stylesheet type="text/xsl" href="Template.xsl"?>
<article title="Functions">

  <section level="1" title="Introduction" />
  This article discusses function declaration in Ela.
  
<section level="1" title="Declaration" />
Functions in Ela are first class values and are declared using regular binding syntax like so:
<code>let sum x y = x+y</code>
Functions are curried therefore the declaration above is equivalent to the following declaration:
<code>let sum x = sum'
            where sum' y = x+y</code>
Ela also supports anonymous functions syntax. The function above can be also written like so:
<code>let sum = \x y -> x+y</code>
or like so (taking into account that the function is curried):
<code>let sum = \x -> \y -> x+y</code>
Functions in Ela can be declared using both <key>let</key> and <key>where</key> bindings.

<section level="1" title="Operators" />
Strictly speaking Ela doesn't have a concept of operators. Instead it recognizes two types of idenfiers for functions - a regular type (which is a standard Ela identifier)
which is used for functions called in prefix notation by default and a symbolic idenfier which is used by default in infix (or postfix) notations. 
Therefore declaration of operators is effectively the same as declaration of functions:
<code>let (+.) x y = x+y</code>
This function is basically equivalent to the <key>sum</key> function shown in the begging of the previous section. The only difference is that by default
it is applied using infix notation:
<code>x +. y</code>

<section level="1" title="Application Notation" />
"By default" means that prefix, postfix and infix notations are possible for any functions in Ela. For example operators can be applied using prefix notation:
<code>(+) 2 2</code>
And even postfix notation:
<code>2+</code>
The latter code partially applies an operator <key>+</key>. However for unary operators it will result in saturation.
<br/>Functions also can be called using infix and postfix notations:
<code>2 `sum` 2</code>
or even
<code>2 `sum`</code>
which has effectively the same effect as a right section for <key>+</key> shown above.
<br/>
You can also declare functions and operators using all these notations:
<code>let sum x y = x+y //Prefix
let x +. y = x+y //Infix
let x+++ = x+x //Postfix</code>

<section level="1" title="Pattern Matching"/>
Functions in Ela can be defined using pattern matching. In such a case a function will have a separate body for each of the match entries. A typical example is a
known <key>map</key> function:
<code>let map _ [] = []
    map f (x::xs) = f x :: map f xs</code>
Here we have a function for two arguments that accepts a function (as a first argument) and a list (as a second argument). A list is deconstructed using head/tail pattern.
<br/>
One can also use guards in functions (in the same manner as in bindings):
<code>let filter _ [] = []
    filter p (x::xs) | p x  = x :: filter p xs
                     | else = filter p xs</code>

<section level="1" title="Extensible Functions"/>
One function can extend another function by adding additional match clauses. Such a function can be declared using <key>extends</key> attribute. For example, this how
one can extend a standard prelude <key>+</key> function:
<code>let extends (Box x) + (Box y) = x+y</code>
Without <key>extends</key> attribute it will simply shadow an existing declaration.
<br/>Now application in a form: <key>Box 2 + Box 2</key> would evaluate to <key>4</key> as well as <key>2+2</key>.
<br/>Functions marked with <key>extends</key> attribute are evaluated in order - starting from the function that was declared last. Also it is important to understand that
such a declaration doesn't mutate anything - it simply creates a new binding that includes a body of previously defined function.

</article>