#title Classes
#category Language Reference

=Introduction
A concept of _classes_ in Ela is similar to the concept of _typeclasses_ in Haskell.//br
A _class_ in Ela is a class of operations and can be seen as an abstraction over types. Without types a particular operation 
(such as `x + y`) would have a meaning only for specific type (e.g. integer) and any code that uses such an operation wouldn't
be polymorphic. However in Ela a function `+` is defined in a `Num` class which can be implemented for any type therefore code 
like `x + y` can work fine with types that are even unknown to the person who is writing this code.//br
Classes in Ela can be compared with interfaces in object oriented languages (such as C#) as they do share with interfaces a
number of peculiarities. A class (as well as an interface) doesn't provide an implementation of its members. Also a type can
provide instances for several classes. However unlike object oriented language where you have to implement all interfaces at
the point where you define your type and you cannot implement interfaces for the types that are already defined, declaration of
a type and declaration of a class instance shouldn't be done at the same time. For example, you can write instances for built-in
Ela types.//br
Another important difference is that unlike interfaces classes are used to define a _global_ bindings. A class member in Ela is 
effectively a global function that is not different from other functions - it is curried and is a first class value:
>>>class Foo a
>>>  where foo _->a
>>>foo
Dispatch rules are also different. Ela provides a support for only single parameter classes however there is no need for this
parameter to be first a class function. In the example above we have defined a function `foo` that accepts any value as its 
first parameter. Now we can define an instance of this class like so:
>>>instance Foo int
>>>  where foo _ a = Foo a
Here we effectively ignore the first parameter of a `foo` function which is overloaded only by its second argument:
>>>foo "some value" 42
Through a class member signature it is possible to provide any overload rules you want. For example, if we define a class `Foo`
like so:
>>class Foo a
>>  where foo a->a
Our application of `foo` to string and integer would fail.

=Classes
A class in Ela is declared using `class` declaration that has the following syntax:
>>"class" className param
>>  "where" (ident|operator) signature
>>         {(ident|operator) signature}
A name of a class can be a valid Ela identifier. It can also start with a capital letter (like variants). It is recommended to use
uppercased names for classes and all standard Ela classes have uppercased names.//br
A `where` clause is used to specify members for a class. A class should have at least one members. Also all these members should
be function bindings (and are treated like that by Ela compiler).//br
As it was mentioned in introduction class members are just ordinary global bindings and comply to the rules of bindings in Ela. Such as
the head symbol can be either a valid Ela identifier or an operator symbol. You can also define class members using prefix, postfix and
infix form. However definition of class members by pattern matching is not allowed.//br
A `param` clause should be a valid Ela identifier. It is used for substitution in the function signatures. Any valid identifier can be 
used here however normally `a` is used in this clause to denote a type parameter.
A `singnature` clause represents a required class member signature. This signature is used to specify overloading rules for a function.
It has the following syntax:
>(_|param) { "->" (_|param) }
A underscore character denotes "any" value when a param should be the same identifier as in `param` clause. As long as class in Ela is
instanced for one specific type a `param` entry is used to specify occurences of this type in a function signature.//br
A signature should define at least one argument. Also a function signature should have at least one occurence of `param` entry (multiple
occurences are OK as well). Therefore a signature `a` is valid, as well as `_->a` and `a->_->a`, but a signature `_` is not valid and a
signature `_->_` is not valid as well. A signature `a` means a function with _at_ _least_ _one_ _argument_ which first argument is of our
target type, a signature `_->a` means a function with _at_ _least_ _two_ _arguments_ where the second argument is of our target type and
a signature `a->_->a` means a function with _at_ _least_ _three_ _arguments_ where the first and the last arguments are of our target type.//br
Here is an example of a custom class declaration:
>>>class Car a
>>>  where drive _->a
Here we define a `Car` class with two functions. A `drive` function expects a target type as its second argument.

=Instances
Instances are used to implement a class for a particular type. An instance declaration has the following syntax:
>>"instance" className typeName
>>  "where" binding
>>         {binding}
A name of an instance is composed of a class name and a type name. A `where` clause is used to specify implementations of class functions. This
clause should contain regular Ela bindings (except of bindings defined by pattern matching which are not allowed). Also Ela compiler controls
that an instance provides implementations for all functions of a class. If this is not the case than a compile time error is generated.//br
Let's define an instance for a class `Car` from a previous section. //br
A `Car` class defines a `drive` function that can be used to accellerate our car to a specific speed. However all cars have certain speed limits
and if a limit is reach than this function would return a `SpeedLimit` variant.//br
Taking that we can first write a "test drive" function for a car like so://br
>>>testDrive n car = 
>>>   match drive n car with
>>>         Speed x = x :: testDrive (n+1) car
>>>         SpeedLimit = []
This function pushes a given car to its limits and generates a list with our accelleration history - up to the moment when a speed limit is reached.//br
Now we can define a custom type `steamCar` which cannot go faster than 10 miles an hour:
>>>type steamCar
>>>  where steamCar = ()
And here is an instance for this type:
>>>instance Car steamCar
>>>  where drive s _ | s < 10 = Speed s
>>>                  | else = SpeedLimit
Now we can test drive our new car like so:
>>>testDrive 0 steamCar
However ten miles an hour is not really fast so we might wish to implement a better (faster) car like so:
>>>type electroCar
>>>  where electroCar = ()
>>>
>>>instance Car electroCar
>>>  where drive s _ | s < 15 = Speed s
>>>                  | else = SpeedLimit
And test drive as we did before:
>>>testDrive 0 electroCar
Instances can be defined for user types and for built-in Ela types as well. However it is an error to have two instances of the same class for the same
type - even in different modules.

=Name Conflicts
As with custom types class names are not unique. It is not allowed to define two classes of the same name in a single module - however they can coexist in
two different modules. Because of that it is allowed to prefix a class name with a module alias:
>>open cars //We have cars implementations in this module
>>open carClass //We have a Car class in this module
>>
>>instance carClass.Car cars.steamCar
>>  where drive _ s = ...

=Reflection
It is possible to query which instances are supported by a given value using special pattern like so:
>>match value with
>>      x is (Eq Num Car) = ...
Class names can be prefixed with module aliases inside this pattern as well.

