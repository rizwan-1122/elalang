/* 
    Ela standard prelude module
    Created in 2011-2012 by Basil Voronkov
*/

/* Built-in types */
type int
type long
type single
type double
type bool
type char
type string
type tuple
type list
type record
type module
type thunk
type typeinfo
type fun
type unit
type object
type variant

/* Typeable */
class Typeable __internal Typeable cast

let toInt    = cast 0
let toLong   = cast 0L
let toSingle = cast 0F
let toDouble = cast 0D
let toBool   = cast false
let toChar   = cast '\0'
let toList   = cast []
let toString = cast ""

instance Typeable list
  where cast ?string x = castString x
     et castString (x::xs) = toString x ++ castString xs
        castString [] = ""

/* Eq */
class Eq __internal Eq (==) (<>)

instance Eq tuple
  where x == y = x `eq` y
     et x <> y = not (x `eq` y)
     et tup1 `eq` tup2 = len == length tup2 and eq' 0
                where len = length tup1
                   et eq' n | n < len = if tup1:n == tup2:n then eq' (n+1) else false
                            | else = true

instance Eq record
  where x == y = x `eq` y
     et x <> y = not (x `eq` y)
     et rec1 `eq` rec2 = len == length rec2 and eq' 0
                where len = length rec1
                   et eq' n | n < len = if rec1!!n == rec2!!n and rec1:n == rec2:n then eq' (n+1) else false
                            | else = true
                   et (!!) = __internal recfield

instance Eq list
  where x == y = x `eq` y
     et x <> y = not (x `eq` y)
     et eq (x::xs) (y::ys) | x == y = xs `eq` ys | else = false
        eq [] [] = true
        eq [] _ = false
        eq _ [] = false

instance Eq variant
  where x == y = tag x == tag y and untag x == untag y
     et x <> y = tag x <> tag y or untag x <> untag y

/* Ord */
class Ord __internal Ord (>) (<) (>=) (<=)

instance Ord tuple
  where x<y = fold (<) x y
     et x>y = fold (>) x y
     et x<=y = fold (<=) x y
     et x>=y = fold (>=) x y
     et fold f tup1 tup2 | length tup2 <> len = fail "Tuples should be of the same length."
                         | else = fold' 0
                         where len = length tup1
                            et fold' n | n == len - 1 = e
                                       | else = if e then true else fold' (n+1)
                                       where e = (tup1:n) `f` (tup2:n)

/* Num */
class Num __internal Num (+) (-) (*) (/) (**) (%) (--)

/* Bit */
class Bit __internal Bit (&&&) (|||) (^^^) (~~~) (<<<) (>>>)

/* Enum */
class Enum __internal Enum succ pred

instance Enum tuple
  where succ = sp succ
     et pred = sp pred
     et sp fun tup = sp' 0
           where sp' n | n == len - 1 = (fun (tup:n),)
                       | else = (fun (tup:n),) ++ sp' (n+1)
              et len = length tup

/* Seq */
class Seq __internal Seq head tail isnil

/* Ix */
class Ix __internal Ix (:) length

instance Ix list
  where length xs = len 0 xs
               where len n [] = n
                     len n (x::xs) = len (n+1) xs
     et xs:n = get 0 xs
               where get _ [] = raise IndexOutOfRange ("Index " ++ n ++ " is out of range.")
                     get i (x::xs) | i == n = x
                                   | else = get (i+1) xs

/* Cons */
class Cons __internal Cons (::) nil

/* Cat */
class Cat __internal Cat (++)

instance Cat list
  where xs++ys = cat (reverse xs) ys
                 where cat (x::xs) ys = cat xs (x::ys)
                       cat [] ys = ys
    et reverse xs = rev [] xs
          where (:) = flip (::)
             et rev z [] = z
                rev z (x::xs) = rev (z:x) xs

/* Show */
class Show __internal Show showf

let show = showf ""

instance Show variant
  where showf f x = if v is ?unit then tag x else tag x ++ " " ++ showf f v
                    where v = untag x

instance Show tuple
  where showf f t = "(" ++ tos 0 ++ ")"
                    where tos n | n == len - 1 = e ++ (if len == 1 then "," else "")
                                | else = e ++ "," ++ tos (n+1)
                                where e = showf f (t:n) 
                       et len = length t

instance Show list
  where showf _ [] = "[]"
        showf f xs = "[" ++ tos xs ++ "]"
                     where tos (x::[]) = showf f x
                           tos (x::xs) = showf f x ++ "," ++ tos xs

instance Show record
  where showf f t = "{" ++ tos 0 ++ "}"
                    where tos n | n == len - 1 = fld
                                | else = fld ++ "," ++ tos (n+1)
                                where fld = t!!n ++ "=" ++ showf f (t:n)
                       et len = length t
                       et (!!) = __internal recfield

/* Read 
class Read
      readf (readf)


let read = readf "" 
let readInt     = readf "" ?int
let readLong    = readf "" ?long
let readSingle  = readf "" ?single
let readDouble  = readf "" ?double
let readBool    = readf "" ?bool
let readList    = readf "" ?list
let readTuple   = readf "" ?tuple
let readRecord  = readf "" ?record */

/* Boolean operators */
let not = __internal not

/* Function related operators and functions */
let (>>) f g x = g (f x)
let (<<) f g x = f (g x)
let flip = __internal flip
let curry f x y = f (x, y)
let uncurry f (x, y) = f x y
let curry3 f x y z = f (x, y, z)
let uncurry3 f (x, y, z) = f x y z

/* Tuple functions */
let (=>) x y = (x, y)
let swap (x, y) = (y, x)
let swap3 (x, y, z) = (y, x, z)
let fst (x,_) = x
let snd (_,y) = y
let fst3 (x,_,_) = x
let snd3 (_,y,_) = y

/* Complex behaviors */
let typeinfo = __internal typeinfo
let force = __internal force

/* Variants */
let tag   = __internal gettag
let untag = __internal untag

/* Combinators */
let id x = x//I
let const x _ = x//K
let sub x y z = x z (y z)//S
let fix f = f (& fix f)
let on cmb f x y = f x `cmb` f y

/* Misc */
let f! = f()
let (|>) = __internal fpipe
let (<|) = __internal bpipe
let until p f x | p x  = x  | else = until p f (f x)
let compare x y | x == y = EQ | x < y = LT | else = GT