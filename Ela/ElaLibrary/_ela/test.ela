/* 
  Module test
  Created in 2011-2012 by Basil Voronkov
*/
open core reflect format

assert # private
assert =
  {
      eq  = op' "eq"  (==),
      neq = op' "neq" (<>),
      gt  = op' "gt"  (>),
      lt  = op' "lt"  (<),
      gte = op' "gte" (>=),
      lte = op' "lte" (<=),
      eqt = op' "eqt" (==) true,
      eqf = op' "eqf" (==) false
  } 
  where op' m op x y | op x y = ()
                     | else   = raise AssertFailed (formatStr "{0} for {1} and {2}" m x y)

funData # private 
funData mod fun = (moduleName mod ++ "." ++ funName fun, fun)

regFun fun xs = funData fun :: xs

regFuns mod xs = xs ++ (vals |> filter isFun |> map (funData mod))
                 where vals = map (:"value") (moduleExportList mod)
                       isFun (_ is fun) = true
                       isFun _ = false

run xs = (res, failed)
        where exec (n, f) = try (f assert $ n, true, "") with 
                                 AssertFailed m = (n, false, ": Assert failed: " ++ m)
                                 v              = (n, false, ": Error occured: " ++ untag v)
              count f xs = length <| filter f xs
              res = map exec xs
              failed = count (not << snd3) res

report f prf (tests, failed) =
        out "Test session started" 
            (all' f tests 1 "")
            "Test session finished"
            (formatStr "Executed tests: {0}" (length tests))
            (formatStr "Successful tests: {0}" (length tests - failed))
            (formatStr "Failed tests: {0}" failed)
        where out v = prf v $ out
              tag' true  = "Success "
              tag' false = "FAILED "
              fmt' i (n, r, m) = formatStr "{0}. {1}: {2} {3}\r\n" i n (tag' r) m
              all' _ [] _ s = s
              all' f (x::xs) i s | f x  = (s ++ fmt' i x) |> all' f xs (i + 1)
                                 | else = all' f xs (i + 1) s
