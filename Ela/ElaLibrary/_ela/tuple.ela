/*
  Module tuple
  Created in 2012 by Basil Voronkov
*/
open thunk
import lang

/* Instances */
instance Additive Tuple where 
  (+)  = join (+)
  (-)  = join (-)
  negate x = zero (length x) - x

instance Enum Tuple where 
  succ = map succ
  pred = map pred
  enumFrom fst snd = gen fst (snd-fst)
    where gen e s = e :: (& gen (e+s) s)
  enumFromTo max fst snd = gen [] max fst (snd-fst)
    where gen xs max e s 
            | e > max = reverse xs
            | else = gen (e::xs) max (e+s) s

instance ListLike Tuple where
  toList t = tol 0
    where
      len = length t
      tol n | n == len = []
            | else = t:n :: tol (n+1)
  fromList xs = lang.__tupleFromList ys
    where ys | lazyList xs = forceOnlyList xs
             | else = xs

/* Functions */
map # qualified
map f tup = fromList (m 0) -> Tuple
  where 
    len = length tup
    m n | n == len = []
        | else = f (tup:n) :: m (n+1)

join # qualified
join f (x,) (a,) = (x `f` a,)
join f (x,y) (a,b) = (x `f` a, y `f` b)
join f (x,y,z) (a,b,c) = (x `f` a,y `f` b,z `f` c)
join f t1 t2 
  | len <> length t2 = fail "tuple: Tuples should be of the same length." 
  | else = fromList (fold 0) -> Tuple
  where len = length t1
        fold n | n == len = []
               | else = (t1:n `f` t2:n) :: fold (n+1)

any # qualified
any f t = m 0
  where len = length t
        m n | n == len = false
            | f (t:n) = true
            | else = m (n+1)

all # qualified
all f t = m 0
  where len = length t
        m n | n == len = true
            | f (t:n) = m (n+1)
            | else = false

zero # private
zero 1 = (0,)
zero 2 = (0,0)
zero 3 = (0,0,0)
zero n = fromList (gen [] n) -> Tuple
  where 
    gen ys 0 = ys
    gen ys n = gen (0::ys) (n-1)
