/*
  Module data
  Created by Basil Voronkov in 2012
*/
open lang

/* Reflection API */
//Constructor name: Alg->String
consName        = __internal api1

//Constructor parameter number: Alg->Int
consParamNumber = __internal api2

//Constructor index: Alg->Int
consIndex       = __internal api3

//Constructor is infix symbol: Alg->Bool
consInfix       = __internal api7

//Constructor parameters: Alg->Tuple or Alg->Unit
consParams      = __internal api8

//Constructor unique ID: Alg->Int
consCode        = __internal api9

//Type name: (any)->String
typeName        = __internal api4

//Type unique ID: (any)-Int
typeCode        = __internal api5

//Number of constructor in type: Alg->Int
typeConsNumber  = __internal api6

//Index of a parameter in constructor: String->Alg->Int
consParamIndex  = __internal api101

//Value of a parameter in constructor: Int->Alg->(any)
consParamValue  = __internal api102

//Name of a parameter: Int->Alg->String
consParamName   = __internal api103

//Checks is a cons parameter exists: String->Alg->Bool
consParamExist  = __internal api105

//Creates a default instance: Int->Alg->Alg
consDefault     = __internal api104

//Create a production: Int->Alg->Fun or Int->Alg->Alg
consCreate      = __internal api107


/* Default instances */
//Only for algebraic, open types are welcome
instance Show where
  showf f a 
    | consInfix a and len == 2 = showf f (consParamValue 0 a) ++ " " 
                                 ++ consName a ++ " " ++ showf f (consParamValue 1 a)
    | else = lang.__stringFromList (consName a :: show 0)
    where len = consParamNumber a
          show n 
            | n < len = " " :: showf f (consParamValue n a) :: show (n+1)
            | else = []

//Only for algebraic, open types are welcome
instance Eq where
  a == b = consCode a == consCode b and consParams a == consParams b
  a <> b = consCode a <> consCode b or consParams a <> consParams b

//Only for algebraic, bettern not to use with open types
instance Ord where
  a > b
    | consParamNumber a == 0 or consParamNumber b == 0 = consIndex a > consIndex b 
    | else = consIndex a > consIndex b or consParams a > consParams b
  a < b
    | consParamNumber a == 0 or consParamNumber b == 0 = consIndex a < consIndex b 
    | else = consIndex a < consIndex b or consParams a < consParams b
  a >= b = a > b or a == b
  a <= b = a < b or a == b

//Only for algebraic, open types are welcome
instance Name where
  getField nm xs = consParamValue (consParamIndex nm xs) xs
  isField = consParamExist

//Only for algebraic, open types are welcome
instance Len where
  length = consParamNumber

//Only for algebraic, open types are welcome
instance Ix where
  getValue = consParamValue

//Only for algebraic, better not to use with open types
instance Enum where
  succ a = consDefault (consIndex a + 1) a
  pred a = consDefault (consIndex a - 1) a
  enumFrom fst snd = map (flip consDefault fst) [consIndex fst,consIndex snd..consParamNumber fst - 1]
  enumFromTo max fst snd = map (flip consDefault max) [consIndex fst,consIndex snd..consIndex max]

//Only for algebraic, better not to use with open types
instance IntLike where
  toInt a = consIndex

//Only for algebraic, better not to use with open types
instance LongLike where
  toLong = toLong << consIndex

//Only for algebraic, open types are welcome
instance StringLike where
  toString = consName

//Only for algebraic, open types are welcome
instance TupleLike where
  toTuple a
    | consParamNumber a == 0 = fail "TupleLike.toTuple: Type constructor has no parameters."
    | else = consParams a

//Only for algebraic, open types are welcome
instance ListLike where
  toList a
    | len == 0 = []
    | else = tol 0
    where
      len = consParamNumber a
      tol n 
        | n < len = consParamValue n a :: tol (n+1)
        | else = []

/* Privates */
map # private
map _ [] = []
map f (x::xs) = f x :: map xs
