/* 
  Ela standard prelude module
  Created in 2011-2012 by Basil Voronkov
*/
import lang

/* Built-in types */
type Int
  deriving Eq Ord Show Additive Ring Field Modulo Bit

type Long
  deriving Eq Ord Show Additive Ring Field Modulo Bit

type Single
  deriving Eq Ord Show Additive Ring Field Modulo

type Double
  deriving Eq Ord Show Additive Ring Field Modulo

type Bool
  deriving Eq Show

type Char
  deriving Eq Ord Show Cat

type String
  deriving Eq Ord Show Cat Seq Len Ix

type Tuple
  deriving Len Ix Cat

type Record
  deriving Len Ix Name Cat

type Module
  deriving Eq Show Name

type Fun
  deriving Eq Show

type Unit
  deriving Eq Show

type Object

type List = a :: b | Nil
  deriving Seq

/* Eq */
class Eq(Eq) a where 
  (==) a->a 
  (<>) a->a

instance Eq Tuple
  where x == y = x `eqTuple` y
        x <> y = not (x `eqTuple` y)

instance Eq Record
  where x == y = x `eqRecord` y
        x <> y = not (x `eqRecord` y)

instance Eq List
  where x == y = x `eqList` y
        x <> y = not (x `eqList` y)

eqTuple # private
eqTuple tup1 tup2 = len == length tup2 and eq 0
        where len = length tup1
              eq n | n < len = if tup1:n == tup2:n then eq (n+1) else false
                   | else = true

eqRecord # private
eqRecord rec1 rec2 = len == length rec2 and eq 0
         where len = length rec1
               eq n | n < len = if rec1~n == rec2~n and rec1:n == rec2:n then eq (n+1) else false
                    | else = true

eqList # private
eqList (x::xs) (y::ys) | x == y = xs `eqList` ys | else = false
eqList [] [] = true
eqList [] _ = false
eqList _ [] = false

/* Ord */
class Ord(Ord) a where
  (>) a->a
  (<) a->a
  (>=) a->a
  (<=) a->a

instance Ord Tuple where 
  x < y  = tupleAny (<) x y
  x > y  = tupleAny (>) x y
  x <= y = tupleAny (<=) x y
  x >= y = tupleAny (>=) x y

tupleAny # private 
tupleAny f tup1 tup2 
  | length tup2 <> len = fail "prelude: Tuples should be of the same length."
  | else = fold 0
  where len = length tup1
        fold n | n == len - 1 = e
               | else = if e then true else fold (n+1)
               where e = tup1:n `f` tup2:n

/* Numerical classes */
class Additive(Additive) a where
  (+) a->a
  (-) a->a
  (--) a

class Ring(Ring) a where
  (*) a->a
  (**) a->a

class Field(Field) a where 
  (/) a->a

class Modulo(Modulo) a where
  mod a->a
  rem a->a

(%) = rem

/* Bit */
class Bit(Bit) a where 
  (&&&) a->a
  (|||) a->a
  (^^^) a->a
  (~~~) a
  (<<<) a->_
  (>>>) a->_

/* Enum */
class Enum a where
  succ a
  pred a
  enumFrom a->a
  enumFromTo a->a->a

instance Enum Int Long where
  succ = (+1)
  pred = (-1)
  enumFrom fst snd = genInf fst (snd-fst)
    where genInf e step = e :: (& genInf (e+step) step)
  enumFromTo max fst snd 
    | snd < fst = genLt [] max fst (snd-fst)
    | else = genGt [] max fst (snd-fst)
    where genLt xs max e step
            | e < max = lang.__reverseList xs
            | else = genLt(e::xs) max (e+step) step
          genGt xs max e step
            | e > max = lang.__reverseList xs
            | else = genGt(e::xs) max (e+step) step

/* Seq */
class Seq(Seq) a where
  head a
  tail a
  isnil a

/* Ix */
class Ix(Ix) a where 
  getValue _->a

instance Ix List where
  getValue n xs = get 0 xs
    where get _ [] = fail "Ix.getValue: Index is out of range."
          get i (x::xs) | i == n = x
                        | else = get (i+1) xs

(:) = __internal getvaluer

/* Len */
class Len(Len) a where
  length a

instance Len List where
  length xs
    | lang.__isLazyList xs = len 0 xs
    | else = lang.__listLength xs
    where len n [] = n
          len n (x::xs) = len (n+1) xs

/* Name */
class Name(Name) a where
  getField _->a
  hasField _->a

/* Cat */
class Cat(Cat) a where
  (++) a->_

instance Cat List where 
  xs ++ ys = cat (reverse xs) ys
             where cat (x::xs) ys = cat xs (x::ys)
                   cat [] ys = ys

reverse # private
reverse xs 
  | lang.__isLazyList xs = rev [] xs 
  | else = lang.__reverseList xs
  where rev ys [] = ys
        rev ys (x::xs) = rev (x::ys) xs

/* Show */
class Show(Show) a where 
  showf _->a

show = showf ""

instance Show Tuple where 
  showf f t = lang.__stringFromList ("(" :: tos 0)
    where len = length t
          tos n | n == len - 1 = [e, (if len == 1 then ",)" else ")")]
                | else = e :: "," :: tos (n+1)
                where e = showf f (t:n) 

instance Show List where 
  showf _ [] = "[]"
  showf f xs = lang.__stringFromList ("[" :: tos xs)
    where tos (x::[]) = [showf f x, "]"]
          tos (x::xs) = showf f x :: "," :: tos xs

instance Show Record where 
  showf f t = lang.__stringFromList ("{" :: tos 0)
    where len = length t
          tos n | n == len - 1 = [fld, "}"]
                | else = fld :: "," :: tos (n+1)
                where fld = t~n ++ "=" ++ showf f (t:n)

/* xLike */
class IntLike a where
  toInt a

class LongLike a where
  toLong a

class SingleLike a where
  toSingle a

class DoubleLike a where
  toDouble a

class BoolLike a where
  toBool a

class CharLike a where
  toChar a

class StringLike a where
  toString a

class ListLike a where
  toList a

class TupleLike a where
  toTuple a

class RecordLike a where
  toRecord a

instance ListLike List where
  toList a = a

instance TupleLike Tuple where
  toTuple a = a

instance RecordLike Record where
  toRecord a = a

instance IntLike Int Long Single Double Char Bool where
  toInt = lang.__toInt

instance LongLike Long Int Single Double Char Bool where
  toLong = lang.__toLong

instance SingleLike Single Double Long Int where
  toSingle = lang.__toSingle

instance DoubleLike Double Single Long Int where
  toDouble = lang.__toDouble

instance CharLike Char Int where
  toChar = lang.__toChar

instance BoolLike Bool Int Long where
  toBool = lang.__toBool

instance StringLike String Char where
  toString = lang.__toString

/* Misc operators */
not = __internal not

/* Function related operators and functions */
(>>) f g x = g (f x)
(<<) f g x = f (g x)
(|>) = __internal fpipe
(<|) = __internal bpipe
flip f x y = f y x
curry f x y = f (x, y)
uncurry f (x, y) = f x y
curry3 f x y z = f (x, y, z)
uncurry3 f (x, y, z) = f x y z

/* Tuple functions */
x => y = (x, y)
swap (x, y) = (y, x)
swap3 (x, y, z) = (y, x, z)
fst (x,_) = x
snd (_,y) = y
fst3 (x,_,_) = x
snd3 (_,y,_) = y

/* Complex behaviors */
force = __internal force

/* Combinators */
id x = x//I
const x _ = x//K
sub x y z = x z (y z)//S
fix f = f (& fix f)
on cmb f x y = f x `cmb` f y

/* Misc */
until p f x | p x  = x | else = until p f (f x)
even x = x % 2 == 0
odd x = x % 2 <> 0

/* Privates */
(~) # private
(~) = __internal api106
