/* 
  Ela standard prelude module
  Created in 2011-2012 by Basil Voronkov
*/
import lang

/* Built-in types */
type Int
  deriving Eq Ord Show Additive Ring Field Modulo Bit

type Long
  deriving Eq Ord Show Additive Ring Field Modulo Bit

type Single
  deriving Eq Ord Show Additive Ring Field Modulo

type Double
  deriving Eq Ord Show Additive Ring Field Modulo

type Bool
  deriving Eq Show

type Char
  deriving Eq Ord Show Cat

type String
  deriving Eq Ord Show Cat Seq Len Ix

type Tuple
  deriving Len Ix Cat

type Record
  deriving Len Ix Name Cat

type Module
  deriving Eq Show Name

type Fun
  deriving Eq Show

type Unit
  deriving Eq Show

type Object

type List = a :: b | Nil
  deriving Seq

/* Extra types */
type StringBuilder = StringBuilder xs # private

stringBuilder = StringBuilder []

(StringBuilder xs) +> s = StringBuilder (s::xs)

instance StringLike StringBuilder where
  toString (StringBuilder xs) = lts xs
    where lts = __internal api13

instance Eq StringBuilder where
  (StringBuilder xs) == (StringBuilder ys) = xs == ys
  (StringBuilder xs) <> (StringBuilder ys) = xs <> ys

instance Show StringBuilder where
  showf _ = toString

/* Eq */
class Eq(Eq) a where 
  (==) a->a 
  (<>) a->a

instance Eq Tuple where 
  x == y = x `eqTuple` y
  x <> y = not (x `eqTuple` y)

instance Eq Record where 
  x == y = x `eqRecord` y
  x <> y = not (x `eqRecord` y)

instance Eq List where 
  x == y = x `eqList` y
  x <> y = not (x `eqList` y)

eqTuple # private
eqTuple tup1 tup2 = len == length tup2 and eq 0
  where len = length tup1
        eq n | n < len = if tup1:n == tup2:n then eq (n+1) else false
             | else = true

eqRecord # private
eqRecord rec1 rec2 = len == length rec2 and eq 0
  where len = length rec1
        eq n | n < len = if n~rec1 == n~rec2 and rec1:n == rec2:n then eq (n+1) else false
             | else = true

eqList # private
eqList (x::xs) (y::ys) 
  | x == y = xs `eqList` ys 
  | else = false
eqList [] [] = true
eqList [] _ = false
eqList _ [] = false

/* Ord */
class Ord(Ord) a where
  (>) a->a
  (<) a->a
  (>=) a->a
  (<=) a->a

instance Ord Tuple where 
  x < y  = tupleAny (<) x y
  x > y  = tupleAny (>) x y
  x <= y = tupleAny (<=) x y
  x >= y = tupleAny (>=) x y

tupleAny # private 
tupleAny f tup1 tup2 
  | length tup2 <> len = fail "prelude: Tuples should be of the same length."
  | else = fold 0
  where len = length tup1
        fold n | n < len = if e then true else fold (n+1)
               | else = e
               where e = tup1:n `f` tup2:n

/* Numerical classes */
class Additive(Additive) a where
  (+) a->a
  (-) a->a
  (--) a

class Ring(Ring) a where
  (*) a->a
  (**) a->a

class Field(Field) a where 
  (/) a->a

class Modulo(Modulo) a where
  mod a->a
  rem a->a

(%) = rem

/* Bit */
class Bit(Bit) a where 
  (&&&) a->a
  (|||) a->a
  (^^^) a->a
  (~~~) a
  (<<<) a->_
  (>>>) a->_

/* Enum */
class Enum a where
  succ a
  pred a
  enumFrom a->a
  enumFromTo a->a->a

instance Enum Int Long where
  succ = (+1)
  pred = (-1)
  enumFrom fst snd = genInf fst (snd-fst)
    where genInf e step = e :: (& genInf (e+step) step)
  enumFromTo max fst snd 
    | snd < fst = genLt [] max fst (snd-fst)
    | else = genGt [] max fst (snd-fst)
    where genLt xs max e step
            | e < max = listReverse xs
            | else = genLt (e::xs) max (e+step) step
          genGt xs max e step
            | e > max = listReverse xs
            | else = genGt (e::xs) max (e+step) step

/* Bounded */
class Bounded a where
  maxBound a
  minBound a

instance Bounded Int where
  maxBound _ = 0x7fffffff
  minBound _ = 0x7fffffff + 1

instance Bounded Long where
  maxBound _ = 0x7fffffffffffffffL
  minBound _ = 0x7fffffffffffffffL + 1

instance Bounded Single where
  maxBound _ = 3.402823E+38f
  minBound _ = --3.402823E+38f

instance Bounded Double where
  maxBound _ = 1.7976931348623157E+308D
  minBound _ = --1.7976931348623157E+308D

/* Seq */
class Seq(Seq) a where
  head a
  tail a
  isnil a

/* Ix */
class Ix(Ix) a where 
  getValue _->a

instance Ix List where
  getValue n xs = get 0 xs
    where get _ [] = fail "Ix.getValue: Index is out of range."
          get i (x::xs) | i == n = x
                        | else = get (i+1) xs

(:) = __internal getvaluer

/* Len */
class Len(Len) a where
  length a

instance Len List where
  length xs
    | listLazy xs = len 0 xs
    | else = listLength xs
    where len n [] = n
          len n (x::xs) = len (n+1) xs

/* Name */
class Name(Name) a where
  getField _->a
  isField _->a

/* Cat */
class Cat(Cat) a where
  (++) a->_

instance Cat List where 
  xs ++ ys = cat (reverse xs) ys
             where cat (x::xs) ys = cat xs (x::ys)
                   cat [] ys = ys

/* Show */
class Show(Show) a where 
  showf _->a

show = showf ""

instance Show Tuple where 
  showf f (x,) = "(" ++ showf f x ++ ",)"
  showf f t = toString <| tos (stringBuilder +> "(") 0
    where len = length t - 1
          tos sb n 
            | n < len = tos (sbb +> ",") (n+1)
            | else = sbb +> ")"
            where sbb = sb +> showf f (t:n)

instance Show List where 
  showf _ [] = "[]"
  showf f xs = toString <| tos (stringBuilder +> "[") xs
    where tos sb (x::[]) = sb +> showf f x +> "]"
          tos sb (x::xs) = tos (sb +> showf f x +> ",") xs

instance Show Record where 
  showf f t = toString <| tos (stringBuilder +> "{") 0
    where len = length t - 1
          tos sb n 
            | n < len = tos (sbb +> ",") (n+1)
            | else = sbb +> "}"
            where sbb = sb +> n~t +> "=" +> showf f (t:n)

/* xLike */
class IntLike a where
  toInt a

class LongLike a where
  toLong a

class SingleLike a where
  toSingle a

class DoubleLike a where
  toDouble a

class BoolLike a where
  toBool a

class CharLike a where
  toChar a

class StringLike a where
  toString a

class ListLike a where
  toList a

class TupleLike a where
  toTuple a

class RecordLike a where
  toRecord a

instance ListLike List where
  toList = id

instance TupleLike Tuple where
  toTuple = id

instance RecordLike Record where
  toRecord = id

instance IntLike Int Long Single Double Char Bool where
  toInt = lang.__toInt

instance LongLike Long Int Single Double Char Bool where
  toLong = lang.__toLong

instance SingleLike Single Double Long Int where
  toSingle = lang.__toSingle

instance DoubleLike Double Single Long Int where
  toDouble = lang.__toDouble

instance CharLike Char Int where
  toChar = lang.__toChar

instance BoolLike Bool Int Long where
  toBool = lang.__toBool

instance StringLike String Char where
  toString = lang.__toString

/* Misc operators */
not = __internal not

/* Function related operators and functions */
(>>) f g x = g (f x)
(<<) f g x = f (g x)
(|>) = __internal fpipe
(<|) = __internal bpipe
flip f x y = f y x
curry f x y = f (x, y)
uncurry f (x, y) = f x y
curry3 f x y z = f (x, y, z)
uncurry3 f (x, y, z) = f x y z

/* Tuple functions */
x => y = (x, y)
swap (x, y) = (y, x)
swap3 (x, y, z) = (y, x, z)
fst (x,_) = x
snd (_,y) = y
fst3 (x,_,_) = x
snd3 (_,y,_) = y

/* Complex behaviors */
force = __internal force

/* Combinators */
id x = x//I
const x _ = x//K
sub x y z = x z (y z)//S
fix f = f (& fix f)
on cmb f x y = f x `cmb` f y

/* Misc */
until p f x 
  | p x  = x 
  | else = until p f (f x)
even x = x % 2 == 0
odd x = x % 2 <> 0

/* Privates */
(~) # private
(~) = __internal api106

listLazy # private
listLazy = __internal api10

listLength # private
listLength = __internal api11

listReverse # private
listReverse = __internal api12

reverse # private
reverse xs 
  | listLazy xs = rev [] xs 
  | else = listReverse xs
  where rev ys [] = ys
        rev ys (x::xs) = rev (x::ys) xs
