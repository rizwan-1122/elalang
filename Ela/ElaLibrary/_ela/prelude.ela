/* 
  Ela standard prelude module
  Created in 2011-2012 by Basil Voronkov
*/
import lang

/* Built-in types */
type Int
  deriving Eq Ord Show Additive Ring Field Modulo Bit

type Long
  deriving Eq Ord Show Additive Ring Field Modulo Bit

type Single
  deriving Eq Ord Show Additive Ring Field Modulo

type Double
  deriving Eq Ord Show Additive Ring Field Modulo

type Bool
  deriving Eq Show

not  = __internal not

type Char
  deriving Eq Ord Show Cat

type String
  deriving Eq Ord Show Cat Seq Len Ix

type Record
  deriving Len Ix Name Cat

type Module
  deriving Eq Show Name

type Unit
  deriving Eq Show

type Object

/* Function */
type Fun
  deriving Eq Show

(>>) f g x = g (f x)

(<<) f g x = f (g x)

(|>) = __internal fpipe

(<|) = __internal bpipe

f! = f()

flip f x y = f y x

curry f x y = f (x, y)

uncurry f (x, y) = f x y

curry3 f x y z = f (x, y, z)

uncurry3 f (x, y, z) = f x y z

/* Tuple */
type Tuple
  deriving Len Ix Cat

x => y = (x, y)

swap (x, y) = (y, x)

swap3 (x, y, z) = (y, x, z)

fst (x,_) = x

snd (_,y) = y

fst3 (x,_,_) = x

snd3 (_,y,_) = y

/* List */
type List
  deriving Seq

(::) = __internal cons

last (x::[]) = x
last (_::xs) = last xs
last []      = fail "prelude.last: Empty list."

init (x::[])   = []
init (x::xs)   = x :: init xs
init []        = fail "prelude.init: Empty list."

map f (x::xs) = f x :: map f xs
map _ []      = []

foldl f z (x::xs) = foldl f (f z x) xs
foldl _ z [] = z

foldr f z (x::xs) = f x (foldr f z xs)
foldr _ z []      = z

reverse xs 
  | listLazy xs = rev [] xs
  | else = revList xs
  where rev ys [] = ys
        rev ys (x::xs) = rev (x::ys) xs

filter p (x::xs) 
  | p x  = x :: filter p xs
  | else = filter p xs
filter _ [] = []

revList # private
revList = __internal api12

/* String builder */
type StringBuilder = StringBuilder xs # private

stringBuilder = StringBuilder []

(StringBuilder xs) +> s = StringBuilder (s::xs)

instance StringLike StringBuilder where
  toString (StringBuilder xs) = lts xs
    where lts = __internal api13
  fromString s = stringBuilder +> s

instance Eq StringBuilder where
  (StringBuilder xs) == (StringBuilder ys) = xs == ys
  (StringBuilder xs) <> (StringBuilder ys) = xs <> ys

instance Show StringBuilder where
  showf _ = toString

/* Default */
class Default a where
  default a

instance Default Int where
  default = 0

instance Default Long where
  default = 0L

instance Default Single where
  default = 0f

instance Default Double where
  default = 0d

instance Default Bool where
  default = false

instance Default Char where
  default = '\0'

instance Default String where
  default = ""

instance Default List where
  default = []

instance Default Unit where
  default = ()

/* Eq */
class Eq(Eq) a where 
  (==) a->a->_
  (<>) a->a->_

instance Eq Tuple where 
  (==) = compareTuples (==)
  (<>) = compareTuples (<>)

instance Eq Record where 
  x == y = x `eqRecord` y
  x <> y = not (x `eqRecord` y)

instance Eq List where 
  (==) = compareLists (==)
  (<>) = compareLists (<>)

eqRecord # private
eqRecord rec1 rec2 = len == length rec2 and eq 0
  where len = length rec1
        eq n | n < len = if n~rec1 == n~rec2 and rec1:n == rec2:n then eq (n+1) else false
             | else = true

/* Ord */
class Ord(Ord) a where
  (>) a->a->_
  (<) a->a->_
  (>=) a->a->_
  (<=) a->a->_

instance Ord Tuple where 
  x < y  = compareTuples (<) x y
  x > y  = compareTuples (>) x y
  x <= y = compareTuples (<=) x y
  x >= y = compareTuples (>=) x y

instance Ord List where
  x > y  = compareLists (>) x y
  x < y  = compareLists (<) x y
  x <= y = compareLists (<=) x y
  x >= y = compareLists (>=) x y

/* Numerical classes */
class Additive(Additive) a where
  (+) a->a->_
  (-) a->a->_
  negate a->_

(--) = negate

class Ring(Ring) a where
  (*) a->a->_
  (**) a->a->_

class Field(Field) a where 
  (/) a->a->_

class Modulo(Modulo) a where
  mod a->a->_
  rem a->a->_

(%) = rem

/* Bit */
class Bit(Bit) a where 
  (&&&) a->a->_
  (|||) a->a->_
  (^^^) a->a->_
  (~~~) a->_
  (<<<) a->_->_
  (>>>) a->_->_

/* Enum */
class Enum a where
  succ a->_
  pred a->_
  enumFrom a->a->_
  enumFromTo a->a->a->_

instance Enum Int Long where
  succ = (+ 1)
  pred = (- 1)
  enumFrom fst snd = genInf fst (snd-fst)
    where genInf e step = e :: (& genInf (e+step) step)
  enumFromTo max fst snd
    | snd < fst = genLt [] fst (snd-fst)
    | else = genGt [] fst (snd-fst)
    where genLt xs e step
            | e < max = listReverse xs
            | else = genLt (e::xs) (e+step) step
          genGt xs e step
            | e > max = listReverse xs
            | else = genGt (e::xs) (e+step) step

/* Bounded */
class Bounded a where
  maxBound a
  minBound a

instance Bounded Int where
  maxBound = 0x7fffffff
  minBound = 0x7fffffff + 1

instance Bounded Long where
  maxBound = 0x7fffffffffffffffL
  minBound = 0x7fffffffffffffffL + 1

instance Bounded Single where
  maxBound = 3.402823E+38f
  minBound = --3.402823E+38f

instance Bounded Double where
  maxBound = 1.7976931348623157E+308D
  minBound = --1.7976931348623157E+308D

/* Seq */
class Seq(Seq) a where
  head a->_
  tail a->_
  isnil a->_

/* Ix */
class Ix(Ix) a where 
  getValue _->a->_

instance Ix List where
  getValue n xs = get 0 xs
    where get _ [] = fail "Ix.getValue: Index is out of range."
          get i (x::xs) | i == n = x
                        | else = get (i+1) xs

(:) = __internal getvaluer

/* Len */
class Len(Len) a where
  length a->_

instance Len List where
  length xs
    | listLazy xs = len 0 xs
    | else = listLength xs
    where len n [] = n
          len n (_::xs) = len (n+1) xs

/* Name */
class Name(Name) a where
  getField _->a->_
  isField _->a->_

/* Cat */
class Cat(Cat) a where
  (++) a->_->_

instance Cat List where 
  xs ++ ys = cat (reverse xs) ys
    where cat (x::xs) ys = cat xs (x::ys)
          cat [] ys = ys

/* Show */
class Show(Show) a where 
  showf _->a->_

show = showf ""

instance Show Tuple where 
  showf f (x,) = "(" ++ showf f x ++ ",)"
  showf f t = toString <| tos (stringBuilder +> "(") 0
    where len = length t - 1
          tos sb n 
            | n < len = tos (sbb +> ",") (n+1)
            | else = sbb +> ")"
            where sbb = sb +> showf f (t:n)

instance Show List where 
  showf _ [] = "[]"
  showf f xs = toString <| tos (stringBuilder +> "[") xs
    where tos sb (x::[]) = sb +> showf f x +> "]"
          tos sb (x::xs) = tos (sb +> showf f x +> ",") xs

instance Show Record where 
  showf f t = toString <| tos (stringBuilder +> "{") 0
    where len = length t - 1
          tos sb n 
            | n < len = tos (sbb +> ",") (n+1)
            | else = sbb +> "}"
            where sbb = sb +> n~t +> "=" +> showf f (t:n)

/* xLike */
class IntLike a where
  toInt a->_
  fromInt _->a

class LongLike a where
  toLong a->_
  fromLong _->a

class SingleLike a where
  toSingle a->_
  fromSingle _->a

class DoubleLike a where
  toDouble a->_
  fromDouble _->a

class BoolLike a where
  toBool a->_
  fromBool _->a

class CharLike a where
  toChar a->_
  fromChar _->a

class StringLike a where
  toString a->_
  fromString _->a

class ListLike a where
  toList a->_
  fromList _->a

class TupleLike a where
  toTuple a->_
  fromTuple _->a

class RecordLike a where
  toRecord a->_
  fromRecord _->a

instance ListLike List where
  toList = id
  fromList = id

instance TupleLike Tuple where
  toTuple = id
  fromTuple = id

instance RecordLike Record where
  toRecord = id
  fromRecord = id

instance IntLike Int where
  toInt = id
  fromInt = id

instance IntLike Long where
  toInt = lang.__toInt
  fromInt = lang.__toLong

instance IntLike Single where
  toInt = lang.__toInt
  fromInt = lang.__toSingle

instance IntLike Double where
  toInt = lang.__toInt
  fromInt = lang.__toDouble

instance IntLike Char where
  toInt = lang.__toInt
  fromInt = lang.__toChar

instance IntLike Bool where
  toInt = lang.__toInt
  fromInt = lang.__toBool

instance LongLike Long where
  toLong = id
  fromLong = id

instance LongLike Int where
  toLong = lang.__toLong
  fromLong = lang.__toInt

instance LongLike Single where
  toLong = lang.__toLong
  fromLong = lang.__toSingle

instance LongLike Double where
  toLong = lang.__toLong
  fromLong = lang.__toDouble

instance LongLike Char where
  toLong = lang.__toLong
  fromLong = lang.__toChar

instance LongLike Bool where
  toLong = lang.__toLong
  fromLong = lang.__toBool

instance SingleLike Single where
  toSingle = id
  fromSingle = id

instance SingleLike Int where
  toSingle = lang.__toSingle
  fromSingle = lang.__toInt

instance SingleLike Double where
  toSingle = lang.__toSingle
  fromSingle = lang.__toDouble

instance SingleLike Long where
  toSingle = lang.__toSingle
  fromSingle = lang.__toLong

instance DoubleLike Double where
  toDouble = id
  fromDouble = id

instance DoubleLike Int where
  toDouble = lang.__toDouble
  fromDouble = lang.__toInt

instance DoubleLike Single where
  toDouble = lang.__toDouble
  fromDouble = lang.__toSingle

instance DoubleLike Long where
  toDouble = lang.__toDouble
  fromDouble = lang.__toLong

instance CharLike Char where
  toChar = id
  fromChar = id

instance CharLike Int where
  toChar = lang.__toChar
  fromChar = lang.__toInt

instance BoolLike Bool where
  toBool = id
  fromBool = id
  
instance BoolLike Int where
  toBool = lang.__toBool
  fromBool = lang.__toInt

instance BoolLike Long where
  toBool = lang.__toBool
  fromBool = lang.__toLong
  
instance StringLike String where
  toString = id
  fromString = id

instance StringLike Char where
  toString = lang.__toString
  fromString = lang.__toChar

/* Misc */
force = __internal force
undefined = & fail "Undefined."

/* Combinators */
id x = x//I
const x _ = x//K
sub x y z = x z (y z)//S
fix f = f (& fix f)
on cmb f x y = f x `cmb` f y
iif p f x y
  | p x  = f x y
  | else = y

/* Misc */
until p f x 
  | p x  = x 
  | else = until p f (f x)
even x = x % 2 == 0
odd x = x % 2 <> 0

/* Privates */
(~) # private
(~) = __internal api106

listLazy # private
listLazy = __internal api10

listLength # private
listLength = __internal api11

listReverse # private
listReverse = __internal api12

compareLists # private
compareLists f (x::xs) (y::ys) 
  | x `f` y = compareLists f xs ys 
  | else = false
compareLists _ [] [] = true
compareLists _ [] _ = false
compareLists _ _ [] = false

compareTuples # private 
compareTuples f tup1 tup2 
  | length tup2 <> len = fail "prelude: Tuples should be of the same length."
  | else = fold 0
  where 
    len = length tup1
    fold n 
      | n < len - 1 = if e then true else fold (n+1)
      | else = e
      where e = tup1:n `f` tup2:n
