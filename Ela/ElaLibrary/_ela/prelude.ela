/* 
  Ela standard prelude module
  Created in 2011-2012 by Basil Voronkov
*/
import lang

/* Built-in types */
type int
type long
type single
type double
type bool
type char
type string
type tuple
type record
type module
type fun
type unit
type object

type list a = a :: list | Nil

/* Eq */
class Eq __internal Eq (==) (<>)

instance Eq int

instance Eq char

instance Eq bool

instance Eq double

instance Eq single

instance Eq long

instance Eq string

instance Eq unit

instance Eq fun

instance Eq module

instance Eq tuple
  where x == y = x `eqTuple` y
        x <> y = not (x `eqTuple` y)

instance Eq record
  where x == y = x `eqRecord` y
        x <> y = not (x `eqRecord` y)

instance Eq list
  where x == y = x `eqList` y
        x <> y = not (x `eqList` y)

eqTuple # private
eqTuple tup1 tup2 = len == length tup2 and eq 0
        where len = length tup1
              eq n | n < len = if tup1:n == tup2:n then eq (n+1) else false
                   | else = true

eqRecord # private
eqRecord rec1 rec2 = len == length rec2 and eq 0
         where len = length rec1
               eq n | n < len = if rec1!!n == rec2!!n and rec1:n == rec2:n then eq (n+1) else false
                    | else = true

eqList # private
eqList (x::xs) (y::ys) | x == y = xs `eqList` ys | else = false
eqList [] [] = true
eqList [] _ = false
eqList _ [] = false

/* Ord */
class Ord __internal Ord (>) (<) (>=) (<=)

instance Ord int

instance Ord long

instance Ord single

instance Ord double

instance Ord char

instance Ord string

instance Ord tuple
  where x<y = tupleAny (<) x y
        x>y = tupleAny (>) x y
        x<=y = tupleAny (<=) x y
        x>=y = tupleAny (>=) x y

tupleAny # private 
tupleAny f tup1 tup2 
  | length tup2 <> len = fail "prelude: Tuples should be of the same length."
  | else = fold 0
  where len = length tup1
        fold n | n == len - 1 = e
               | else = if e then true else fold (n+1)
               where e = tup1:n `f` tup2:n

/* Additive */
class Additive __internal Additive (+) (-) (--)

instance Additive int

instance Additive long

instance Additive single

instance Additive double

/* Ring */
class Ring __internal Ring (*) (**)

instance Ring int

instance Ring long

instance Ring single

instance Ring double

/* Num */
class Field __internal Field (/)

instance Field single

instance Field double

/* Modulo */
class Modulo __internal Modulo mod rem

instance Modulo int

instance Modulo long

instance Modulo single

instance Modulo double

(%) = rem

/* Bit */
class Bit __internal Bit (&&&) (|||) (^^^) (~~~) (<<<) (>>>)

instance Bit int

instance Bit long

/* Enum */
class Enum a where
  succ a
  pred a
  enumFrom a->a
  enumFromTo a->a->a

instance Enum int long where
  succ = (+1)
  pred = (-1)
  enumFrom fst snd = genInf fst (snd-fst)
    where genInf e step = e :: (& genInf (e+step) step)
  enumFromTo max fst snd = gen [] max fst (snd-fst)
    where gen xs max e step
            | e > max = lang.__reverseList xs
            | else = gen (e::xs) max (e+step) step

/* Seq */
class Seq __internal Seq head tail isnil

instance Seq list

instance Seq string

/* Ix */
class Ix __internal Ix item length

(:) = item

instance Ix string

instance Ix tuple

instance Ix record

instance Ix list
  where 
    length xs
      | lang.__isLazyList xs = len 0 xs
      | else = lang.__listLength xs
      where len n [] = n
            len n (x::xs) = len (n+1) xs
    item xs n = get 0 xs
      where get _ [] = fail ("Index " ++ n ++ " is out of range.")
            get i (x::xs) | i == n = x
                          | else = get (i+1) xs

/* Cat */
class Cat __internal Cat (++)

instance Cat char

instance Cat string

instance Cat tuple

instance Cat record

instance Cat list
  where xs++ys = cat (reverse xs) ys
                 where cat (x::xs) ys = cat xs (x::ys)
                       cat [] ys = ys

reverse # private
reverse xs 
  | lang.__isLazyList xs = rev [] xs 
  | else = lang.__reverseList xs
  where (:) = flip (::)
        rev z [] = z
        rev z (x::xs) = rev (z:x) xs

/* Show */
class Show __internal Show showf

show = showf ""

instance Show int

instance Show long

instance Show single

instance Show double

instance Show char

instance Show bool

instance Show string

instance Show unit

instance Show fun

instance Show module

instance Show tuple where 
  showf f t = lang.__stringFromList ("(" :: tos 0)
    where len = length t
          tos n | n == len - 1 = [e, (if len == 1 then ",)" else ")")]
                | else = e :: "," :: tos (n+1)
                where e = showf f (t:n) 

instance Show list where 
  showf _ [] = "[]"
  showf f xs = lang.__stringFromList ("[" :: tos xs)
    where tos (x::[]) = [showf f x, "]"]
          tos (x::xs) = showf f x :: "," :: tos xs

instance Show record where 
  showf f t = lang.__stringFromList ("{" :: tos 0)
    where len = length t
          tos n | n == len - 1 = [fld, "}"]
                | else = fld :: "," :: tos (n+1)
                where fld = t!!n ++ "=" ++ showf f (t:n)

/* xLike */
class IntLike a where
  toInt a

class LongLike a where
  toLong a

class SingleLike a where
  toSingle a

class DoubleLike a where
  toDouble a

class BoolLike a where
  toBool a

class CharLike a where
  toChar a

class StringLike a where
  toString a

instance IntLike int long single double char bool where
  toInt = lang.__toInt

instance LongLike long int single double char bool where
  toLong = lang.__toLong

instance SingleLike single double long int where
  toSingle = lang.__toSingle

instance DoubleLike double single long int where
  toDouble = lang.__toDouble

instance CharLike char int where
  toChar = lang.__toChar

instance BoolLike bool int long where
  toBool = lang.__toBool

instance StringLike string char where
  toString = lang.__toString


/* Misc operators */
not = __internal not

/* Function related operators and functions */
(>>) f g x = g (f x)
(<<) f g x = f (g x)
f! = f()
(|>) = __internal fpipe
(<|) = __internal bpipe
flip f x y = f y x
curry f x y = f (x, y)
uncurry f (x, y) = f x y
curry3 f x y z = f (x, y, z)
uncurry3 f (x, y, z) = f x y z

/* Tuple functions */
(=>) x y = (x, y)
swap (x, y) = (y, x)
swap3 (x, y, z) = (y, x, z)
fst (x,_) = x
snd (_,y) = y
fst3 (x,_,_) = x
snd3 (_,y,_) = y

/* Complex behaviors */
getType x = lang.__getTypeInfo (force x)
force = __internal force

/* Variants */
tag   = __internal gettag
untag x = lang.__unwrap (force x)

/* Combinators */
id x = x//I
const x _ = x//K
sub x y z = x z (y z)//S
fix f = f (& fix f)
on cmb f x y = f x `cmb` f y

/* Misc */
until p f x | p x  = x | else = until p f (f x)
even x = x % 2 == 0
odd x = x % 2 <> 0

/* Functions used for automatic instance generation */
genericEq # infrastructure
genericEq a b = tag a == tag b and untag a == untag b

genericNeq # infrastructure
genericNeq a b = tag a <> tag b or untag a <> untag b

genericGt # infrastructure
genericGt a b = untag a > untag b and tag a >= tag b

genericLt # infrastructure
genericLt a b = tag a < tag b or untag a < untag b

genericGtEq # infrastructure
genericGtEq a b = tag a >= tag b and untag a >= untag b

genericLtEq # infrastructure
genericLtEq a b = tag a <= tag b or untag a <= untag b

genericShow # infrastructure
genericShow f a 
  | lang.__isInfix lang a = showf f (u:0) ++ " " ++ tag a ++ " " ++ showf f (u:1)
  | else = lang.__stringFromList (tag a :: v)
  where u = untag a 
        v = match u with () = []; _  = " " :: showParamList f u

showParamList # private
showParamList f t = tos 0
  where len = length t
        tos n | n == len - 1 = [e]
              | else = e :: " " :: tos (n+1)
              where e = showf f (t:n) 

/* Privates */
(!!) # private
(!!) = __internal recfield
