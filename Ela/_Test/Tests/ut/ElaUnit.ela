//ELAUNIT

open Core

let toString x = show x
let inline (^^) x y = toString x ++ toString y
let concat x::[] = show x
    concat x::xs = x ^^ concat xs
let failureMessage = "FAILED"

//let no_action x y = true

let assert =
    {
        //disabled = op' "disabled test" (no_action)
        eq  = op' "eq"  (==),
        neq = op' "neq" (<>),
        gt  = op' "gt"  (>),
        lt  = op' "lt"  (<),
        gte = op' "gte" (>=),
        lte = op' "lte" (<=)
    }
    where op' m op x y | op x y = ()
                       | m == "eq" = raise
                                     AssertFailed
                                     (
                                       concat[Expected,": ",x," but was: ",y]
                                     )
                       | else      = raise AssertFailed (m)

let funData fun = (funDescription,fun)
                  where t = type fun
                     et funDescription = concat [t.module.name,".",t.name]

let isFun x = x is ?fun

let regFuns mod xs = xs ++ (vals |> filter isFun |> map funData)
                     where vals = [ v.value \\ v <- (type mod).globals ]

let run xs = (res, failed)
        where exec (n, f) = try (f assert $ n, true, "") with
                                 AssertFailed m = (n, false, ": Assert failed: " ++ m)
                                 v              = (n, false, ": Error occured: " ++ untag v)
           et count f xs = length <| filter f xs
           et res = map exec xs
           et failed = count (\(_,y,_) -> not y) res
             
let fmt prf (tests, failed) = let totTests = length tests
                               et numSuccesfulTests = totTests - failed
                               et numFailedTests = failed
                               et out v = prf v $ out
                               et fmt' nTest (moduleName, success, message)
                                   | success = ""
                                   | else    = concat
                                               [
                                                  nTest,         ". ",
                                                  moduleName,    ": ",
                                                  failureMessage," ",
                                                  message,       "\r\n"
                                               ]
                               et all' x::xs i s = (s ++ fmt' i x) |> all' xs (i + 1)
                                  all' []    _ s = s
                               et result | numFailedTests == 0 = out (concat ["# Executed tests: ",length tests," - OK"])
                                         | else = out (concat ["# Executed tests _________________________________________",length tests])
                                                      (concat ["# Successful tests _______________________________________",length tests - failed])
                                                      (concat ["# Failed tests ___________________________________________",failed,"\r\n"])
                                                      (all' tests 1 "")
                                in result
