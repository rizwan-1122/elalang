/*let (x, y) = (2, 2);


for i to 1000*1000 do
    ignore <| x + y
end*/

//old: 00:00:00.1580090
//new: 00:00:00.1520087
/*
open Math with sin;

let abs x | x < 0d = 0d - x, | else = x;

let solve f x1 x2 eps = secant_step x1 (f x1) x2 (f x2)
  where secant_step x1 f1 x2 f2 =
        let secant x1 f1 x2 f2 = x1 - (x1-x2)*f1/(f1-f2) in
        let x3 = secant x1 f1 x2 f2 in
        let f3 = f x3           
        in
            if abs(x1-x2) < eps then  x1
            else if f3 == 0.0 then x3 
            else if f1*f3 < 0.0 then secant_step x1 f1 x3 f3
            else secant_step x2 f2 x3 f3
  end;
  
let func1 = \x:double -> x / 2D - sin x;
solve func1 1d 2d 1e-10;


let year_size = 365.0;
 
let birthday prob people | prob' < 0.5 = people + 1.0 \
                         | else        = birthday prob' (people + incr)
                         where prob' = (year_size - people) / year_size * prob et
                               incr  = 1.0 
                         end   
 
cout (birthday 1.0 1.0);*/

open Core
let is_true x            = is_axiom x || is_theorem x
 et is_expr x            = is_b_expr x || is_n_expr x || is_a_expr x
 et is_axiom x           = is_n_expr x && is_b_expr (tail x)
 et is_b_expr ['B']      = true
    is_b_expr 'B'::xs    = all (=='I') xs
    is_b_expr  _         = false 
 et is_n_expr 'N'::xs    = is_expr xs
    is_n_expr  _         = false               
 et split _ []           = []
    split p x::xs        = split' [x] xs
                           where split' _  [] = false
                                 split' l1 (x::xs)@l2 | p l1 l2 = l1
                                                      | else    = split' (l1 ++ [x]) xs
 et have_two_exprs xs ys = is_expr xs && is_expr ys
 et check_two_exprs lst  = (split have_two_exprs lst) is ?list
 et is_a_expr 'A'::xs    = check_two_exprs xs
    is_a_expr  _         = false               
 et is_theorem x         = is_n_expr x && is_a_expr (tail x) && has_subtheorem x
                           where has_subtheorem lst = is_true ('N'::first)
                                                      where first = split have_two_exprs (tail (tail x))

let test1 = "NBI" // this is "true" because it is an axiom
let test2 = "NBIBI" // this is not a well-formed expression
let test3 = "NABIBI" // this is "true" because of derivation (NBI, BI) -> NABIBI
let test4 = "NANBBI" // this is a well-formed expression but is not "true"
let test5 = "ABB" // this is well-formed but not "true"
let test6 = "NABIBIBI" // not well-formed
let test7 = "NAABABBBI" // "true"

let list1 = ["NBI", "NBIBI", "NABIBI", "NANBBI", "ABB", "NABIBIBI", "NAABABBBI"]

map is_true list1

//from W. Robinson, Computers, minds and robots, Temple University Press, 1992.
//ABIN in Pure: http://code.google.com/p/pure-lang/wiki/PurePrimer2#Complete_code_for_ABIN