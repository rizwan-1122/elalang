COMPILER Ela

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	newLine = cr + lf.
	tab = '\t'.    
	letter = 'A' .. 'Z' + 'a' .. 'z' + '_'.
	ucase = 'A' .. 'Z'.
	lcase = 'a' .. 'z'.
	digit = "0123456789".
	notDigit = ANY - digit.
	hexDigit = digit + "ABCDEFabcdef".
	verbatimChar = ANY.
	stringChar = ANY - '"' - '\\' - newLine.
	char = ANY - "'" - '\\' - newLine.
	op = "!%&*+-.:/<=>?@^|~".
	op2 = "!%&*+-.:/<=?@^|~".
	op3 = "!%&*+-.:/=>?@^~".
	op4 = "!%&*+.:/<=>?@^|~".
	op5 = "!%&*+-./<=>?@^|~".

TOKENS
	ident = lcase { letter | digit | "'" }
			| "_" ("'"|letter) { letter | digit | "'" }
			| "'" letter [ (letter|digit|"'") {letter|digit|"'"} (letter|digit) ].	
	
	variantTok = ucase { letter | digit | "'" }.
				
	intTok = ( digit { digit } | digit { digit } CONTEXT ("." notDigit) | 
			( "0x" | "0X" ) hexDigit { hexDigit } ) [ "L" | "l" ].
			
	realTok = "." digit { digit } [ ( "e" | "E") [ "+" | "-" ] digit { digit } ] [ "D" | "d" | "F" | "f" ] 
			| digit { digit } 
			( 
				"." digit { digit } 
				[ ( "e" | "E" ) ["+" | "-" ] digit { digit } ] [ "D" | "d" | "F" | "f" ] 
				| ( "e" | "E") ["+" | "-" ] digit { digit } [ "D" | "d" | "F" | "f" ]  | "D" | "d" | "F" | "f"
			).		
			
	stringTok = "\"" { stringChar
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					}  
				"\""
				| "<[" {verbatimChar} "]>".
				
	charTok = 	"'" ( char
					| "\\\"" | "\\\\" | "\\0" | "\\b" | "\\n" | "\\r" | "\\t" | "\\'"
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					)  
				"'".
	operatorTok1 = (
		("="|"|"|"&") { op }
		| ">" [ op2 { op } ]
		| "<" [ op3 { op } ]
		).
	operatorTok2 = "^" { op }.
	operatorTok3 = "::" { op }.
	operatorTok4 = (
		"+" { op }
		| "-" [ op4 { op } ]
		).
	operatorTok5 = ("*"|"/"|"%") { op }.		
	operatorTok6 = "<<" { op }.
	operatorTok7 = ">>" { op }.
	operatorTok8 = (("~"|"--"|"!"|"?") { op }
	               | ":" [ op5 { op } ]).
	operatorTok9 = "<|" { op }.
	typeNameTok = "?" lcase { letter }.
	
	LBRA = "{".
	RBRA = "}".
	LILB = "[".
	LIRB = "]".
	
	PIPE = "|".
	ARROW = "->".
	LAMBDA = "\\".
	COMPH = "@@".
	COMPO = "\\\\".
	
	DOT = ".".
	IN = "in".
	MATCH = "match".
	ASAMP = "@".
	IS = "is".	
	LET = "let".
	PRIVATE = "private".
	OPEN = "open".	
	WITH = "with".
	IFS = "if".
	ELSE = "else".
	THEN = "then".
	RAISE = "raise".
	TRY = "try".
	TRUE = "true".
	FALSE = "false".
	FAIL = "fail".
	WHERE = "where".
	QUALIFIED = "qualified".
	
	ET = "et".
	
	EBLOCK = ";".
	
	
COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/"
IGNORE cr + lf

PRODUCTIONS
	EndBlock = EBLOCK (. if (!t.virt) scanner.PopIndent(); .).

	Literal<out ElaExpression exp> = 
		(. exp = null; .)
		(	
			Primitive<out exp>
			| RecordLiteral<out exp>
			| ListLiteral<out exp>
			| TupleLiteral<out exp>
			| SimpleExpr<out exp>
			| VariantLiteral<out exp>
		).		
		
	VariantLiteral<out ElaExpression exp> = 
		variantTok (. exp = new ElaVariantLiteral(t) { Tag = t.val }; .).
		
	SimpleExpr<out ElaExpression exp> = 
		(. exp = null; .)
		(	
			VariableReference<out exp>
		).
		
	Primitive<out ElaExpression exp> = 
		(. exp = null; .)
		(
			intTok  (. exp = new ElaPrimitive(t) { Value = ParseInt(t.val) };	.)
			| realTok (. exp = new ElaPrimitive(t) { Value = ParseReal(t.val) }; .)
			| stringTok (. exp = new ElaPrimitive(t) { Value = ParseString(t.val) }; .)
			| charTok (. exp = new ElaPrimitive(t) { Value = ParseChar(t.val) }; .)
			| TRUE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(true) }; .) 
			| FALSE (. exp = new ElaPrimitive(t) { Value = new ElaLiteralValue(false) }; .)
		).
		
	VariableReference<out ElaExpression exp> =
		(. exp = null; .)
		(
			ident (. exp = new ElaVariableReference(t) { VariableName = t.val }; .)
			| "_" (. exp = new ElaPlaceholder(t); .)
		).
		
	TupleLiteral<out ElaExpression exp> =
		(. 
			var ot = default(Token);
			exp = null; 
		.)
		(
			"(" 
				(. ot = t; .)
				[ 
					GroupExpr<out exp> 
					| LazyExpr<out exp>
				] 
			")"
		)
		(.
			if (exp == null)
				exp = new ElaUnitLiteral(ot);
		.).			
		
	GroupExpr<out ElaExpression exp> = 
		(. 
			exp = null; 
			var cexp = default(ElaExpression);
			var ot = t;
		.)
		(
			Expr<out exp>
			[
				(
					(. 
						var tuple = new ElaTupleLiteral(ot); 
						tuple.Parameters.Add(exp);
						exp = tuple; 
					.)		
					","
					(	
						[
							Expr<out cexp> 
							(. tuple.Parameters.Add(cexp); .)
						]
						{ "," Expr<out cexp> (. tuple.Parameters.Add(cexp); .) }
					)
				)
			]
		).
			
		
	/* Match */
	
	MatchExpr<out ElaExpression exp> = 
		(. scanner.InjectBlock(); .)
		SYNC MATCH
		(. 
			var match = new ElaMatch(t);
			exp = match; 
			var cexp = default(ElaExpression);
		.)
		Expr<out cexp> (. match.Expression = cexp; .)
		WITH
		(
			MatchEntry<match>
			{ 
				MatchEntry<match>
				| ChildMatchEntry<match>
			}
		)		
		EndBlock.
					
	MatchEntry<ElaMatch match> = 
		(. var cexp = default(ElaExpression); .)
		(. scanner.InjectBlock(); .)
		(		
			(. 
				var pat = default(ElaPattern); 
				var ot = t; 
			.)			
			RootPattern<out pat>
			(. 
				var entry = new ElaMatchEntry(ot);
				entry.Pattern = pat;				
				match.Entries.Add(entry);
			.)
			[ 
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
		)
		(	
			"=" Expr<out cexp>
			(. entry.Expression = cexp; .)	
		)
		[ 
			WhereBinding<out cexp> 
			(. entry.Where = cexp; .) 
		]
		(. if (RequireEndBlock()) .) EndBlock.
		
	ChildMatchEntry<ElaMatch match> = 
		(. var cexp = default(ElaExpression); .)
		(		
			(. 
				var entry = new ElaMatchEntry(t);
				match.Entries.Add(entry);
			.)
			Guard<out cexp>
			(. entry.Guard = cexp; .)
			
			"=" Expr<out cexp>
			(. entry.Expression = cexp; .)	
			
			[ 
				WhereBinding<out cexp> 
				(. entry.Where = cexp; .) 
			]
		)
		(. if (RequireEndBlock()) .) EndBlock.
		
	Guard<out ElaExpression exp> = 
		(. exp = null; .)
		"|" 		
		(
			(
				BinaryExpr<out exp>
				{
					(. var old = exp; .)
					"," 
					(. var ot = t; .)
					BinaryExpr<out exp>
					(.
						exp = new ElaBinary(t) { Operator = ElaOperator.BooleanAnd, Left = old, Right = exp };
					.)
				}
			)
			| "else" (. exp = new ElaOtherwiseGuard(t); .)
		).	
		
	RootPattern<out ElaPattern pat> =
		OrPattern<out pat> 
		[ ConsPattern<pat, out pat> ].
		
	ParenPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			OrPattern<out pat> 
		)
		[ ConsPattern<pat, out pat> ]		
		[ TuplePattern<pat, out pat> ].
		
	VariantPattern<out ElaPattern pat> = 
		(. 
			pat = null; 
			var vp = default(ElaVariantPattern);
			var cpat = default(ElaPattern);
		.)
		(
			(
				variantTok  
				(. 
					vp = new ElaVariantPattern(t);
					vp.Tag = t.val; 
				.)
			)
			[ 
				AsPattern<out cpat> 
				(. vp.Pattern = cpat; .)
			]
			(. pat = vp; .)
		).
	
	SimpleVariantPattern<out ElaPattern pat> = 
		(. pat = null; .)
		(
			variantTok  
			(. 
				pat = new ElaVariantPattern(t) { Tag = t.val };
			.)
		).
			
	OrPattern<out ElaPattern pat> =	
		(. pat = null; .)
		(VariantPattern<out pat> | AsPattern<out pat>).
		
	FuncPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			AsPattern<out pat> 
			| SimpleVariantPattern<out pat>
		).
					
	FuncPattern2<out ElaPattern pat> =
		(. pat = null; .)
		(
			(AsPattern<out pat>|SimpleVariantPattern<out pat>) [ ConsPattern<pat, out pat> ]
		).

	SinglePattern<out ElaPattern pat> =			
		(. pat = null; .)
		(
			DefaultPattern<out pat>
			| UnitPattern<out pat>
			| LiteralPattern<out pat> 
			| ListPattern<out pat>
			| RecordPattern<out pat>
			| IdentPattern<out pat>
			| TypeCheckPattern<out pat>
		).
			
	AsPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			SinglePattern<out pat>
			[
				"@" 
				(. 
					var asPat = new ElaAsPattern(t) { Pattern = pat }; 
					pat = asPat;				
				.)
				(
					ident (. asPat.Name = t.val; .)
					| 
					(
						"(" Operators (. asPat.Name = t.val; .) ")"
					)
				)
			]		
		).
		
	UnitPattern<out ElaPattern pat> = 
		(.
			var ot = t;
			pat = null;
		.)
		(
			"(" 
				[ ParenPattern<out pat> | SymbolicIdentPattern<out pat> ] 
			")" 
		)
		(. 
			if (pat == null)
				pat = new ElaUnitPattern(ot); 
		.). 
		
	DefaultPattern<out ElaPattern pat> = 
		"_" (. pat = new ElaDefaultPattern(t); .). 
		
	SymbolicIdentPattern<out ElaPattern pat> = 
		Operators (. pat = new ElaVariablePattern(t) { Name = t.val }; .).
		
	BindingPattern<out ElaPattern pat> =
		(. pat = null; .)
		(
			DefaultPattern<out pat>
			| UnitPattern<out pat>
			| LiteralPattern<out pat> 
			| ListPattern<out pat>
			| RecordPattern<out pat>
			| TypeCheckPattern<out pat>
			| SimpleVariantPattern<out pat>
		)
		[
			"@" 
			(. 
				var asPat = new ElaAsPattern(t) { Pattern = pat }; 
				pat = asPat;				
			.)
			(
				ident (. asPat.Name = t.val; .)
				| 
				(
					"(" Operators (. asPat.Name = t.val; .) ")"
				)
			)
		].		
		
	GeneratorPattern<out ElaPattern pat> =
		(. pat = null; string name = null; .)
		(
			  IdentPattern<out pat> (. name = pat.GetName(); .)
			| LiteralPattern<out pat>
			| RecordPattern<out pat>
			| ListPattern<out pat>
			| UnitPattern<out pat>
			| SimpleVariantPattern<out pat>
		).
		
	IsOperatorPattern<out ElaPattern pat> = 
		(. pat = null; .)
		(
			TypeCheckPattern<out pat>
			| LiteralPattern<out pat>
			| RecordPattern<out pat>
			| ListPattern<out pat>
			| UnitPattern<out pat>
			| VariantPattern<out pat>
		).
		
	TypeCheckPattern<out ElaPattern pat> = 
		(. 
			var eis = new ElaIsPattern(t);
			pat = eis; 			
		.)
		(
			typeNameTok
			(. 
				eis.TypeCode = GetType(t.val); 
				
				if (eis.TypeCode == ElaTypeCode.None)
					eis.TypeName = t.val.Substring(1);
			.)
		).		
						
	IdentPattern<out ElaPattern pat> =
		ident (. pat = new ElaVariablePattern(t) { Name = t.val }; .).	
		
	RecordPattern<out ElaPattern pat> = 
		(. 
			pat = null; 
			var cpat = default(ElaFieldPattern);
		.)
		(
			"{"
				(. 
					var rec = new ElaRecordPattern(t); 
					pat = rec; 
				.)				
				[
					FieldPattern<out cpat>
					(. rec.Fields.Add(cpat); .)
					{
						","
						FieldPattern<out cpat>
						(. rec.Fields.Add(cpat); .)
					}
				]
			"}"		
		).
		
	FieldPattern<out ElaFieldPattern fld> =
		(. 
			fld = null;
			var cpat = default(ElaPattern);
		.)
		(
			(
				stringTok
				(. fld = new ElaFieldPattern(t) { Name = ReadString(t.val) }; .)		
				"=" AsPattern<out cpat>
				(. fld.Value = cpat; .)
			)
			|
			(
				ident
				(. fld = new ElaFieldPattern(t) { Name = t.val }; .)		
				[
					"=" AsPattern<out cpat>
				]
				(. 
					if (cpat == null)
						cpat = new ElaVariablePattern(t) { Name = fld.Name };
					
					fld.Value = cpat; 
				.)
			)
		).	
			
	TuplePattern<ElaPattern prev, out ElaPattern pat> = 
		(.
			var seq = new ElaTuplePattern(t); 
			seq.Patterns.Add(prev);
			var cpat = default(ElaPattern);
			pat = seq;
		.)
		(
			"," 
			[
				AsPattern<out cpat> [ ConsPattern<cpat, out cpat> ]	
				(. seq.Patterns.Add(cpat); .)
				{ 
					"," 
					AsPattern<out cpat> [ ConsPattern<cpat, out cpat> ]	
					(. seq.Patterns.Add(cpat); .)
				}
			]
		).
			
	ConsPattern<ElaPattern prev, out ElaPattern exp> =
		(. 
			var cexp = default(ElaPattern); 
			var ht = new ElaHeadTailPattern(t); 
			ht.Patterns.Add(prev);
			exp = ht;				
		.)
		(
			"::" AsPattern<out cexp>
			(. ht.Patterns.Add(cexp); .)
			{
				"::" AsPattern<out cexp>
				(. ht.Patterns.Add(cexp); .)
			}
		).
				
	LiteralPattern<out ElaPattern pat> =
		(
			(. 
				var lit = default(ElaLiteralValue);
				pat = null;
			.) 
			(
				stringTok (. lit = ParseString(t.val); .)
				| charTok (. lit = ParseChar(t.val); .)
				| intTok (. lit = ParseInt(t.val); .)
				| realTok (. lit = ParseReal(t.val); .)
				| "true" (. lit = new ElaLiteralValue(true); .)
				| "false" (. lit = new ElaLiteralValue(false); .)
			)
			(.
				pat = new ElaLiteralPattern(t) { Value = lit };				
			.)
		).		
			
	ListPattern<out ElaPattern pat> = 
		(.
			var cexp = default(ElaPattern); 
			var ht = default(ElaHeadTailPattern); 
			pat = null;
		.)
		"["
			[
				(.
					ht = new ElaHeadTailPattern(t);			
				.)
				AsPattern<out cexp> 
				(.  ht.Patterns.Add(cexp);  .)
				{ 
					"," AsPattern<out cexp> 
					(. ht.Patterns.Add(cexp); .)
				}
				(.
					ht.Patterns.Add(new ElaNilPattern(t));
					pat = ht;
				.)
			]
			(.
				if (pat == null)
					pat = new ElaNilPattern(t);
			.)
		"]".
			
	/* End Match */
		
		
	RecordLiteral<out ElaExpression exp> =
		(. 
			exp = null; 
			var fld = default(ElaFieldDeclaration);
		.)
		(
			"{"
				(. var rec = new ElaRecordLiteral(t); exp = rec; .) 
				RecordField<out fld> (. rec.Fields.Add(fld); .)				
				{ "," RecordField<out fld> (. rec.Fields.Add(fld); .) }
			"}"
		).
		
	RecordField<out ElaFieldDeclaration fld> = 
		(. 
			fld = null; 
			var cexp = default(ElaExpression);
		.)
		(
			(
				(
					(ident|variantTok)
					(. fld = new ElaFieldDeclaration(t) { FieldName = t.val }; .) 
					[						
						"=" Expr<out cexp> 
						(. fld.FieldValue = cexp; .)
					]
					(.
						if (fld.FieldValue == null)
							fld.FieldValue = new ElaVariableReference(t) { VariableName = t.val };
					.)
				)
				|
				(
					stringTok
					(. fld = new ElaFieldDeclaration(t) { FieldName = ReadString(t.val) }; .) 
					"=" 
					Expr<out cexp> 
					(. fld.FieldValue = cexp; .)
				)
			)
		).
		
	RangeExpr<ElaExpression first, ElaExpression sec, out ElaRange rng> = 
		(. 
			rng = new ElaRange(t) { First = first, Second = sec };
			var cexp = default(ElaExpression);
		.)
		".."
		[
			Expr<out cexp>
			(. rng.Last = cexp; .)
		].
		
				
	ParamList<. out List<ElaExpression> list, out ElaComprehension comp, out ElaRange rng .> =
		(. 
			var exp = default(ElaExpression); 
			list = null;
			comp = null;
			rng = null;
		.)
		Expr<out exp> 
		[
			ComprehensionExpr<exp, out comp>
			| 
			RangeExpr<exp, null, out rng>
			|
			(
				(. var oexp = exp; .)
				"," Expr<out exp> 
				(
					RangeExpr<oexp, exp, out rng>
					|
					(
						(. 
							list = new List<ElaExpression>();
							list.Add(oexp);
							list.Add(exp);
						.)
						{ 
							"," Expr<out exp> 
							(. list.Add(exp); .)
						}
					)
				)
			)
		]
		(.
			if (list == null && comp == null && rng == null && exp != null)
			{
				list = new List<ElaExpression>();
				list.Add(exp);
			}
		.).
		
	ListLiteral<out ElaExpression exp> = 
		"["
			(. 
				var list = default(List<ElaExpression>);
				var comp = default(ElaComprehension);
				var rng = default(ElaRange);
				var ot = t;
				
				exp = null;
			.)
			[ 
				(
					ParamList<out list, out comp, out rng> 
					(. 
						if (list != null)
						{
							var listExp = new ElaListLiteral(ot) { Values = list };
							exp = listExp;	
						}
						else if (comp != null)
						{
							comp.Initial = new ElaListLiteral(ot);
							exp = comp;
						}
						else if (rng != null)
						{
							rng.Initial = new ElaListLiteral(ot);
							exp = rng;
						}
					.)
				)
				|
				(
					(. var cexp = default(ElaExpression); .)
					"&" Expr<out cexp> ComprehensionExpr<cexp, out comp>
					(. 
						comp.Lazy = true;
						comp.Initial = new ElaListLiteral(ot);
						exp = comp;
					.)
				)
			] 
			(.
				if (exp == null)
					exp = new ElaListLiteral(ot);
			.)
		"]".
		
	LetBinding<out ElaExpression exp> = 
		(. 
			exp = null; 
			var inExp = default(ElaExpression);
			var flags = default(ElaVariableFlags);
		.)
		SYNC LET [VariableAttributes<ref flags>] 
		BindingBody<flags, out exp>
		WEAK IN Expr<out inExp>
		(. ((ElaBinding)exp).In = inExp; .).
		
	RootLetBinding<out ElaExpression exp> = 
		(. 
			exp = null; 
			var inExp = default(ElaExpression);
			var flags = default(ElaVariableFlags);
		.)
		(
			(. scanner.InjectBlock(); .) 
			SYNC LET 
			[VariableAttributes<ref flags>] 
			BindingBody<flags, out exp>
			(
				(
					WEAK IN Expr<out inExp> 
					(. ((ElaBinding)exp).In = inExp; .)	
					EndBlock
				)
				|
				EndBlock
			)	
		).
		
		
	VariableAttributes<ref ElaVariableFlags flags> =
		(
			(
				"private" (. flags |= ElaVariableFlags.Private; .)
			)
			|
			(
				"inline" (. flags |= ElaVariableFlags.Inline; .)					
			)
			|
			(
				"extends" (. flags |= ElaVariableFlags.Extends; .)					
			)
		)
		[VariableAttributes<ref flags>].			
		
	WhereBinding<out ElaExpression exp> = 
		(.
			var flags = default(ElaVariableFlags); 
			scanner.InjectBlock(); 
		.) 
		SYNC WHERE 
		[VariableAttributes<ref flags>] 			
		BindingBody<flags, out exp> 
		EndBlock.
		
	BindingGuard<out ElaExpression exp> = 
		(. exp = null; .)
		(
			BinaryExpr<out exp>
			{
				(. var old = exp; .)
				"," 
				(. var ot = t; .)
				BinaryExpr<out exp>
				(.
					exp = new ElaBinary(t) { Operator = ElaOperator.BooleanAnd, Left = old, Right = exp };
				.)
			}
		).
		
	BindingGuardList<ref ElaCondition cond> =
		(.
			var gexp = default(ElaExpression);
			var cexp = default(ElaExpression);
		.)
		(				
			"|" 
			(
				(
					(.
						var newCond = new ElaCondition(t);
						cond.False = newCond;
						cond = newCond;
					.)
					BindingGuard<out gexp> (. cond.Condition = gexp; .) "=" Expr<out cexp> (. cond.True = cexp; .)
					[ BindingGuardList<ref cond> ]
				)
				|
				(
					"else" "=" Expr<out cexp> (. cond.False = cexp; .)
				)
			)
		).
		
	BindingBody<ElaVariableFlags flags, out ElaExpression exp> =
		(. 
			var varExp = new ElaBinding(t) { VariableFlags = flags }; 
			exp = varExp;
			var cexp = default(ElaExpression); 
			var pat = default(ElaPattern);
		.)		
		(
			(
				ident (. varExp.VariableName = t.val; .)
				[
					  FunExpr<varExp>
					| BindingBodyGuards<varExp>
					| BindingBodyInit<varExp>
					| InfixFunExpr<new ElaVariablePattern(t) { Name = t.val },varExp>
				]
				(. SetObjectMetadata(varExp, cexp); .)
			)
			| 
			(
				BindingPattern<out pat> 
				(. 
					if (pat.Type != ElaNodeType.VariablePattern)
						varExp.Pattern = pat; 
					else
						varExp.VariableName = pat.GetName();
				.) 
				[ 
					BindingBodyInit<varExp> 
					| 
					(
						(. varExp.Pattern = null; .)
						InfixFunExpr<pat,varExp>
					)
					|
					(
						(. 
							if (pat.Type != ElaNodeType.VariablePattern)
								AddError(ElaParserError.InvalidFunctionDeclaration, pat);
						.)						
						FunExpr<varExp>
					)
					| 
					(
						BindingBodyGuards<varExp>
					)	
				]
			)
			| BindingBodyOperator<varExp>
		)		
		[
			WEAK ET BindingBody<flags, out exp>
			(.
				((ElaBinding)varExp).And = (ElaBinding)exp;
				exp = varExp;
			.)
		].
			
	BindingBodyOperator<ElaBinding varExp> =
		(
			Operators
			(. varExp.VariableName = t.val; .)
			(
			
				(
					FunExpr<varExp>
					(. 
						var fun = (ElaFunctionLiteral)varExp.InitExpression;
						fun.FunctionType = ElaFunctionType.Operator;
					.)
				)
				|
				(
					BindingBodyInit<varExp>
					(. 
						if (varExp.InitExpression.Type == ElaNodeType.FunctionLiteral)
							((ElaFunctionLiteral)varExp.InitExpression).FunctionType = ElaFunctionType.Operator;
					.)
				)
				| 
				(
					BindingBodyGuards<varExp>
				)					
			)
		).
		
	BindingBodyInit<ElaBinding varExp> =
		(. 
			var cexp = default(ElaExpression); 
			var cexp2 = default(ElaExpression);
		.)
		(
			"=" 
			(
				Expr<out cexp>
				|
				(
					"__internal" ident
					(. cexp = new ElaBuiltin(t) { Kind = Builtins.Kind(t.val) }; .)
				)
			)
			(. varExp.InitExpression = cexp; .)
			[
				WhereBinding<out cexp2> 
				(. varExp.Where = (ElaBinding)cexp2; .)
			]
		).
		
	BindingBodyGuards<ElaBinding varExp> = 
		(.
			var gexp = default(ElaExpression);
			var cexp3 = default(ElaExpression);
			var cond = new ElaCondition(t);
			varExp.InitExpression = cond;
		.)
		(
			"|" BindingGuard<out gexp> (. cond.Condition = gexp; .) 
			"=" Expr<out cexp3> (. cond.True = cexp3; .)
			[ BindingGuardList<ref cond> ]
		).
		
	InfixFunExpr<ElaPattern pat, ElaBinding varExp> =
		(
			(. 
				var ot = t;
				var mi = new ElaFunctionLiteral(t);
				varExp.InitExpression = mi;
				mi.Body = new ElaMatch(t);            
				scanner.InjectBlock(t.col);				
			.)	
			InfixFunBodyExprFirst<pat,mi>
			(. 
				varExp.VariableName = mi.Name;
				ProcessFunctionParameters(mi, ot, varExp); 
			.)			
		).
    
	InfixFunBodyExprFirst<ElaPattern pat, ElaFunctionLiteral fun> =
		(.
			var ot = t;
			var match = fun.Body;
			var cexp = default(ElaExpression);			
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
			entry.Pattern = pat;
		.)		
		(
			InfixFunName<fun> 
			[
				FuncPattern<out pat>
				(.
					var seq = new ElaPatternGroup(ot);
					seq.Patterns.Add(entry.Pattern);
					seq.Patterns.Add(pat);
					entry.Pattern = seq;
				.)
			]            
			[
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			(. if (RequireEndBlock()) .) EndBlock
			[ 
				(
					(
						(. scanner.InjectBlock(); .)
						InfixFunBodyExpr<fun>
					)
					| InfixChildFunBodyExpr<fun>
				)
			]
		).

	InfixFunBodyExpr<ElaFunctionLiteral fun> =
		(.
			var ot = t;
			var match = fun.Body;
			var pat = default(ElaPattern);
			var cexp = default(ElaExpression);			
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)		
		(
			( FuncPattern<out pat> (. entry.Pattern = pat; .) )
			InfixFunName<fun> 
			[
				FuncPattern<out pat>
				(.
					var seq = new ElaPatternGroup(ot);
					seq.Patterns.Add(entry.Pattern);
					seq.Patterns.Add(pat);
					entry.Pattern = seq;
				.)
			]            
			[
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			(. if (RequireEndBlock()) .) EndBlock
			[ 
				(
					(
						(. scanner.InjectBlock(); .)
						InfixFunBodyExpr<fun>
					)
					| InfixChildFunBodyExpr<fun>
				)
			]
		).
			
	InfixChildFunBodyExpr<ElaFunctionLiteral fun> =
		(.
			var ot = t;
			var match = fun.Body;
			var cexp = default(ElaExpression);
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)
		(
			Guard<out cexp>
			(. entry.Guard = cexp; .)
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			(. if (RequireEndBlock()) .) EndBlock
			[ 
				(
					(
						(. scanner.InjectBlock(); .)
						InfixFunBodyExpr<fun>
					)
					| InfixChildFunBodyExpr<fun>
				)
			]
		).
	    
	InfixFunName<ElaFunctionLiteral fun> = 
		(
			(. var name = String.Empty; .)
			("`" ident (. name = t.val; .) "`"| Operators (. name = t.val; .))
			(.
				if (String.IsNullOrEmpty(fun.Name))
					fun.Name = name;
				else if (name != fun.Name)
					AddError(ElaParserError.InvalidFunctionDeclaration, name);
			.)
		).
		
	Operators = operatorTok1|operatorTok2|operatorTok3|operatorTok4|operatorTok5|operatorTok6|operatorTok7|operatorTok8|operatorTok9|"::".
		
	FunName<ElaFunctionLiteral fun> = 
		(. string val = ""; .)
		(
			(
				ident (. val = t.val; .)
				| Operators (. val = t.val; .)
				| "(" Operators (. val = t.val; .) ")"
			)
			(.
				if (val != fun.Name)
					AddError(ElaParserError.InvalidFunctionDeclaration, t.val);
			.)
		).
		
	FunExpr<ElaBinding varExp> =
		(
			(. 
				var ot = t;
				var mi = new ElaFunctionLiteral(t);
				mi.Name = varExp.VariableName;
				varExp.InitExpression = mi;
				mi.Body = new ElaMatch(t);
				scanner.InjectBlock(t.col);				
			.)	
			FunBodyExpr<mi>
			(. ProcessFunctionParameters(mi, ot, varExp); .)			
		).
		
	FunBodyExpr<ElaFunctionLiteral fun> =
		(.
			var ot = t;
			var match = fun.Body;
			var pat = default(ElaPattern);
			var seq = default(ElaPatternGroup);
			var cexp = default(ElaExpression);			
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)		
		(
			(	
				FuncPattern2<out pat> (. entry.Pattern = pat; .)
				{ 
					FuncPattern2<out pat> 
					(. 
						if (seq == null)
						{
							seq = new ElaPatternGroup(ot);
							seq.Patterns.Add(entry.Pattern);
							entry.Pattern = seq;							
						}
					
						seq.Patterns.Add(pat); 
					.) 
				} 				
			)
			[
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			(. if (RequireEndBlock()) .) EndBlock
			[ 
				(
					(
						(. scanner.InjectBlock(); .)
						FunName<fun> FunBodyExpr<fun>
					)
					| ChildFunBodyExpr<fun>
				)
			]
		).
		
	ChildFunBodyExpr<ElaFunctionLiteral fun> =
		(.
			var ot = t;
			var match = fun.Body;
			var cexp = default(ElaExpression);
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)
		(
			Guard<out cexp>
			(. entry.Guard = cexp; .)
			"=" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
			[ WhereBinding<out cexp> (. entry.Where = cexp; .) ]
			(. if (RequireEndBlock()) .) EndBlock
			[ 
				(
					(
						(. scanner.InjectBlock(); .)
						FunName<fun> FunBodyExpr<fun>
					)
					| ChildFunBodyExpr<fun>
				)
			]
		).
		
	LambdaExpr<out ElaExpression exp> =
		SYNC LAMBDA
		(.
			var ot = t;
			var pat = default(ElaPattern);
			var seq = default(ElaPatternGroup);
			
			var mi = new ElaFunctionLiteral(t);
			exp = mi;
			var match = new ElaMatch(t);
			mi.Body = match;
			
			var entry = new ElaMatchEntry(t);
			match.Entries.Add(entry);
		.)
		(
			(		
				FuncPattern2<out pat> (. entry.Pattern = pat; .)
				{ 
					FuncPattern2<out pat> 
					(. 
						if (seq == null)
						{
							seq = new ElaPatternGroup(ot);
							seq.Patterns.Add(entry.Pattern);
							entry.Pattern = seq;							
						}
					
						seq.Patterns.Add(pat); 
					.) 
				} 				
			)
			[
				(. var cexp = default(ElaExpression); .)
				Guard<out cexp>
				(. entry.Guard = cexp; .)
			]
			"->" 
			(
				(. var fexp = default(ElaExpression); .)
				Expr<out fexp>
				(. entry.Expression = fexp; .)
			)
		).
		
	IncludeStat<out ElaExpression exp> = 
		(. exp = null; .)
		(
			(. scanner.InjectBlock(); .)
			SYNC OPEN (. var inc = new ElaModuleInclude(t); .)
			[ QUALIFIED (. inc.RequireQuailified = true; .) ]
			Qualident<inc.Path>
			(.
				var name = inc.Path[inc.Path.Count - 1];				
				inc.Path.RemoveAt(inc.Path.Count - 1);				
				inc.Alias = inc.Name = name;
				exp = inc;
			.)	
			[
				"#"
				(
					ident (. inc.DllName = t.val; .)
					| variantTok (. inc.DllName = t.val; .)
					| stringTok (. inc.DllName = ReadString(t.val); .)
				)
			]		
			[ "@" ident (. inc.Alias = t.val; .) ]
			[
				(. var imp = default(ElaImportedVariable); .)
				"("
					ImportName<out imp> (. inc.ImportList.Add(imp); .)
					{ "," ImportName<out imp> (. inc.ImportList.Add(imp); .) }
				")"
			]
			EBLOCK
		).
		
	ImportName<out ElaImportedVariable imp> =
		(. imp = new ElaImportedVariable(t); .)
		(
			[ "private" (. imp.Private = true; .) ]
			ident (. imp.Name = imp.LocalName = t.val; .)
			[ "=" ident (. imp.Name = t.val; .) ]
		).
		
	Qualident<. List<String> path .> = 
		(. var val = String.Empty; .)
		(
			ident (. val = t.val; .)
			| variantTok (. val = t.val; .)
			| stringTok (. val = ReadString(t.val); .)
		)
		(. path.Add(val); .)
		[ "." Qualident<path> ].
	
	IfExpr<out ElaExpression exp> = 
		IFS
		(. 
			var cond = new ElaCondition(t); 
			var cexp = default(ElaExpression);	
			exp = cond;
		.)
		Expr<out cexp> (. cond.Condition = cexp; .)
		THEN Expr<out cexp> (. cond.True = cexp; .)
		WEAK ELSE Expr<out cexp> (. cond.False = cexp; .).
    
	RaiseExpr<out ElaExpression exp> = 
		RAISE
		(. 
			var r = new ElaRaise(t);
			exp = r;
			var cexp = default(ElaExpression); 
			var code = String.Empty;
		.)		
		variantTok (. code = t.val; .)
		(Expr<out cexp>|  )
		(. 
			r.ErrorCode = code;
			r.Expression = cexp; 
		.).
		
	FailExpr<out ElaExpression exp> = 
		FAIL
		(. 
			var r = new ElaRaise(t);
			exp = r;
			var cexp = default(ElaExpression); 
		.)		
		Expr<out cexp>
		(. 
			r.Expression = cexp; 
			r.ErrorCode = "Failure"; 
		.).	
		
	TryExpr<out ElaExpression exp> =
		(. scanner.InjectBlock(); .)
		TRY
		(. 
			var ot = t;
			var match = new ElaTry(t);
			exp = match; 
			var cexp = default(ElaExpression);
		.)		
		Expr<out cexp> (. match.Expression = cexp; .)
		WITH
		(
			(. scanner.InjectBlock(); .)
			MatchEntry<match> 
			EndBlock
			{ 
				(. scanner.InjectBlock(); .)
				MatchEntry<match> 
				EndBlock
			}
		)	
		EndBlock.
			
	/* Expr */
					
	OrExpr<out ElaExpression exp> =
		AndExpr<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"or" AndExpr<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaOperator.BooleanOr, Right = cexp }; 
			.)			
		}.
		
	AndExpr<out ElaExpression exp> =
		OpExpr1<out exp>
		{
			(. var cexp = default(ElaExpression); .)
			"and" OpExpr1<out cexp>
			(. 
				exp = new ElaBinary(t) { 
					Left = exp, Operator = ElaOperator.BooleanAnd, Right = cexp }; 
			.)
		}.	
			
	OpExpr1<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr1b<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok1 (. op = t.val; .)
					[ OpExpr1b<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok1 (. op = t.val; .)
				[ 
					OpExpr1b<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = op };
				.)
			)
		).
			
	OpExpr1b<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr2<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok9 (. op = t.val; .)
					[ OpExpr1b<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}			
			)
			|
			(
				operatorTok9 (. op = t.val; .)
				[ 
					OpExpr2<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
			
	OpExpr2<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr3<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok2 (. op = t.val; .)
					[ OpExpr3<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok2 (. op = t.val; .)
				[ 
					OpExpr3<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
			
			
	OpExpr3<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr4<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					(operatorTok3|"::") (. op = t.val; .)
					[ OpExpr3<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}			
			)
			|
			(
				(operatorTok3|"::") (. op = t.val; .)
				[ 
					OpExpr4<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	OpExpr4<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr5<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok4 (. op = t.val; .)
					[ OpExpr5<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok4 (. op = t.val; .)
				[ 
					OpExpr5<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	OpExpr5<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				CastExpr<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok5 (. op = t.val; .)
					[ CastExpr<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				operatorTok5 (. op = t.val; .)
				[ 
					CastExpr<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	CastExpr<out ElaExpression exp> = 
		InfixExpr<out exp>
		{
			(
				(
					(. var pat = default(ElaPattern); .)
					IS IsOperatorPattern<out pat> 
					(. exp = new ElaIs(t) { Expression = exp, Pattern = pat }; .)
				)
				|
				COMPH ComprehensionOpExpr<exp, out exp>
			)
		}.		
		
	ComprehensionOpExpr<ElaExpression init, out ElaExpression exp> =
		(.
			var list = default(List<ElaExpression>);
			var comp = default(ElaComprehension);
			var rng = default(ElaRange);
			exp = null;
		.)
		(
			"["
				(
					ParamList<out list, out comp, out rng>
					(.
						if (rng != null) {
							rng.Initial = init;
							exp = rng;
						}
						else if (comp != null) {
							comp.Initial = init;
							exp = comp;
						}
						else {
							AddError(ElaParserError.ComprehensionOpInvalidOperand);
							exp = new ElaRange();
						}
					.)
				)
			"]"		
		).
		
	InfixExpr<out ElaExpression exp> = 
		(. 
			exp = null;
			var ot = t; 
			var funexp = default(ElaExpression);
		.)				
		(
			(
				OpExpr6<out exp>
				{
					(. 
						var cexp = default(ElaExpression); 
						ot = t;
					.)
					(
						"`" Literal<out funexp> "`"
					)
					[ OpExpr6<out cexp> ]
					(. 
						var fc = new ElaFunctionCall(ot) { 
								Target = funexp
							};
						fc.Parameters.Add(exp);			
						
						if (cexp != null)
							fc.Parameters.Add(cexp);
										
						exp = fc;
					.)
				}
			)
			|
			(
				(
					"`" Literal<out funexp> "`"
				)
				[ 
					OpExpr6<out exp> 
					(. exp = GetPrefixFun(funexp, exp, true);	.)
				]
				(.
					if (exp == null)
						exp = funexp;
				.)				
			)
		).
		
	OpExpr6<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr7<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok6 (. op = t.val; .)
					[ OpExpr6<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}			
			)
			|
			(
				operatorTok6 (. op = t.val; .)
				[ 
					OpExpr7<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	OpExpr7<out ElaExpression exp> =
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OpExpr8<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					operatorTok7 (. op = t.val; .)
					[ OpExpr8<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}			
			)
			|
			(
				operatorTok7 (. op = t.val; .)
				[ 
					OpExpr8<out exp> 
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
		
	OpExpr8<out ElaExpression exp> = 
		(. 
			var op = String.Empty; 
			exp = null;
			var ot = t; 
		.)
		(
			(
				Application<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					(operatorTok8) (. op = t.val; .)
					[ Application<out cexp> ]
					(. exp = GetOperatorFun(op, exp, cexp); .)
				}
			)
			|
			(
				(operatorTok8) (. op = t.val; .)
				[ 
					Application<out exp>
					(. exp = GetOperatorFun(op, null, exp); .)
				]
				(.
					if (exp == null)
						exp = new ElaVariableReference(ot) { VariableName = t.val };
				.)
			)
		).
			
	Application<out ElaExpression exp> = 
		(. exp = null; .)
		(
			AccessExpr<out exp>
			(. 
				var ot = t;
				var mi = default(ElaFunctionCall); 
				var cexp = default(ElaExpression);
			.)	
			{
				AccessExpr<out cexp>					
				(. 
					if (mi == null)
					{
						mi = new ElaFunctionCall(ot) { Target = exp };
						exp = mi; 
					}
				
					mi.Parameters.Add(cexp); 
				.)					
			}								
		).
		
	AccessExpr<out ElaExpression exp> =
		Literal<out exp>
		{ 
			"."
			(
				(
					"("
						(ident|variantTok|Operators)
						(. exp = new ElaFieldReference(t) { FieldName = t.val, TargetObject = exp }; .)
					")"
				)
				|
				(
					(ident|variantTok)
					(. exp = new ElaFieldReference(t) { FieldName = t.val, TargetObject = exp }; .)
				)
			)			
		}.	
					
	BinaryExpr<out ElaExpression exp> = 
		(. 
			exp = null;
			var ot = t; 
		.)				
		(
			(
				OrExpr<out exp>
				{
					(. var cexp = default(ElaExpression); .)
					"$"
					OrExpr<out cexp>
					(. 
						exp = new ElaBinary(t) { Operator = ElaOperator.Sequence, Left = exp, Right = cexp };
					.)
				}
			)
		).	
		
	EmbExpr<out ElaExpression exp> = 
		(. exp = null; .)
		( 
			BinaryExpr<out exp>
			| IfExpr<out exp> 
			| LambdaExpr<out exp>
			| RaiseExpr<out exp>
			| FailExpr<out exp>
			| MatchExpr<out exp>		
			| TryExpr<out exp>			
		).
				
	WhereExpr<ElaExpression cexp, out ElaExpression exp> =
	    WhereBinding<out exp>
        (.
            ((ElaBinding)exp).In = cexp;
        .).
        
	Expr<out ElaExpression exp> = 
		(. exp = null; .)
		( 
			EmbExpr<out exp>
			| LetBinding<out exp>
		).
		
	LazyExpr<out ElaExpression exp> =
		(
			"&" 
			(. var lazy = new ElaLazyLiteral(t); .)
			Expr<out exp>
			(.
				var m = new ElaMatch(t);
				m.Entries.Add(new ElaMatchEntry { Pattern = new ElaUnitPattern(), Expression = exp });
				lazy.Body = m;
				exp = lazy;
			.)
		).
	
	ComprehensionExpr<ElaExpression sel, out ElaComprehension exp> =
		(. 	
			var it = default(ElaGenerator); 
			var ot = t;		
		.)
		"\\\\" ComprehensionEntry<sel, out it>
		(. exp = new ElaComprehension(ot) { Generator = it }; .).
		
	ComprehensionEntry<ElaExpression body, out ElaGenerator it> =
		(.
			it = new ElaGenerator(t);
			it.Body = body;
			var cexp = default(ElaExpression);
			var pat = default(ElaPattern);
		.)
		(
			GeneratorPattern<out pat> "<-" Expr<out cexp>
			(. 
				it.Pattern = pat;
				it.Target = cexp;
			.)
		)
		[ 
			(
				(. var cit = default(ElaGenerator); .)
				"," ComprehensionEntry<body, out cit>
				(. it.Body = cit; .)
			)
			|
			(
				Guard<out cexp>
				(. it.Guard = cexp; .)
			)
		].
		
	Ela = 
		(
			(.
				var b = new ElaBlock(t);
				Expression = b;
			.)			
			DeclarationBlock<b> { DeclarationBlock<b> }
		).		
		
	DeclarationBlock<ElaBlock b> =
		(. var exp = default(ElaExpression); .)
		(
			RootLetBinding<out exp>
			| IncludeStat<out exp>
			| EmbExpr<out exp> [WhereExpr<exp, out exp>](. if (FALSE) .) EBLOCK	
		)
		(. b.Expressions.Add(exp); .).
		
END Ela.